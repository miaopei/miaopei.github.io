<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="icon" type="image/png" sizes="32x32" href="/images/mrmiaow-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/mrmiaow-16.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"miaopei.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"show_result":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 基本命令1.1 shell 格式输出12345678$ echo &#x27;Hello world !&#x27;-n	# 忽略结尾的换行符-e	# 激活转义字符-E	# disable转义字符# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。$ echo -e &quot;1\t2\t3&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell脚本攻略笔记">
<meta property="og:url" content="http://miaopei.github.io/2017/05/15/Shell/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Mr.Miaow Blog">
<meta property="og:description" content="1. 基本命令1.1 shell 格式输出12345678$ echo &#x27;Hello world !&#x27;-n	# 忽略结尾的换行符-e	# 激活转义字符-E	# disable转义字符# echo会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。$ echo -e &quot;1\t2\t3&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-05-15T07:40:41.000Z">
<meta property="article:modified_time" content="2024-06-17T08:35:15.677Z">
<meta property="article:author" content="Mr.Miaow">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://miaopei.github.io/2017/05/15/Shell/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://miaopei.github.io/2017/05/15/Shell/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/","path":"2017/05/15/Shell/Shell脚本攻略笔记/","title":"Shell脚本攻略笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Shell脚本攻略笔记 | Mr.Miaow Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Mr.Miaow Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Mr.Miaow Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Do what you say, say what you do.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-messages"><a href="/messages/" rel="section"><i class="fa fa-comment fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-text">1. 基本命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-shell-%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="nav-text">1.1 shell 格式输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4-tr"><span class="nav-text">1.2 替换命令 tr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%89%93%E5%8D%B0%E5%8F%98%E9%87%8F"><span class="nav-text">1.3 打印变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">1.4 设置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Shell%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%BC%95%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">1.5 Shell中三种引号的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%8E%B7%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">1.6 获得字符串的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E8%AF%86%E5%88%AB%E5%BD%93%E5%89%8Dshell"><span class="nav-text">1.7 识别当前shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E4%BD%BF%E7%94%A8shell%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-text">1.8 使用shell进行数学运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-shell%E4%B8%AD%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8-%E3%80%81-%E3%80%81-%E3%80%81-%E3%80%81"><span class="nav-text">1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-1-%E5%B0%8F%E6%8B%AC%E5%8F%B7%EF%BC%8C%E5%9C%86%E6%8B%AC%E5%8F%B7%EF%BC%88%EF%BC%89"><span class="nav-text">1.9.1 小括号，圆括号（）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-2-%E4%B8%AD%E6%8B%AC%E5%8F%B7%EF%BC%8C%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="nav-text">1.9.2 中括号，方括号[]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E3%80%81%E8%8A%B1%E6%8B%AC%E5%8F%B7"><span class="nav-text">1.9.3 大括号、花括号 {}</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-%E7%AC%A6%E5%8F%B7-%E5%90%8E%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text">1.9.4 符号$后的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-5-%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="nav-text">1.9.5 多条命令执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-Shell%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F-0-%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">1.10 Shell特殊变量 &#96;$0, $#, $*, $@, $?, ### 和命令行参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">1.10.1 命令行参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-2-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.10.2 $* 和 $@ 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="nav-text">1.10.3 退出状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-Shell%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">1.11 Shell重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-Shell%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84"><span class="nav-text">1.12 Shell数组和关联数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">1.12.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84"><span class="nav-text">1.12.2 定义打印普通数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-3-%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84"><span class="nav-text">1.12.3 定义打印关联数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="nav-text">1.13 使用别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-%E8%8E%B7%E5%8F%96%E3%80%81%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E5%92%8C%E5%BB%B6%E6%97%B6"><span class="nav-text">1.14 获取、设置日期和延时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95"><span class="nav-text">1.15 脚本调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-1%E4%BD%BF%E7%94%A8%E9%80%89%E9%A1%B9%E2%80%93x%EF%BC%8C%E5%90%AF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E7%9A%84%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="nav-text">1.15.1使用选项–x，启用shell脚本的跟踪调试功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-2-%E4%BD%BF%E7%94%A8set-x%E5%92%8Cset-x%E5%AF%B9%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E8%B0%83%E8%AF%95"><span class="nav-text">1.15.2 使用set -x和set +x对脚本进行部分调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-3-%E9%80%9A%E8%BF%87%E4%BC%A0%E9%80%92-DEBUG%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%B0%83%E8%AF%95"><span class="nav-text">1.15.3 通过传递 _DEBUG环境变量调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-4-%E5%88%A9%E7%94%A8shebang%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="nav-text">1.15.4 利用shebang来进行调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">1.16 函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-read%E5%91%BD%E4%BB%A4"><span class="nav-text">1.17 read命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-18-%E6%9D%A1%E4%BB%B6%E6%AF%94%E8%BE%83%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="nav-text">1.18 条件比较与测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="nav-text">补充内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%A9%E7%94%A8%E5%AD%90shell%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-text">1. 利用子shell生成一个独立的进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-text">2. 无限循环的实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%91%BD%E4%BB%A4%E4%B9%8B%E4%B9%90"><span class="nav-text">2. 命令之乐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-cat%E5%91%BD%E4%BB%A4"><span class="nav-text">2.1 cat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-find%E5%91%BD%E4%BB%A4"><span class="nav-text">2.2 find命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%8E%A9%E8%BD%ACxargs"><span class="nav-text">2.3 玩转xargs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%B0%86%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8D%95%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="nav-text">2.3.1 将多行输入转换成单行输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%B0%86%E5%8D%95%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="nav-text">2.3.2 将单行输入转换成多行输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%AE%9A%E5%88%B6%E5%AE%9A%E7%95%8C%E7%AC%A6"><span class="nav-text">2.3.3 定制定界符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E8%AF%BB%E5%8F%96stdin%EF%BC%8C%E5%B0%86%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%91%BD%E4%BB%A4"><span class="nav-text">2.3.4 读取stdin，将格式化参数传递给命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%A0%A1%E9%AA%8C%E5%92%8C%E4%B8%8E%E6%A0%B8%E5%AE%9E"><span class="nav-text">2.4 校验和与核实</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%95%A3%E5%88%97"><span class="nav-text">2.4.1 加密工具与散列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%8E%92%E5%BA%8F%E3%80%81%E5%94%AF%E4%B8%80%E4%B8%8E%E9%87%8D%E5%A4%8D"><span class="nav-text">2.5 排序、唯一与重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">2.6 临时文件命名与随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-split-%E5%88%86%E5%89%B2%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="nav-text">2.7 split 分割文件和数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-%E6%A0%B9%E6%8D%AE%E6%89%A9%E5%B1%95%E5%90%8D%E5%88%87%E5%88%86%E6%96%87%E4%BB%B6%E5%90%8D-%E3%80%81"><span class="nav-text">2.7.1 根据扩展名切分文件名$、##</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E5%92%8C%E7%A7%BB%E5%8A%A8"><span class="nav-text">2.8 批量重命名和移动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%A5%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8D"><span class="nav-text">3 以文件之名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%94%9F%E6%88%90%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">3.1 生成任意大小的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E3%80%81%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E7%B2%98%E6%BB%9E%E4%BD%8D"><span class="nav-text">3.2 文件权限、所有权和粘滞位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-text">3.3 创建不可修改的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%9F%A5%E6%89%BE%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%8F%8A%E5%85%B6%E6%8C%87%E5%90%91%E7%9B%AE%E6%A0%87"><span class="nav-text">3.4 查找符号链接及其指向目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%88%97%E4%B8%BE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">3.5 列举文件类型统计信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%9B%9E%E6%96%87%E4%BB%B6"><span class="nav-text">3.6 使用环回文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E7%94%9F%E6%88%90-ISO-%E6%96%87%E4%BB%B6%E5%8F%8A%E6%B7%B7%E5%90%88%E5%9E%8B-ISO"><span class="nav-text">3.7 生成 ISO 文件及混合型 ISO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-diff%E5%91%BD%E4%BB%A4"><span class="nav-text">3.8 diff命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-more%E3%80%81less%E3%80%81head%E4%B8%8Etail%E5%91%BD%E4%BB%A4"><span class="nav-text">3.9 more、less、head与tail命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1-more%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%BE%93%E5%87%BA%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7"><span class="nav-text">3.9.1 more文件内容输出查看工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-2-less%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B7%A5%E5%85%B7"><span class="nav-text">3.9.2 less查看文件内容工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-3-head"><span class="nav-text">3.9.3 head</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-4-tail"><span class="nav-text">3.9.4 tail</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-getopts-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-text">3.10 getopts 参数解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-1-getopts%EF%BC%88shell%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="nav-text">3.10.1 getopts（shell内置命令）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-2-getopt%EF%BC%88%E4%B8%80%E4%B8%AA%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%EF%BC%89"><span class="nav-text">3.10.2 getopt（一个外部工具）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-%E5%8F%AA%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">3.11 只列出目录的各种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-%E4%BD%BF%E7%94%A8pushd%E5%92%8Cpopd%E8%BF%9B%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D"><span class="nav-text">3.12 使用pushd和popd进行快速定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-tree%E6%89%93%E5%8D%B0%E7%9B%AE%E5%BD%95%E6%A0%91"><span class="nav-text">3.13 tree打印目录树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AE%A9%E6%96%87%E4%BB%B6%E9%A3%9E"><span class="nav-text">4 让文件飞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">4.1 正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-grep%E5%91%BD%E4%BB%A4"><span class="nav-text">4.2 grep命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-cut-%E6%8C%89%E5%88%97%E5%88%87%E5%88%86%E6%96%87%E4%BB%B6"><span class="nav-text">4.3 cut 按列切分文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-sed-%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2"><span class="nav-text">4.4 sed 进行文本替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-awk-%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-text">4.5 awk 进行高级文本处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-awk-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="nav-text">4.5.1 awk 常用命令选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-awk-%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">4.5.2 awk 脚本基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-awk-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">4.5.3 awk 的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-awk-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F%EF%BC%88%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-text">4.5.4 awk 内置变量（预定义变量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-%E5%B0%86%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%80%BC%E4%BC%A0%E9%80%92%E7%BB%99awk"><span class="nav-text">4.5.5 将外部变量值传递给awk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-awk-%E8%BF%90%E7%AE%97%E4%B8%8E%E5%88%A4%E6%96%AD"><span class="nav-text">4.5.6 awk 运算与判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-7-awk-%E9%AB%98%E7%BA%A7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">4.5.7 awk 高级输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-8-%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%AE%9A%E7%95%8C%E7%AC%A6"><span class="nav-text">4.5.8 设置字段定界符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text">4.5.9 流程控制语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-10-%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8"><span class="nav-text">4.5.10 数组应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-11-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-text">4.5.11 内置函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-find-%E5%AF%B9%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2"><span class="nav-text">4.6 find 对目录中的所有文件进行文本替换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%80%E5%9B%A2%E4%B9%B1%E9%BA%BB"><span class="nav-text">5 一团乱麻</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-wget%E5%91%BD%E4%BB%A4"><span class="nav-text">5.1 wget命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-curl-%E5%91%BD%E4%BB%A4"><span class="nav-text">5.2 curl 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-curl-wget%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9Fhttp%E7%9A%84get-post%E8%AF%B7%E6%B1%82"><span class="nav-text">5.3 curl wget两种方法模拟http的get post请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-B%E8%AE%A1%E5%88%92"><span class="nav-text">6 B计划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%94%A8tar%E5%BD%92%E6%A1%A3"><span class="nav-text">6.1 用tar归档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%94%A8cpio%E5%BD%92%E6%A1%A3"><span class="nav-text">6.2 用cpio归档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%BD%BF%E7%94%A8gzip%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE"><span class="nav-text">6.3 使用gzip压缩数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E7%94%A8-zip-%E5%BD%92%E6%A1%A3%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="nav-text">6.4 用 zip 归档和压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7-pbzip2"><span class="nav-text">6.5 更快的归档工具 pbzip2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E5%88%9B%E5%BB%BA%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">6.6 创建压缩文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E4%BD%BF%E7%94%A8-rsync-%E5%A4%87%E4%BB%BD%E7%B3%BB%E7%BB%9F%E5%BF%AB%E7%85%A7"><span class="nav-text">6.7 使用 rsync 备份系统快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-%E7%94%A8-fsarchiver-%E5%88%9B%E5%BB%BA%E5%85%A8%E7%9B%98%E9%95%9C%E5%83%8F"><span class="nav-text">6.8 用 fsarchiver 创建全盘镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%97%A0%E7%BD%91%E4%B8%8D%E5%88%A9"><span class="nav-text">7 无网不利</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C"><span class="nav-text">7.1 设置网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-traceroute-%E5%91%BD%E4%BB%A4"><span class="nav-text">7.2 traceroute 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%88%97%E5%87%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%B4%BB%E5%8A%A8%E4%B8%BB%E6%9C%BA-fping"><span class="nav-text">7.3 列出网络上所有的活动主机 (fping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-ssh-%E5%91%BD%E4%BB%A4"><span class="nav-text">7.4 ssh 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6"><span class="nav-text">7.5 通过网络传输文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BA%BF%E7%BD%91%E7%BB%9C"><span class="nav-text">7.6 连接网线网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%8C%82%E8%BD%BD%E7%82%B9%E4%B8%8A%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-text">7.7 在本地挂载点上挂载远程驱动器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%88%86%E6%9E%90"><span class="nav-text">7.8 网络流量与端口分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-text">7.9 创建套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10-iptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE"><span class="nav-text">7.10 iptables防火墙设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%BD%93%E4%B8%AA%E5%A5%BD%E7%AE%A1%E5%AE%B6"><span class="nav-text">8 当个好管家</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E7%9B%91%E8%A7%86%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">8.1 监视磁盘使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E8%AE%A1%E7%AE%97%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="nav-text">8.2 计算命令执行时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E6%94%B6%E9%9B%86%E4%B8%8E%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E3%80%81%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%95%85%E9%9A%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-text">8.3 收集与当前登录用户、启动日志及启动故障的相关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E4%BD%BF%E7%94%A8-watch-%E7%9B%91%E8%A7%86%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA"><span class="nav-text">8.4 使用 watch 监视命令输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E7%94%A8-logrotate-%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-text">8.5 用 logrotate 管理日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E7%94%A8-syslog-%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="nav-text">8.6 用 syslog 记录日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-%E9%80%9A%E8%BF%87%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%89%BE%E5%87%BA%E5%85%A5%E4%BE%B5%E8%80%85"><span class="nav-text">8.7 通过监视用户登录找出入侵者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-%E7%9B%91%E8%A7%86%E7%A3%81%E7%9B%98%E6%B4%BB%E5%8A%A8"><span class="nav-text">8.8 监视磁盘活动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-9-%E6%A3%80%E6%9F%A5%E7%A3%81%E7%9B%98%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF"><span class="nav-text">8.9 检查磁盘及文件系统错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%AE%A1%E7%90%86%E9%87%8D%E4%BB%BB"><span class="nav-text">9 管理重任</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E6%94%B6%E9%9B%86%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-text">9.1 收集进程信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-which%E3%80%81-whereis%E3%80%81-file%E3%80%81-whatis%E4%B8%8E%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD"><span class="nav-text">9.2 which、 whereis、 file、 whatis与平均负载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%8F%91%E9%80%81%E6%88%96%E5%93%8D%E5%BA%94%E4%BF%A1%E5%8F%B7"><span class="nav-text">9.3 杀死进程以及发送或响应信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-%E5%90%91%E7%94%A8%E6%88%B7%E7%BB%88%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text">9.4 向用户终端发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="nav-text">9.5 采集系统信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-%E4%BD%BF%E7%94%A8-proc-%E9%87%87%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="nav-text">9.6 使用 proc 采集信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-%E7%94%A8-cron-%E8%BF%9B%E8%A1%8C%E8%B0%83%E5%BA%A6"><span class="nav-text">9.7 用 cron 进行调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-%E4%BB%8E%E7%BB%88%E7%AB%AF%E6%88%AA%E5%9B%BE"><span class="nav-text">9.8 从终端截图</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mr.Miaow"
      src="https://avatars.githubusercontent.com/u/7922626?v=4">
  <p class="site-author-name" itemprop="name">Mr.Miaow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>
      RSS
    </a>
  </div>

  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/miaopei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;miaopei" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/miaopei163@163.com" title="E-Mail → miaopei163@163.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


          <link rel="stylesheet" href="/dist/APlayer.min.css">
          <div id="aplayer"></div>
          <script type="text/javascript" src="/dist/APlayer.min.js"></script>
          <script type="text/javascript" src="/dist/music.js"></script>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://miaopei.github.io/2017/05/15/Shell/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/7922626?v=4">
      <meta itemprop="name" content="Mr.Miaow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Miaow Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Shell脚本攻略笔记 | Mr.Miaow Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Shell脚本攻略笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-15 15:40:41" itemprop="dateCreated datePublished" datetime="2017-05-15T15:40:41+08:00">2017-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>88k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:20</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-shell-格式输出"><a href="#1-1-shell-格式输出" class="headerlink" title="1.1 shell 格式输出"></a>1.1 shell 格式输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;Hello world !&#x27;</span></span></span><br><span class="line">-n	# 忽略结尾的换行符</span><br><span class="line">-e	# 激活转义字符</span><br><span class="line">-E	# disable转义字符</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>会将一个换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;1\t2\t3&quot;</span></span></span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>打印彩色输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">彩色文本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;\e[1;31m This is red text \e[0m&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">彩色背景</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;\e[1;42m Green Background \e[0m&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&quot;%-5s %-10s %-4s\n&quot;</span> No Name Mark</span></span><br></pre></td></tr></table></figure>

<p><strong>原理：</strong></p>
<p><code> %-5s</code> 指明了一个格式为左对齐且宽度为5的字符串替换（ <code>- </code>表示左对齐）。如果不用 <code>-</code> 指定对齐方式，字符串就采用右对齐形式。</p>
<p><code>%s</code> 、 <code>%c</code> 、<code>%d</code> 和 <code>%f</code> 都是格式替换符（format substitution character），其所对应的参数可以置于带引号的格式字符串之后。 </p>
<h3 id="1-2-替换命令-tr"><a href="#1-2-替换命令-tr" class="headerlink" title="1.2 替换命令 tr"></a>1.2 替换命令 tr</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">tr</span> 是 translate的简写</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> <span class="string">&#x27;\0&#x27;</span> <span class="string">&#x27;\n&#x27;</span>		<span class="comment"># 将 \0 替换成 \n</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> [选项]… 集合1 [集合2]</span></span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br><span class="line"></span><br><span class="line">字符集合的范围：</span><br><span class="line">\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</span><br><span class="line">\\ 反斜杠</span><br><span class="line">\a Ctrl-G 铃声</span><br><span class="line">\b Ctrl-H 退格符</span><br><span class="line">\f Ctrl-L 走行换页</span><br><span class="line">\n Ctrl-J 新行</span><br><span class="line">\r Ctrl-M 回车</span><br><span class="line">\t Ctrl-I tab键</span><br><span class="line">\v Ctrl-X 水平制表符</span><br><span class="line">CHAR1-CHAR2 从CHAR1 到 CHAR2的所有字符按照ASCII字符的顺序</span><br><span class="line">[CHAR*] in SET2, copies of CHAR until length of SET1</span><br><span class="line">[CHAR*REPEAT] REPEAT copies of CHAR, REPEAT octal if starting with 0</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有字母</span><br><span class="line">[:blank:] 水平制表符，空白等</span><br><span class="line">[:cntrl:] 所有控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字符</span><br><span class="line">[:print:] 所有可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有的横向或纵向的空白</span><br><span class="line">[:upper:] 所有大写字母</span><br></pre></td></tr></table></figure>

<h3 id="1-3-打印变量"><a href="#1-3-打印变量" class="headerlink" title="1.3 打印变量"></a>1.3 打印变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-设置环境变量"><a href="#1-4-设置环境变量" class="headerlink" title="1.4 设置环境变量"></a>1.4 设置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在PATH中添加一条新路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/home/user/bin&quot;</span></span></span><br><span class="line">也可以使用：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/home/user/bin&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-Shell中三种引号的用法"><a href="#1-5-Shell中三种引号的用法" class="headerlink" title="1.5 Shell中三种引号的用法"></a>1.5 Shell中三种引号的用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单引号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用单引号时，变量不会被扩展（<span class="built_in">expand</span>），将依照原样显示。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;$var&#x27;</span> will <span class="built_in">print</span> <span class="variable">$var</span></span></span><br><span class="line">结果为：&#x27;$var&#x27; will print 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双引号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出引号中的内容，若存在命令、变量等，会先执行命令解析出结果再输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span> will <span class="built_in">print</span> <span class="variable">$var</span></span></span><br><span class="line">结果为：123 will print 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反引号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令替换</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var=`<span class="built_in">whoami</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line">结果为：root</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备注：反引号和$()作用相同</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-获得字符串的长度"><a href="#1-6-获得字符串的长度" class="headerlink" title="1.6 获得字符串的长度"></a>1.6 获得字符串的长度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用法</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">length=<span class="variable">$&#123;#var&#125;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var=12345678901234567890</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span></span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="1-7-识别当前shell"><a href="#1-7-识别当前shell" class="headerlink" title="1.7 识别当前shell"></a>1.7 识别当前shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">也可以使用：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$0</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-使用shell进行数学运算"><a href="#1-8-使用shell进行数学运算" class="headerlink" title="1.8 使用shell进行数学运算"></a>1.8 使用shell进行数学运算</h3><p>在Bash shell环境中，可以利用 <code>let</code>、<code> (( ))</code> 和<code>[]</code> 执行基本的算术操作。而在进行高级操作时，<code>expr</code> 和 <code>bc</code> 这两个工具也会非常有用。</p>
<p>使用 <code>let</code> 时，变量名之前不需要再添加 <code>$</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">no1=4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">let</span> no1++</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">let</span> no1+=6	<span class="comment"># 等同于let no=no+6</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">操作符[]的使用方法和<span class="built_in">let</span>命令类似</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">result=$[ no1 + no2 ]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在[]中也可以使用$前缀</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">result=$[ <span class="variable">$no1</span> + 5 ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用(())时，变量名之前需要加上$</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">result=$(( no1 + <span class="number">50</span> ))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">expr</span>同样可以用于基本算术操作</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">result=`<span class="built_in">expr</span> 3 + 4`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">result=$(<span class="built_in">expr</span> <span class="variable">$no1</span> + 5)</span></span><br></pre></td></tr></table></figure>

<p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项 。此处不多介绍。</p>
<h3 id="1-9-shell中各种括号的作用-、-、-、-、"><a href="#1-9-shell中各种括号的作用-、-、-、-、" class="headerlink" title="1.9 shell中各种括号的作用()、(())、[]、[[]]、{}"></a>1.9 shell中各种括号的作用()、(())、[]、[[]]、{}</h3><h4 id="1-9-1-小括号，圆括号（）"><a href="#1-9-1-小括号，圆括号（）" class="headerlink" title="1.9.1 小括号，圆括号（）"></a>1.9.1 小括号，圆括号（）</h4><p>1、单小括号 ( )</p>
<ul>
<li><strong>命令组。</strong>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。</li>
<li><strong>命令替换。</strong>等同于<code>cmd</code>，shell扫描一遍命令行，发现了<code>$(cmd)结构</code> ，便将 <code>$(cmd)</code> 中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li>
<li><strong>用于初始化数组。</strong>如：array&#x3D;(a b c d)。</li>
</ul>
<p>2、双小括号 (( ))</p>
<ul>
<li><strong>整数扩展。</strong>这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li>
<li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在 <code>$((exp))</code>中，甚至是三目运算符</strong>。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)。</li>
<li><strong>单纯用 (( )) 也可重定义变量值</strong>，比如 a&#x3D;5; ((a++)) 可将 $a 重定义为6。</li>
<li><strong>常用于算术运算比较，双括号中的变量可以不使用<code>$</code> 符号前缀</strong>。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i&#x3D;0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用 <code>if (($i&lt;5))</code> , 如果不使用双括号, 则为 <code>if [ $i -lt 5 ]</code> 。</li>
</ul>
<h4 id="1-9-2-中括号，方括号"><a href="#1-9-2-中括号，方括号" class="headerlink" title="1.9.2 中括号，方括号[]"></a>1.9.2 中括号，方括号[]</h4><p>1、单中括号 []</p>
<ul>
<li>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if&#x2F;test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if&#x2F;test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</li>
<li>Test和[]中可用的比较运算符只有&#x3D;&#x3D;和!&#x3D;，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li>
<li>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li>
<li>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</li>
</ul>
<p>2、双中括号 [[ ]]</p>
<ul>
<li>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li>
<li>支持字符串的模式匹配，使用&#x3D;~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello &#x3D;&#x3D; hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li>
<li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code> , 如果不适用双括号, 则为 <code>if [ $a -ne 1] &amp;&amp; [ $a != 2 ] </code>或者 <code>if [ $a -ne 1 -a $a != 2 ]</code> 。</li>
<li>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</li>
</ul>
<h4 id="1-9-3-大括号、花括号"><a href="#1-9-3-大括号、花括号" class="headerlink" title="1.9.3 大括号、花括号 {}"></a>1.9.3 大括号、花括号 {}</h4><p>1）常规用法</p>
<ul>
<li>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</li>
<li>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li>
</ul>
<p>2）几种特殊的替换结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var:-string&#125;,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>$&#123;var:-string&#125;</code> 和 <code>$&#123;var:=string&#125;:</code> 若变量var为空，则用在命令行中用string来替换 <code>$&#123;var:-string&#125;</code>，否则变量var不为空时，则用变量var的值来替换 <code>$&#123;var:-string&#125;</code> ；对于 <code>$&#123;var:=string&#125;</code> 的替换规则和 <code>$&#123;var:-string&#125;</code> 是一样的，所不同之处是 <code>$&#123;var:=string&#125;</code> 若var为空时，用string替换 <code>$&#123;var:=string&#125;</code> 的同时，把string赋给变量 <code>var： $&#123;var:=string&#125;</code> 很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li>
<li><code>$&#123;var:+string&#125;</code> 的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 。</li>
<li><code>$&#123;var:?string&#125;</code> 替换规则为：若变量var不为空，则用变量var的值来替换 <code>$&#123;var:?string&#125;</code> ；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</li>
</ul>
<p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p>
<p>3）四种模式匹配替换结构</p>
<p>模式匹配记忆方法：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是去掉左边(在键盘上#在$之左边)</span><br><span class="line">% 是去掉右边(在键盘上%在$之右边)</span><br><span class="line">#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var%pattern&#125;,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种模式：<code>$&#123;variable%pattern&#125;</code> ，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</p>
</li>
<li><p>第二种模式：<code>$&#123;variable%%pattern&#125;</code>，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p>
</li>
<li><p>第三种模式：<code>$&#123;variable#pattern&#125;</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</p>
</li>
<li><p>第四种模式：<code>$&#123;variable##pattern&#125;</code> 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p>
</li>
</ul>
<p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p>
<p>4）字符串提取和替换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var:num&#125;,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一种模式：<code>$&#123;var:num&#125;</code> ，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如 <code>$&#123;var: -2&#125;</code> 、<code>$&#123;var:1-3&#125;</code> 或 <code>$&#123;var:(-2)&#125;</code>。         </li>
<li>第二种模式：<code>$&#123;var:num1:num2&#125;</code>，num1是位置，num2是长度。表示从 <code>$var字符串的第$num1</code> 个位置开始提取长度为$num2的子串。不能为负数。</li>
<li>第三种模式：<code>$&#123;var/pattern/pattern&#125;</code>表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         </li>
<li>第四种模式：<code>$&#123;var//pattern/pattern&#125;</code> 表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</li>
</ul>
<h4 id="1-9-4-符号-后的括号"><a href="#1-9-4-符号-后的括号" class="headerlink" title="1.9.4 符号$后的括号"></a>1.9.4 符号$后的括号</h4><ul>
<li><code>$&#123;a&#125;</code> 变量a的值, 在不引起歧义的情况下可以省略大括号。</li>
<li><code>$(cmd)</code>  命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持 <code>$()</code> 形式的命令替换, 如tcsh。</li>
<li><code>$((expression))</code> 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/c">C语言</a>的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li>
</ul>
<h4 id="1-9-5-多条命令执行"><a href="#1-9-5-多条命令执行" class="headerlink" title="1.9.5 多条命令执行"></a>1.9.5 多条命令执行</h4><ul>
<li>单小括号，<code>(cmd1;cmd2;cmd3)</code>  新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。</li>
<li>单大括号，<code>&#123; cmd1;cmd2;cmd3;&#125;</code>  在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。</li>
</ul>
<p>对 <code>&#123;&#125;</code> 和 <code>()</code> 而言, 括号中的重定向符只影响该条命令，而括号外的重定向符影响到括号中的所有命令。</p>
<h3 id="1-10-Shell特殊变量-0-和命令行参数"><a href="#1-10-Shell特殊变量-0-和命令行参数" class="headerlink" title="1.10 Shell特殊变量 &#96;$0, $#, $*, $@, $?, ### 和命令行参数"></a>1.10 Shell特殊变量 &#96;$0, $#, $*, $@, $?, ### 和命令行参数</h3><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名。</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n是一个数字，表示几个参数。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有采纳数。被双引号(“ “)包含是，与$* 稍有不同。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前shell进程ID。对于shell脚本，就是这个脚本所在的进程ID。</td>
</tr>
</tbody></table>
<h4 id="1-10-1-命令行参数"><a href="#1-10-1-命令行参数" class="headerlink" title="1.10.1 命令行参数"></a>1.10.1 命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 <code>$n</code> 表示，例如，<code>$1 </code> 表示第一个参数，<code>$2</code> 表示第二个参数，依次类推。</p>
<h4 id="1-10-2-和-的区别"><a href="#1-10-2-和-的区别" class="headerlink" title="1.10.2 $* 和 $@ 的区别"></a>1.10.2 <code>$*</code> 和 <code>$@</code> 的区别</h4><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; </code>的形式输出所有参数。</p>
<h4 id="1-10-3-退出状态"><a href="#1-10-3-退出状态" class="headerlink" title="1.10.3 退出状态"></a>1.10.3 退出状态</h4><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p>
<p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p>
<p>不过，也有一些命令返回其他值，表示不同类型的错误。</p>
<p><code>$?</code> 也可以表示函数的返回值，此处不展开。</p>
<h3 id="1-11-Shell重定向"><a href="#1-11-Shell重定向" class="headerlink" title="1.11 Shell重定向"></a>1.11 Shell重定向</h3><p>1、重定向符号</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;               输出重定向到一个文件或设备 覆盖原来的文件</span><br><span class="line">&gt;!              输出重定向到一个文件或设备 强制覆盖原来的文件</span><br><span class="line">&gt;&gt;              输出重定向到一个文件或设备 追加原来的文件</span><br><span class="line">&lt;               输入重定向到一个程序 </span><br></pre></td></tr></table></figure>

<p>2、标准输入刷出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：</span><br><span class="line">1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;</span><br><span class="line">2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;</span><br><span class="line">3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;</span><br></pre></td></tr></table></figure>

<p>3、使用实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1&gt;&amp;2 意思是把标准输出重定向到标准错误.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd &lt;&gt; file		<span class="comment"># 以读写方式打开文件 file</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd &gt;&amp;n			<span class="comment"># 将 cmd 的输出发送到文件描述符 n</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd m&gt;&amp;n			<span class="comment"># 将本该输出到文件描述符 m 的内容, 发送到文件描述符 n</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd m&lt;&amp;n 			<span class="comment"># 除了本该从文件描述符 m 处获取输入，改为从文件描述符 n 处获取</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd &gt;&amp;-			<span class="comment"># 关闭标准输出</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd &lt;&amp;-			<span class="comment"># 关闭标准输入</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd  &gt;&amp; file		<span class="comment"># 将标准输出和标准错误都发送到文件 file</span></span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmd  &amp;&gt; file		<span class="comment"># 作用同上, 更好的格式</span></span></span><br></pre></td></tr></table></figure>

<p>要在终端中打印stdout，同时将它重定向到一个文件中，那么可以这样使用tee 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用法：<span class="built_in">command</span> | <span class="built_in">tee</span> FILE1 FILE2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> a* | <span class="built_in">tee</span> out.txt | <span class="built_in">cat</span> -n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下， <span class="built_in">tee</span>命令会将文件覆盖，但它提供了一个-a选项，用于追加内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> a* | <span class="built_in">tee</span> -a out.txt | <span class="built_in">cat</span> –n</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以使用stdin作为命令参数。只需要将-作为命令的文件名参数即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用法：$ cmd1 | cmd2 | cmd -</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="built_in">who</span> is this | <span class="built_in">tee</span> -</span></span><br></pre></td></tr></table></figure>

<h3 id="1-12-Shell数组和关联数组"><a href="#1-12-Shell数组和关联数组" class="headerlink" title="1.12 Shell数组和关联数组"></a>1.12 Shell数组和关联数组</h3><h4 id="1-12-1-简介"><a href="#1-12-1-简介" class="headerlink" title="1.12.1 简介"></a>1.12.1 简介</h4><p>数组是Shell脚本非常重要的组成部分，它借助索引将多个独立的独立的数据存储为一个集合。普通数组只能使用整数作为数组索引，关联数组不仅可以使用整数作为索引，也可以使用字符串作为索引。通常情况下，使用字符串做索引更容易被人们理解。Bash从4.0之后开始引入关联数组。</p>
<h4 id="1-12-2-定义打印普通数组"><a href="#1-12-2-定义打印普通数组" class="headerlink" title="1.12.2 定义打印普通数组"></a>1.12.2 定义打印普通数组</h4><p>数组的方法有如下几种：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在一行上列出所有元素</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">array_var=(1 2 3 4 5 6)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以“索引-值”的形式一一列出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">array_var[0]=<span class="string">&quot;test1&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">array_var[1]=<span class="string">&quot;test2&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">array_var[2]=<span class="string">&quot;test3&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：第一种方法要使用圆括号，否则后面会报错。</p>
<p>数组元素的方法有如下几种：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span>         <span class="comment">#输出结果为 test1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">index=2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span>    <span class="comment">#输出结果为 test3</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span>         <span class="comment">#输出所有数组元素</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span>         <span class="comment">#输出所有数组元素</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span>        <span class="comment">#输出值为 3</span></span></span><br></pre></td></tr></table></figure>

<p>注意：在ubuntu 14.04中，shell脚本要以#!&#x2F;bin&#x2F;bash开头，且执行脚本的方式为 bash test.sh。</p>
<h4 id="1-12-3-定义打印关联数组"><a href="#1-12-3-定义打印关联数组" class="headerlink" title="1.12.3 定义打印关联数组"></a>1.12.3 定义打印关联数组</h4><p>定义关联数组<br>在关联数组中，可以使用任何文本作为数组索引。定义关联数组时，首先需要使用声明语句将一个变量声明为关联数组，然后才可以在数组中添加元素，过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">declare</span> -A ass_array                           <span class="comment">#声明一个关联数组</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ass_array=([<span class="string">&quot;index1&quot;</span>]=index1 [<span class="string">&quot;index2&quot;</span>]=index2)<span class="comment">#内嵌“索引-值”列表法</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ass_array[<span class="string">&quot;index3&quot;</span>]=index3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ass_array[<span class="string">&quot;index4&quot;</span>]=index4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;ass_array[&quot;index1&quot;]&#125;</span>                    <span class="comment">#输出为index1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;ass_array[&quot;index4&quot;]&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[*]&#125;</span>                          <span class="comment">#输出索引列表</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;!ass_array[@]&#125;</span>                          <span class="comment">#输出索引列表</span></span></span><br></pre></td></tr></table></figure>

<p>注意：对于普通数组，使用上面的方法依然可以列出索引列表，在声明关联数组以及添加数组元素时，都不能在前面添加美元符$。</p>
<h3 id="1-13-使用别名"><a href="#1-13-使用别名" class="headerlink" title="1.13 使用别名"></a>1.13 使用别名</h3><p>alias命令的作用只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名设置一直保持作用，可以将它放入~&#x2F;.bashrc文件中。因为每当一个新的shell进程生成时，都会执行 ~&#x2F;.bashrc中的命令。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">alias</span> install=<span class="string">&#x27;sudo apt-get install&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-14-获取、设置日期和延时"><a href="#1-14-获取、设置日期和延时" class="headerlink" title="1.14 获取、设置日期和延时"></a>1.14 获取、设置日期和延时</h3><p>时间方面 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% : 印出</span><br><span class="line">% %n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 %S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区</span><br></pre></td></tr></table></figure>

<p>日期方面 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line"></span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line"></span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br></pre></td></tr></table></figure>

<p>若是不以加号作为开头，则表示要设定时间，而时间格式为 <code>MMDDhhmm[[CC]YY][.ss]</code>，其中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MM 	为月份，</span><br><span class="line">DD 	为日，</span><br><span class="line">hh 	为小时，</span><br><span class="line">mm 	为分钟，</span><br><span class="line">CC 	为年份前两位数字，</span><br><span class="line">YY 	为年份后两位数字，</span><br><span class="line">ss 	为秒数</span><br></pre></td></tr></table></figure>

<p>参数 :</p>
<p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)</p>
<p>–help : 显示辅助讯息</p>
<p>-s datestr : 将系统时间设为 datestr 中所设定的时间</p>
<p>-u : 显示目前的格林威治时间</p>
<p>–version : 显示版本编号</p>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span>				<span class="comment"># 获取日期</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> +%s			<span class="comment"># 打印纪元时</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> <span class="string">&quot;+%d %B %Y&quot;</span>	<span class="comment"># 用格式串结合 + 作为date命令的参数，可以按照你的选择打印出对应格式的日期</span></span></span><br><span class="line">20 May 2010</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> -s <span class="string">&quot;21 June 2009 11:01:22&quot;</span> 	<span class="comment"># 设置日期和时间</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-15-脚本调试"><a href="#1-15-脚本调试" class="headerlink" title="1.15 脚本调试"></a>1.15 脚本调试</h3><h4 id="1-15-1使用选项–x，启用shell脚本的跟踪调试功能"><a href="#1-15-1使用选项–x，启用shell脚本的跟踪调试功能" class="headerlink" title="1.15.1使用选项–x，启用shell脚本的跟踪调试功能"></a>1.15.1使用选项–x，启用shell脚本的跟踪调试功能</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash -x script.sh</span></span><br></pre></td></tr></table></figure>

<h4 id="1-15-2-使用set-x和set-x对脚本进行部分调试"><a href="#1-15-2-使用set-x和set-x对脚本进行部分调试" class="headerlink" title="1.15.2 使用set -x和set +x对脚本进行部分调试"></a>1.15.2 使用set -x和set +x对脚本进行部分调试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件名: debug.sh</span></span><br><span class="line">for i in &#123;1..6&#125;</span><br><span class="line">do</span><br><span class="line">	set -x</span><br><span class="line">	echo $i</span><br><span class="line">	set +x</span><br><span class="line">done</span><br><span class="line">echo &quot;Script executed&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>set –x：在执行时显示参数和命令。 </li>
<li>set +x：禁止调试。 </li>
<li>set –v：当命令进行读取时显示输入。 </li>
<li>set +v：禁止打印输入。</li>
</ul>
<h4 id="1-15-3-通过传递-DEBUG环境变量调试"><a href="#1-15-3-通过传递-DEBUG环境变量调试" class="headerlink" title="1.15.3 通过传递 _DEBUG环境变量调试"></a>1.15.3 通过传递 _DEBUG环境变量调试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function DEBUG()</span><br><span class="line">&#123;</span><br><span class="line">	[ &quot;$_DEBUG&quot; == &quot;on&quot; ] &amp;&amp; $@ || :</span><br><span class="line">&#125;</span><br><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">	DEBUG echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>可以将调试功能置为”on”来运行上面的脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">_DEBUG=on ./script.sh</span></span><br></pre></td></tr></table></figure>

<p>我们在每一个需要打印调试信息的语句前加上DEBUG。如果没有把 _DEBUG&#x3D;on传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 <code>:</code> 告诉shell不要进行任何操作。 </p>
<h4 id="1-15-4-利用shebang来进行调试"><a href="#1-15-4-利用shebang来进行调试" class="headerlink" title="1.15.4 利用shebang来进行调试"></a>1.15.4 利用shebang来进行调试</h4><p>shebang的妙用<br>把shebang从 <code>#!/bin/bash</code> 改成 <code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p>
<h3 id="1-16-函数参数"><a href="#1-16-函数参数" class="headerlink" title="1.16 函数参数"></a>1.16 函数参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$0 		# 脚本名</span><br><span class="line">$1		# 第一个参数</span><br><span class="line">$2		# 第二个参数</span><br><span class="line">$n		# 第n个参数</span><br><span class="line"><span class="string">&quot;$@&quot;</span>	# 被扩展成 <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span> <span class="string">&quot;$3&quot;</span>等</span><br><span class="line"><span class="string">&quot;$*&quot;</span>	# 被扩展成 <span class="string">&quot;$1c$2c$3&quot;</span>，其中c是<span class="variable constant_">IFS</span>的第一个字符</span><br><span class="line"><span class="string">&quot;$@&quot;</span> 要比<span class="string">&quot;$*&quot;</span>用得多。由于 <span class="string">&quot;$*&quot;</span>将所有的参数当做单个字符串，因此它很少被使用。</span><br></pre></td></tr></table></figure>

<p><strong>导出函数：</strong></p>
<p>函数也能像环境变量一样用export导出，如此一来，函数的作用域就可以扩展到子进程中，例如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export -f fname </span><br></pre></td></tr></table></figure>

<h3 id="1-17-read命令"><a href="#1-17-read命令" class="headerlink" title="1.17 read命令"></a>1.17 read命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从输入中读取n个字符并存入变量</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> -n 2 var</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$var</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用无回显的方式读取密码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> -s var</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示提示信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> -p <span class="string">&quot;Enter input:&quot;</span> var</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在特定时(秒)限内读取输入</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> -t <span class="built_in">timeout</span> var</span></span><br></pre></td></tr></table></figure>

<h3 id="1-18-条件比较与测试"><a href="#1-18-条件比较与测试" class="headerlink" title="1.18 条件比较与测试"></a>1.18 条件比较与测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span>条件</span></span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">else</span> <span class="keyword">if</span>和<span class="keyword">else</span></span></span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">else if condition then</span><br><span class="line">	commands</span><br><span class="line">else</span><br><span class="line">	commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action		 # 如果condition为真，则执行action</span><br><span class="line">[ condition ] || action		 # 如果condition为假，则执行action</span><br></pre></td></tr></table></figure>

<p><code>&amp;&amp;</code> 是逻辑与运算符， <code>||</code> 是逻辑或运算符。编写Bash脚本时，这是一个很有用的技巧。现在来了解一下条件和比较操作。 </p>
<p>算术比较：</p>
<ul>
<li><code>-gt</code> ：大于。 </li>
<li><code>-lt</code> ：小于。 </li>
<li><code>-ge</code> ：大于或等于。 </li>
<li><code>-le</code> ：小于或等于。</li>
</ul>
<p>可以按照下面的方法结合多个条件进行测试： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ $var1 -ne 0 -a $var2 -gt 2 ] 		#使用逻辑与-a</span><br><span class="line">[ $var1 -ne 0 -o var2 -gt 2 ] 		#逻辑或 -o</span><br></pre></td></tr></table></figure>

<p>文件系统相关测试：</p>
<p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。 </p>
<ul>
<li><code>[ -f $file_var ]</code> ：如果给定的变量包含正常的文件路径或文件名，则返回真。 </li>
<li><code>[ -x $var ]</code> ：如果给定的变量包含的文件可执行，则返回真。 </li>
<li><code>[ -d $var ]</code> ：如果给定的变量包含的是目录，则返回真。 </li>
<li><code>[ -e $var ]</code> ：如果给定的变量包含的文件存在，则返回真。 </li>
<li><code>[ -c $var ]</code> ：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 </li>
<li><code>[ -b $var ]</code> ：如果给定的变量包含的是一个块设备文件的路径，则返回真。 </li>
<li><code>[ -w $var ]</code> ：如果给定的变量包含的文件可写，则返回真。 </li>
<li><code>[ -r $var ]</code> ：如果给定的变量包含的文件可读，则返回真。 </li>
<li><code>[ -L $var ]</code> ：如果给定的变量包含的是一个符号链接，则返回真。</li>
</ul>
<p>字符串比较：</p>
<p style="color: red;">使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。 </p>

<p>可以用下面的方法检查两个字符串，看看它们是否相同。 </p>
<ul>
<li><code>[[ $str1 = $str2 ]]</code>：当str1等于str2时，返回真。也就是说， str1和str2包含<br>的文本是一模一样的。 </li>
<li><code>[[ $str1 == $str2 ]]</code> ：这是检查字符串是否相等的另一种写法。</li>
</ul>
<p>也可以检查两个字符串是否不同。 </p>
<ul>
<li><code>[[ $str1 != $str2 ]]</code> ：如果str1和str2不相同，则返回真。</li>
</ul>
<p>我们还可以检查字符串的字母序情况，具体如下所示。 </p>
<ul>
<li><code>[[ $str1 &gt; $str2 ]]</code> ：如果str1的字母序比str2大，则返回真。 </li>
<li><code>[[ $str1 &lt; $str2 ]]</code> ：如果str1的字母序比str2小，则返回真。 </li>
<li><code>[[ -z $str1 ]]</code> ：如果str1包含的是空字符串，则返回真。 </li>
<li><code>[[ -n $str1 ]]</code> ：如果str1包含的是非空字符串，则返回真。</li>
</ul>
<p>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]] </span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $var -eq 0 ]; then echo &quot;True&quot;; fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以写成：</span></span><br><span class="line">if test $var -eq 0 ; then echo &quot;True&quot;; fi</span><br></pre></td></tr></table></figure>

<h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="1-利用子shell生成一个独立的进程"><a href="#1-利用子shell生成一个独立的进程" class="headerlink" title="1. 利用子shell生成一个独立的进程"></a>1. 利用子shell生成一个独立的进程</h4><p>子shell本身就是独立的进程。可以使用 <code>( )</code>操作符来定义一个子shell ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd;</span><br><span class="line">(cd /bin; ls);</span><br><span class="line">pwd;</span><br></pre></td></tr></table></figure>

<h4 id="2-无限循环的实例"><a href="#2-无限循环的实例" class="headerlink" title="2. 无限循环的实例"></a>2. 无限循环的实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; while true; do $@ &amp;&amp; return; done &#125;</span><br></pre></td></tr></table></figure>

<p>工作原理：</p>
<p>函数repeat，它包含了一个无限while循环，该循环执行以参数形式（通过 <code>$@</code> 访问）传入函数的命令。如果命令执行成功，则返回，进而退出循环。 </p>
<p><strong>一种更快的做法 ：</strong></p>
<p>在大多数现代系统中， <code>true</code> 是作为 <code>/bin</code> 中的一个二进制文件来实现的。<p style="color: red;">这就意味着每执行一次while循环， shell就不得不生成一个进程。</p>如果不想这样，可以使用shell内建的 <code>:</code>命令，它总是会返回为0的退出码： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat() &#123; while :; do $@ &amp;&amp; return; done &#125; </span><br></pre></td></tr></table></figure>

<p>尽管可读性不高，但是肯定比第一种方法快。 </p>
<h2 id="2-命令之乐"><a href="#2-命令之乐" class="headerlink" title="2. 命令之乐"></a>2. 命令之乐</h2><h3 id="2-1-cat命令"><a href="#2-1-cat命令" class="headerlink" title="2.1 cat命令"></a>2.1 cat命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">摆脱多余的空白行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> -s file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示行号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> -n file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n甚至会为空白行加上行号。如果你想跳过空白行，那么可以使用选项-b。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-find命令"><a href="#2-2-find命令" class="headerlink" title="2.2 find命令"></a>2.2 find命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前目录及子目录下所有的文件和文件夹</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find base_path</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-<span class="built_in">print</span>指明打印出匹配文件的文件名（路径）。当使用 -<span class="built_in">print</span>时， <span class="string">&#x27;\n&#x27;</span>作为用于对输出的文件名进行分隔。就算你忽略-<span class="built_in">print</span>， find命令仍会打印出文件名。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-print0指明使用<span class="string">&#x27;\0&#x27;</span>作为匹配的文件名之间的定界符。</span></span><br></pre></td></tr></table></figure>

<p>1、find命令有一个选项 <code>-iname</code>（忽略字母大小写） </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">example.txt EXAMPLE.txt file.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -iname <span class="string">&quot;example*&quot;</span> -<span class="built_in">print</span></span></span><br><span class="line">./example.txt</span><br><span class="line">./EXAMPLE.txt</span><br></pre></td></tr></table></figure>

<p>2、如果想匹配多个条件中的一个，可以采用OR条件操作 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">new.txt some.jpg text.pdf</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . \( -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span> \) -<span class="built_in">print</span></span></span><br><span class="line">./text.pdf</span><br><span class="line">./new.txt</span><br></pre></td></tr></table></figure>

<p>3、选项-path的参数可以使用通配符来匹配文件路径。 <code>-name</code> 总是用给定的文件名进行匹配。<code>-path</code> 则将文件路径作为一个整体进行匹配。例如 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /home/users -path <span class="string">&quot;*/slynux/*&quot;</span> -<span class="built_in">print</span></span></span><br><span class="line">/home/users/list/slynux.txt</span><br><span class="line">/home/users/slynux/eg.css</span><br></pre></td></tr></table></figure>

<p>4、选项 <code>-regex</code> 的参数和 <code>-path</code> 的类似，只不过 <code>-regex</code> 是基于正则表达式来匹配文件路径的。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">new.PY next.jpg test.py</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -regex <span class="string">&quot;.*\(\.py\|\.sh\)$&quot;</span></span></span><br><span class="line">./test.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">类似地， -iregex可以让正则表达式忽略大小写。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -iregex <span class="string">&quot;.*\(\.py\|\.sh\)$&quot;</span></span></span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure>

<p>5、find也可以用“!”否定参数的含义。例如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">list.txt new.PY new.txt next.jpg test.py</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . ! -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span></span><br><span class="line">.</span><br><span class="line">./next.jpg</span><br><span class="line">./test.py</span><br><span class="line">./new.PY</span><br></pre></td></tr></table></figure>

<p>6、基于目录深度的搜索</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">深度选项-maxdepth和 -mindepth来限制find命令遍历的目录深度</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下列命令将find命令向下的最大深度限制为1:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -maxdepth 1 -name <span class="string">&quot;f*&quot;</span> -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出深度距离当前目录至少两个子目录的所有文件:</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -mindepth 2 -name <span class="string">&quot;f*&quot;</span> -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>-maxdepth和-mindepth应该作为find的第三个参数出现。如果作为第4个或之后的参数，就可能会影响到find的效率，因为它不得不进行一些不必要的检查。 </p>
<p>根据文件类型搜索</p>
<p>7、根据文件类型搜索</p>
<p><code>-type</code> 可以对文件搜索进行过滤 </p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>类型参数</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td>f</td>
</tr>
<tr>
<td>符号链接</td>
<td>l</td>
</tr>
<tr>
<td>目录</td>
<td>d</td>
</tr>
<tr>
<td>字符设备</td>
<td>c</td>
</tr>
<tr>
<td>块设备</td>
<td>b</td>
</tr>
<tr>
<td>套接字</td>
<td>s</td>
</tr>
<tr>
<td>FIFO</td>
<td>p</td>
</tr>
</tbody></table>
<p>8、根据文件时间进行搜索</p>
<ul>
<li>访问时间（-atime）：用户最近一次访问文件的时间。</li>
<li>修改时间（-mtime）：文件内容最后一次被修改的时间。</li>
<li>变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。</li>
</ul>
<blockquote>
<p>-atime、 -mtime、 -ctime可作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有 - 或 + ： - 表示小于， + 表示大于。 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出在最近7天内被访问过的所有文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -atime -7 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出恰好在7天前被访问过的所有文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -atime 7 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出访问时间超过7天的所有文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -atime +7 -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>

<p>-atime、 -mtime以及-ctime都是基于时间的参数，其计量单位是“天”。还有其他一些基于时间的参数是以分钟作为计量单位的。这些参数包括： </p>
<ul>
<li>-amin（访问时间）</li>
<li>-mmin（修改时间）</li>
<li>-cmin（变化时间）</li>
</ul>
<p>使用 <code>-newer</code> ，我们可以指定一个用于比较时间戳的参考文件，然后找出比参考文件更新的（更近的修改时间）所有文件 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出比file.txt修改时间更近的所有文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -newer file.txt -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>

<p>9、基于文件大小的搜索</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -size +2k</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大于2KB的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -size -2k</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">小于2KB的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -size 2k</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大小等于2KB的文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>b —— 块（512字节）</li>
<li>c —— 字节</li>
<li>w —— 字（2字节）</li>
<li>k —— 1024字节</li>
<li>M —— 1024k字节</li>
<li>G —— 1024M字节</li>
</ul>
<p>10、删除匹配的文件</p>
<p><code>-delete</code> 可以用来删除find查找到的匹配文件。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前目录下所有的 .swp文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> -delete</span></span><br></pre></td></tr></table></figure>

<p>11、基于文件权限和所有权的匹配</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出权限为644的文件</span></span><br></pre></td></tr></table></figure>

<p>-perm指明find应该只匹配具有特定权限值的文件。 </p>
<p>12、利用find执行命令或动作 </p>
<p>find命令可以借助选项-exec与其他命名进行结合。 -exec算得上是find最强大的特性之一。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> <span class="built_in">chown</span> slynux &#123;&#125; \;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123;&#125;是一个与 -<span class="built_in">exec</span>选项搭配使用的特殊字符串。对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名。</span></span><br></pre></td></tr></table></figure>

<p><code>-exec</code> 结合多个命令 :</p>
<p>我们无法在-exec参数中直接使用多个命令。它只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个shell脚本中（例如command.sh），然后在-exec中使用这个脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \; </span><br></pre></td></tr></table></figure>

<p>13、让find跳过特定的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find devel/source_path \( -name <span class="string">&quot;.git&quot;</span> -prune \) -o \( -<span class="built_in">type</span> f -<span class="built_in">print</span> \)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上命令打印出不包括在.git目录中的所有文件的名称（路径）。</span></span><br></pre></td></tr></table></figure>

<p><code>\( -name &quot;.git&quot; -prune \)</code> 的作用是用于进行排除，它指明了 .git目录应该被排除在外，而<code> \( -type f -print \)</code> 指明了需要执行的动作。这些动作需要被放置在第二个语句块中（打印出所有文件的名称和路径）。 </p>
<h3 id="2-3-玩转xargs"><a href="#2-3-玩转xargs" class="headerlink" title="2.3 玩转xargs"></a>2.3 玩转xargs</h3><p><code>xargs</code> 擅长将标准输入数据转换成命令行参数。</p>
<p><code>xargs</code> 命令把从 stdin接收到的数据重新格式化，再将其作为参数提供给其他命令。 </p>
<h4 id="2-3-1-将多行输入转换成单行输出"><a href="#2-3-1-将多行输入转换成单行输出" class="headerlink" title="2.3.1 将多行输入转换成单行输出"></a>2.3.1 将多行输入转换成单行输出</h4><p>只需要将换行符移除，再用” “（空格）进行代替，就可以实现多行输入的转换。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example.txt <span class="comment"># 样例文件</span></span></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">7 8 9 10</span><br><span class="line">11 12</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example.txt | xargs</span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-将单行输入转换成多行输出"><a href="#2-3-2-将单行输入转换成多行输出" class="headerlink" title="2.3.2 将单行输入转换成多行输出"></a>2.3.2 将单行输入转换成多行输出</h4><p>指定每行最大的参数数量 <code>n</code>，我们可以将任何来自stdin的文本划分成多行，每行 <code>n</code> 个参数。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example.txt | xargs -n 3</span></span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10 11 12</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-定制定界符"><a href="#2-3-3-定制定界符" class="headerlink" title="2.3.3 定制定界符"></a>2.3.3 定制定界符</h4><p>用 <code>-d</code> 选项为输入指定一个定制的定界符： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;splitXsplitXsplitXsplit&quot;</span> | xargs -d X</span></span><br><span class="line">split split split split</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;splitXsplitXsplitXsplit&quot;</span> | xargs -d X -n 2</span></span><br><span class="line">split split</span><br><span class="line">split split</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确指定X作为输入定界符，而在默认情况下， xargs采用内部字段分隔符（空格）作为输入定界符。 </p>
<h4 id="2-3-4-读取stdin，将格式化参数传递给命令"><a href="#2-3-4-读取stdin，将格式化参数传递给命令" class="headerlink" title="2.3.4 读取stdin，将格式化参数传递给命令"></a>2.3.4 读取stdin，将格式化参数传递给命令</h4><p><code>-I</code> 指定替换字符串，这个字符串在xargs扩展时会被替换掉。如果将 <code>-I</code> 与 <code>xargs</code> 结合使用，对于每一个参数，命令都会被执行一次。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> args.txt</span></span><br><span class="line">arg1</span><br><span class="line">arg2</span><br><span class="line">arg3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span></span><br><span class="line">-p arg1 -l #</span><br><span class="line">-p arg2 -l #</span><br><span class="line">-p arg3 -l #</span><br></pre></td></tr></table></figure>

<p><code>-I &#123;&#125;</code> 指定了替换字符串。对于每一个命令参数，字符串 <code>&#123;&#125;</code> 都会被从stdin读取到的参数替换掉。 </p>
<p>使用 <code>-I</code> 的时候，命令以循环的方式执行。 </p>
<p>xargs和find算是一对死党。两者结合使用可以让任务变得更轻松。 不过人们通常却是以一种错误的组合方式使用它们。例如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span> | xargs <span class="built_in">rm</span> -f</span></span><br></pre></td></tr></table></figure>

<p>这样做很危险。 有时可能会删除不必要删除的文件。 </p>
<p>只要我们把 <code>find</code> 的输出作为 <code>xargs</code> 的输入，就必须将 <code>-print0</code> 与 <code>find</code> 结合使用，以字符<code>null（&#39;\0&#39;）</code>来分隔输出。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -print0 | xargs -0 <span class="built_in">rm</span> -f</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xargs -0将\0作为输入定界符。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find source_code_dir_path -<span class="built_in">type</span> f -name <span class="string">&quot;*.c&quot;</span> -print0 | xargs -0 <span class="built_in">wc</span> -l</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计源代码目录中所有C程序文件的行数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-校验和与核实"><a href="#2-4-校验和与核实" class="headerlink" title="2.4 校验和与核实"></a>2.4 校验和与核实</h3><p>校验和（checksum）程序用来从文件中生成校验和密钥，然后利用这个校验和密钥核实文件的完整性。文件可以通过网络或任何存储介质分发到不同的地点。 </p>
<p>最知名且使用最为广泛的校验和技术是md5sum和SHA-1。它们对文件内容使用相应的算法来生成校验和。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> filename</span></span><br><span class="line">68b329da9893e34099c7d8ad5cb9c940 filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> filename &gt; file_sum.md5</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> file1 file2 file3 ..</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> -c file_sum.md5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令会输出校验和是否匹配的消息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要用所有的.md5信息来检查所有的文件，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> -c *.md5</span></span><br></pre></td></tr></table></figure>

<p>计算SAH-1串的命令是sha1sum。其用法和md5sum的非常相似。只需要把先前讲过的那些命令中的md5sum替换成sha1sum就行了，记住将输入文件名从file_sum.md5改为file_sum.sha1。 </p>
<p>对目录进行校验：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">md5deep -rl directory_path &gt; directory.md5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r使用递归的方式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l使用相对路径。默认情况下， md5deep会输出文件的绝对路径</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者也可以结合find来递归计算校验和：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find directory_path -<span class="built_in">type</span> f -print0 | xargs -0 <span class="built_in">md5sum</span> &gt;&gt; directory.md5</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的命令进行核实：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> -c directory.md5</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-加密工具与散列"><a href="#2-4-1-加密工具与散列" class="headerlink" title="2.4.1 加密工具与散列"></a>2.4.1 加密工具与散列</h4><p><code>crypt</code>、 <code>gpg</code>、 <code>base64</code>、 <code>md5sum</code>、 <code>sha1sum</code> 以及 <code>openssl</code> 的用法。 </p>
<p>1）crypt是一个简单的加密工具，它从stdin接受一个文件以及口令作为输入，然后将加密数据输出到Stdout（因此要对输入、输出文件使用重定向）。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crypt &lt;input_file &gt;output_file</span></span><br><span class="line">Enter passphrase:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它会要求输入一个口令。我们也可以通过命令行参数来提供口令。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crypt PASSPHRASE &lt;input_file &gt;encrypted_file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要解密文件，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crypt PASSPHRASE -d &lt;encrypted_file &gt;output_file</span></span><br></pre></td></tr></table></figure>

<p>2）gpg（GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。这里我们讨论如何加密、解密文件。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用gpg加密文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg -c filename</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令采用交互方式读取口令，并生成filename.gpg。使用以下命令解密gpg文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg filename.gpg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令读取口令，然后对文件进行解密。</span></span><br></pre></td></tr></table></figure>

<p>3）Base64是一组相似的编码方案，它将ASCII字符转换成以64为基数的形式，以可读的ASCII字符串来描述二进制数据。 base64命令可以用来编码&#x2F;解码Base64字符串。要将文件编码为Base64格式，可以使用： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">base64</span> filename &gt; outputfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file | <span class="built_in">base64</span> &gt; outputfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">base64</span>可以从stdin中进行读取。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解码Base64数据：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">base64</span> -d file &gt; outputfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> base64_file | <span class="built_in">base64</span> -d &gt; outputfile</span></span><br></pre></td></tr></table></figure>

<p>4）md5sum与sha1sum都是单向散列算法，均无法逆推出原始数据。它们通常用于验证数据完整性或为特定数据生成唯一的密钥： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> file</span></span><br><span class="line">8503063d5488c3080d4800ff50850dc9 file</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sha1sum</span> file</span></span><br><span class="line">1ba02b66e2e557fede8f61b7df282cd0a27b816b file</span><br></pre></td></tr></table></figure>

<p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要进行认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。如果相同，用户就通过认证，被允许访问；否则，就会被拒绝访问。 </p>
<p>5）openssl</p>
<p>用openssl生成shadow密码。 shadow密码通常都是salt密码。所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不易被破解。 salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salt散列值。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">opensslpasswd -1 -salt SALT_STRING PASSWORD</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1$SALT_STRING<span class="variable">$323VkWkSLHuhbt1zkSsUG</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将SALT_STRING替换为随机字符串，并将PASSWORD替换成你想要使用的密码。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-排序、唯一与重复"><a href="#2-5-排序、唯一与重复" class="headerlink" title="2.5 排序、唯一与重复"></a>2.5 排序、唯一与重复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对一组文件进行排序：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> file1.txt file2.txt &gt; sorted.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照数字顺序进行排序：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n file.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照逆序进行排序：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -r file.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照月份进行排序（依照一月，二月，三月……）：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -M months.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并两个已排序过的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -m sorted1 sorted2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出已排序文件中不重复的行：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> file1.txt file2.txt | <span class="built_in">uniq</span></span></span><br></pre></td></tr></table></figure>

<p>检查文件是否已经排序过：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">功能描述：排序</span></span><br><span class="line">sort -C filename ;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">	echo Sorted;</span><br><span class="line">else</span><br><span class="line">	echo Unsorted;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>-k</code> 指定了排序应该按照哪一个键（key）来进行。键指的是列号，而列号就是执行排序时的依据。 <code>-r</code> 告诉sort命令按照逆序进行排序。例如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依据第1列，以逆序形式排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -nrk 1 data.txt</span></span><br><span class="line">4 linux 1000</span><br><span class="line">3 bsd 1000</span><br><span class="line">2 winxp 4000</span><br><span class="line">1 mac 2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-nr表明按照数字，采用逆序形式排序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依据第2列进行排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k 2 data.txt</span></span><br><span class="line">3 bsd 1000</span><br><span class="line">4 linux 1000</span><br><span class="line">1 mac 2000</span><br><span class="line">2 winxp 4000</span><br></pre></td></tr></table></figure>

<p>有时文本中可能会包含一些像空格之类的不必要的多余字符。如果需要忽略这些字符，并以字典序进行排序，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -bd unsorted.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项-b用于忽略文件中的前导空白行，选项-d用于指明以字典序进行排序。</span></span><br></pre></td></tr></table></figure>

<p>sort选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line"></span><br><span class="line">-c：检查文件是否已经按照顺序排序； </span><br><span class="line"></span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； </span><br><span class="line"></span><br><span class="line">-f：排序时，将小写字母视为大写字母； </span><br><span class="line"></span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line"></span><br><span class="line">-m：将几个排序号的文件进行合并； </span><br><span class="line"></span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序； </span><br><span class="line"></span><br><span class="line">-n：依照数值的大小排序； </span><br><span class="line"></span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件； </span><br><span class="line"></span><br><span class="line">-r：以相反的顺序来排序； </span><br><span class="line"></span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； </span><br><span class="line"></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure>

<p>uniq选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数； </span><br><span class="line"></span><br><span class="line">-d或--repeated：仅显示重复出现的行列； </span><br><span class="line"></span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位； </span><br><span class="line"></span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符； </span><br><span class="line"></span><br><span class="line">-u或——unique：仅显示出一次的行列； </span><br><span class="line"></span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure>

<p>wc选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-c或--bytes或——chars：只显示Bytes数； 		# 统计字符数</span><br><span class="line"></span><br><span class="line">-l或——lines：只显示列数； 					# 统计行数</span><br><span class="line"></span><br><span class="line">-w或——words：只显示字数。					# 统计单词数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当不使用任何选项执行<span class="built_in">wc</span>时，它会分别打印出文件的行数、单词数和字符数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> file</span></span><br><span class="line">1435 15763 112200</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-L选项打印出文件中最长一行的长度：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> file -L</span></span><br><span class="line">205</span><br></pre></td></tr></table></figure>

<h3 id="2-6-临时文件命名与随机数"><a href="#2-6-临时文件命名与随机数" class="headerlink" title="2.6 临时文件命名与随机数"></a>2.6 临时文件命名与随机数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建临时文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">filename=`<span class="built_in">mktemp</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$filename</span></span></span><br><span class="line">/tmp/tmp.8xvhkjF5fH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建临时目录：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dirname</span>=`<span class="built_in">mktemp</span> -d`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$dirname</span></span></span><br><span class="line">tmp.NI8xzW7VRX</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果仅仅是想生成文件名，又不希望创建实际的文件或目录，方法如下：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmpfile=`<span class="built_in">mktemp</span> -u`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$tmpfile</span></span></span><br><span class="line">/tmp/tmp.RsGmilRpcT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据模板创建临时文件名：</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">mktemp</span> test.XXX</span></span><br><span class="line">test.2tc</span><br></pre></td></tr></table></figure>

<p>如果提供了定制模板， X会被随机的字符（字母或数字）替换。注意， mktemp正常工作的前提是保证模板中只少要有3个X。 </p>
<h3 id="2-7-split-分割文件和数据"><a href="#2-7-split-分割文件和数据" class="headerlink" title="2.7 split 分割文件和数据"></a>2.7 split 分割文件和数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件分割成多个大小为10KB的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">split</span> -b 10k data.file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">data.file xaa xab xac xad xae xaf xag xah xai xaj</span><br></pre></td></tr></table></figure>

<p>上面的命令将data.file分割成多个文件，每一个文件大小为10KB。这些文件以xab、 xac、 xad的形式命名。这表明它们都有一个字母后缀。如果想以数字为后缀，可以另外使用-d参数。此外，使用 -a length可以指定后缀长度： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">split</span> -b 10k data.file -d -a 4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">data.file x0009 x0019 x0029 x0039 x0049 x0059 x0069 x0079</span><br></pre></td></tr></table></figure>

<p>除了k（KB）后缀，我们还可以使用M（MB）、 G（GB）、 c（byte）、 w（word）等后缀。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为分割后的文件指定文件名前缀</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">split</span> -b 10k data.file -d -a 4 split_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">data.file	   split_file0002 split_file0005 split_file0008 strtok.c</span><br><span class="line">split_file0000 split_file0003 split_file0006 split_file0009</span><br><span class="line">split_file0001 split_file0004 split_file0007</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不想按照数据块大小，而是需要根据行数来分割文件的话，可以使用 -l no_of_lines：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">split</span> -l 10 data.file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分割成多个文件，每个文件包含10行</span></span><br></pre></td></tr></table></figure>

<p>csplit。它能够依据指定的条件和字符串匹配选项对日志文件进行分割。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> server.log</span></span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.168.0.1 success</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 success</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.168.0.1 failed</span><br><span class="line">[connection] 192.168.0.2 failed</span><br><span class="line">[disconnect] 192.168.0.3 success</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.168.0.1 pending</span><br><span class="line">[connection] 192.168.0.2 pending</span><br><span class="line">[disconnect] 192.168.0.3 pending</span><br><span class="line">[connection] 192.168.0.4 failed</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">csplit</span> server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b <span class="string">&quot;%02d.log&quot;</span> ; <span class="built_in">rm</span> server00.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure>

<p>有关这个命令的详细说明如下。 </p>
<ul>
<li>&#x2F;SERVER&#x2F; 用来匹配某一行，分割过程即从此处开始。 </li>
<li>&#x2F;[REGEX]&#x2F; 表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行。 </li>
<li>{*} 表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。 </li>
<li>-s 使命令进入静默模式，不打印其他信息。 </li>
<li>-n 指定分割后的文件名后缀的数字个数，例如01、 02、 03等。 </li>
<li>-f 指定分割后的文件名前缀（在上面的例子中， server就是前缀）。 </li>
<li>-b 指定后缀格式。例如%02d.log，类似于C语言中printf的参数格式。在这里文件名&#x3D;前缀+后缀&#x3D;server + %02d.log。</li>
</ul>
<p>因为分割后的第一个文件没有任何内容（匹配的单词就位于文件的第一行中），所以我们删除了server00.log。 </p>
<h4 id="2-7-1-根据扩展名切分文件名-、"><a href="#2-7-1-根据扩展名切分文件名-、" class="headerlink" title="2.7.1 根据扩展名切分文件名$、##"></a>2.7.1 根据扩展名切分文件名$、##</h4><p>借助 <code>%</code> 操作符可以轻松将名称部分从 “名称.扩展名” 这种格式中提取出来。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_jpg=&quot;sample.jpg&quot;</span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is: $name</span><br><span class="line">输出结果：</span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure>

<p>将文件名的扩展名部分提取出来，这可以借助 # 操作符实现。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is: jpg</span><br><span class="line">输出结果：</span><br><span class="line">Extension is: jpg</span><br></pre></td></tr></table></figure>

<p><code>$&#123;VAR%.*&#125;</code>  的含义如下所述： </p>
<ul>
<li>从 $VAR中删除位于 % 右侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。 </li>
<li>给VAR赋值， VAR&#x3D;sample.jpg。那么，通配符从右向左就会匹配到.jpg，因此，从 $VAR中删除匹配结果，就会得到输出sample。</li>
</ul>
<p>%属于非贪婪（non-greedy）操作。它从右到左找出匹配通配符的最短结果。还有另一个操作符 %%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。 </p>
<p>操作符%%则用.*从右向左执行贪婪匹配（.fun.book.txt）。 </p>
<p><code>$&#123;VAR#*.&#125;</code> 的含义如下所述：<br>从$VAR中删除位于#右侧的通配符（即在前例中使用的*.）所匹配的字符串。通配<br>符从左向右进行匹配。<br>和 %% 类似， #也有一个相对应的贪婪操作符 ##。</p>
<p><code>##</code>从左向右进行贪婪匹配，并从指定变量中删除匹配结果。</p>
<p>这里有个能够提取域名不同部分的实用案例。假定 <code>URL=&quot;www.google.com&quot;</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span> <span class="comment"># 移除.*所匹配的最右边的内容</span></span></span><br><span class="line">www.google</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span> <span class="comment"># 将从右边开始一直匹配到最左边的*.移除（贪婪操作符）</span></span></span><br><span class="line">www</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span> <span class="comment"># 移除*.所匹配的最左边的内容</span></span></span><br><span class="line">google.com</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span> <span class="comment"># 将从左边开始一直匹配到最右边的*.移除（贪婪操作符）</span></span></span><br><span class="line">com</span><br></pre></td></tr></table></figure>

<h3 id="2-8-批量重命名和移动"><a href="#2-8-批量重命名和移动" class="headerlink" title="2.8 批量重命名和移动"></a>2.8 批量重命名和移动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 *.JPG更名为 *.jpg：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rename *.JPG *.jpg</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件名中的空格替换成字符“_”：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rename <span class="string">&#x27;s/ /_/g&#x27;</span> *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转换文件名的大小写：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rename <span class="string">&#x27;y/A-Z/a-z/&#x27;</span> *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将所有的 .mp3文件移入给定的目录：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find path -<span class="built_in">type</span> f -name <span class="string">&quot;*.mp3&quot;</span> -<span class="built_in">exec</span> <span class="built_in">mv</span> &#123;&#125; target_dir \;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将所有文件名中的空格替换为字符“_”：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">&#x27;s/ /_/g&#x27;</span> &#123;&#125; \;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-以文件之名"><a href="#3-以文件之名" class="headerlink" title="3 以文件之名"></a>3 以文件之名</h2><h3 id="3-1-生成任意大小的文件"><a href="#3-1-生成任意大小的文件" class="headerlink" title="3.1 生成任意大小的文件"></a>3.1 生成任意大小的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span></span><br></pre></td></tr></table></figure>

<p>该命令会创建一个1MB大小的文件junk.data。来看一下命令参数： if代表输入文件（input file），of代表输出文件（output file）， bs代表以字节为单位的块大小（block size）， count代表需要被复制的块数。</p>
<p>使用dd命令时一定得留意，该命令运行在设备底层。要是你不小心出了岔子，搞不好会把磁盘清空或是损坏数据。所以一定要反复检查dd命令所用的语法是否正确，尤其是参数of&#x3D;。 </p>
<table>
<thead>
<tr>
<th>单元大小</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>字节（1B）</td>
<td>c</td>
</tr>
<tr>
<td>字（2B）</td>
<td>w</td>
</tr>
<tr>
<td>块（512B）</td>
<td>b</td>
</tr>
<tr>
<td>千字节（1024B）</td>
<td>k</td>
</tr>
<tr>
<td>兆字节（1024KB）</td>
<td>M</td>
</tr>
<tr>
<td>吉字节（1024MB）</td>
<td>G</td>
</tr>
</tbody></table>
<p><code>ls -lS</code> 对当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息。  </p>
<h3 id="3-2-文件权限、所有权和粘滞位"><a href="#3-2-文件权限、所有权和粘滞位" class="headerlink" title="3.2 文件权限、所有权和粘滞位"></a>3.2 文件权限、所有权和粘滞位</h3><p>用命令ls -l可以列出文件的权限： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 slynux slynux 2497 2010-02-28 11:22 bot.py</span><br><span class="line">drwxr-xr-x 2 slynux slynux 4096 2010-05-27 14:31 a.py</span><br><span class="line">-rw-r--r-- 1 slynux slynux 539 2010-02-10 09:11 cl.pl</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-</code>—— 普通文件。 </li>
<li>d —— 目录。 </li>
<li>c —— 字符设备。 </li>
<li>b —— 块设备。 </li>
<li>l —— 符号链接。 </li>
<li>s —— 套接字。 </li>
<li>p —— 管道。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改所有权</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> user.group filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置粘滞位</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要设置粘滞位，利用<span class="built_in">chmod</span>将 +t应用于目录：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+t directory_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以递归的方式设置权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 777 . -R</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以递归的方式设置所有权</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> user.group . -R</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-创建不可修改的文件"><a href="#3-3-创建不可修改的文件" class="headerlink" title="3.3 创建不可修改的文件"></a>3.3 创建不可修改的文件</h3><p>chattr能够将文件设置为不可修改。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用下列命令将一个文件设置为不可修改：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chattr +i file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要使文件恢复可写状态，移除不可修改属性即可：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chattr -i file</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-查找符号链接及其指向目标"><a href="#3-4-查找符号链接及其指向目标" class="headerlink" title="3.4 查找符号链接及其指向目标"></a>3.4 查找符号链接及其指向目标</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建符号链接：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s target symbolic_link_name</span></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -l -s /var/www/ ~/web</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个命令在已登录用户的home目录中创建了一个名为Web的符号链接。该链接指向/var/www。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用下面的命令来验证是否创建链接：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l web</span></span><br><span class="line">lrwxrwxrwx 1 slynux slynux 8 2010-06-25 21:34 web -&gt; /var/www</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印出当前目录下的符号链接：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep <span class="string">&quot;^l&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用find打印当前目录以及子目录下的符号链接：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> l -<span class="built_in">print</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">readlink</span>打印出符号链接所指向的目标路径：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">readlink</span> web</span></span><br><span class="line">/var/www</span><br></pre></td></tr></table></figure>

<h3 id="3-5-列举文件类型统计信息"><a href="#3-5-列举文件类型统计信息" class="headerlink" title="3.5 列举文件类型统计信息"></a>3.5 列举文件类型统计信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的命令打印文件类型信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file filename</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file /etc/passwd</span></span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印不包括文件名在内的文件类型信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file -b filename</span></span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure>

<h3 id="3-6-使用环回文件"><a href="#3-6-使用环回文件" class="headerlink" title="3.6 使用环回文件"></a>3.6 使用环回文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的命令可以创建一个1GB大小的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=loobackfile.img bs=1G count=1</span></span><br><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 37.3155 s, 28.8 MB/s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你会发现创建好的文件大小超过了1GB。这是因为硬盘作为块设备，其分配存储空间时是按照块大小的整数倍来进行的。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用mkfs命令将1GB的文件格式化成ext4文件系统：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.ext4 loopbackfile.img</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用下面的命令检查文件系统：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file loobackfile.img</span></span><br><span class="line">loobackfile.img: Linux rev 1.0 ext4 filesystem data,</span><br><span class="line">UUID=c9d56c42-f8e6-4cbd-aeab-369d5056660a (extents) (large files) (huge files)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在就可以挂载环回文件了：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /mnt/loopback</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -o loop loopbackfile.img /mnt/loopback</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-o loop用来挂载环回文件系统。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们也可以手动来操作：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">losetup /dev/loop1 loopbackfile.img</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/loop1 /mnt/loopback</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用下面的方法进行卸载（umount）：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">umount mount_point</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-生成-ISO-文件及混合型-ISO"><a href="#3-7-生成-ISO-文件及混合型-ISO" class="headerlink" title="3.7 生成 ISO 文件及混合型 ISO"></a>3.7 生成 ISO 文件及混合型 ISO</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用下面的命令从/dev/cdrom创建一个ISO镜像：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/cdrom &gt; image.iso</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">尽管可以奏效。但创建ISO镜像最好的方法还是使用<span class="built_in">dd</span>工具：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of=image.iso</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mkisofs命令用于创建ISO文件系统。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkisofs -V <span class="string">&quot;Label&quot;</span> -o image.iso source_dir/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项 -o指定了ISO文件的路径。 source_dir是作为ISO文件内容来源的目录路径，选项 -V指定了ISO文件的卷标。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-diff命令"><a href="#3-8-diff命令" class="headerlink" title="3.8 diff命令"></a>3.8 diff命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 　				# 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span><br><span class="line">-a或--text 　		# diff预设只会逐行比较文本文件。</span><br><span class="line">-b或--ignore-space-change 　# 不检查空格字符的不同。</span><br><span class="line">-B或--ignore-blank-lines 　 # 不检查空白行。</span><br><span class="line">-c 　			# 显示全部内文，并标出不同之处。</span><br><span class="line">-C或--context 	# 与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d或--minimal 	# 使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D或ifdef		# 此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e或--ed			# 此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f或-forward-ed	# 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H或--speed-large-files 　	# 比较大文件时，可加快速度。</span><br><span class="line">-l或--ignore-matching-lines 　# 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span><br><span class="line">-i或--ignore-case 　# 不检查大小写的不同。</span><br><span class="line">-l或--paginate	   # 将结果交由pr程序来分页。</span><br><span class="line">-n或--rcs 　		  # 将比较结果以RCS的格式来显示。</span><br><span class="line">-N或--new-file 　	  # 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p 　			  # 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P或--unidirectional-new-file 　# 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q或--brief 　	# 仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r或--recursive 　# 比较子目录中的文件。</span><br><span class="line">-s或--report-identical-files 　# 若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S或--starting-file 　# 在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t或--expand-tabs 　	# 在输出时，将tab字符展开。</span><br><span class="line">-T或--initial-tab 　	# 在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U或--unified= 　	# 以合并的方式来显示文件内容的不同。</span><br><span class="line">-v或--version 　		# 显示版本信息。</span><br><span class="line">-w或--ignore-all-space 　# 忽略全部的空格字符。</span><br><span class="line">-W或--width 　		# 在使用-y参数时，指定栏宽。</span><br><span class="line">-x或--exclude 　		# 不比较选项中所指定的文件或目录。</span><br><span class="line">-X或--exclude-from 　 # 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y或--side-by-side 　 # 以并列的方式显示文件的异同之处。</span><br><span class="line">--help 　			 # 显示帮助。</span><br><span class="line">--left-column 　		# 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span><br><span class="line">--suppress-common-lines 　# 在使用-y参数时，仅显示不同之处。</span><br></pre></td></tr></table></figure>

<p>生成目录的差异信息 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff -Naur directory1 directory2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-N：将所有缺失的文件视为空文件。 </li>
<li>-a：将所有文件视为文本文件。 </li>
<li>-u：生成一体化输出。 </li>
<li>-r：遍历目录下的所有文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成patch文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff -u version1.txt version2.txt &gt; version.patch</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下列命令来进行修补：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patch -p1 version1.txt &lt; version.patch</span></span><br><span class="line">patching file version1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">version1.txt的内容现在和verson2.txt的内容一模一样。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的命令可以撤销做出的修改：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patch -p1 version1.txt &lt; version.patch</span></span><br><span class="line">patching file version1.txt</span><br><span class="line">Reversed (or previously applied) patch detected! Assume -R? [n] y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改被撤销</span></span><br></pre></td></tr></table></figure>

<h3 id="3-9-more、less、head与tail命令"><a href="#3-9-more、less、head与tail命令" class="headerlink" title="3.9 more、less、head与tail命令"></a>3.9 more、less、head与tail命令</h3><h4 id="3-9-1-more文件内容输出查看工具"><a href="#3-9-1-more文件内容输出查看工具" class="headerlink" title="3.9.1 more文件内容输出查看工具"></a>3.9.1 more文件内容输出查看工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more [参数选项] [文件]</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数如下：</span> </span><br><span class="line">+num   		# 从第num行开始显示； </span><br><span class="line">-num   		# 定义屏幕大小，为num行； </span><br><span class="line">+/pattern   # 从pattern 前两行开始显示； </span><br><span class="line">-c   		# 从顶部清屏然后显示； </span><br><span class="line">-d   		# 提示Press space to continue, &#x27;q&#x27; to quit.（按空格键继续，按q键退出），禁用响铃功能； </span><br><span class="line">-l    		# 忽略Ctrl+l （换页）字符； </span><br><span class="line">-p    		# 通过清除窗口而不是滚屏来对文件进行换页。和-c参数有点相似； </span><br><span class="line">-s    		# 把连续的多个空行显示为一行； </span><br><span class="line">-u    		# 把文件内容中的下划线去掉退出more的动作指令是q </span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示提示，并从终端或控制台顶部显示；</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more -dc /etc/profile</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从profile的第4行开始显示；</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more +4 /etc/profile</span>     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每屏显示4行；</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more -4 /etc/profile</span>    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从profile中的第一个MAIL单词的前两行开始显示；</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more +/MAIL /etc/profile</span>   </span><br></pre></td></tr></table></figure>

<p>more 的动作指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter       	# 向下n行，需要定义，默认为1行； </span><br><span class="line">Ctrl+f    		# 向下滚动一屏； </span><br><span class="line">空格键			 # 向下滚动一屏； </span><br><span class="line">Ctrl+b  		# 返回上一屏； </span><br><span class="line">=         		# 输出当前行的行号； </span><br><span class="line">:f      		# 输出文件名和当前行的行号； </span><br><span class="line">v      			# 调用vi编辑器； </span><br><span class="line">! 命令          # 调用Shell，并执行命令； </span><br><span class="line">q     			# 退出more当我们查看某一文件时，想调用vi来编辑它，不要忘记了v动作指令，这是比较方便的； </span><br></pre></td></tr></table></figure>

<p>其它命令通过管道和more结合的运用例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /etc |more</span> </span><br></pre></td></tr></table></figure>

<h4 id="3-9-2-less查看文件内容工具"><a href="#3-9-2-less查看文件内容工具" class="headerlink" title="3.9.2 less查看文件内容工具"></a>3.9.2 less查看文件内容工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c 		# 从顶部（从上到下）刷新屏幕，并显示文件内容。而不是通过底部滚动完成刷新； </span><br><span class="line">-f 		# 强制打开文件，二进制文件显示时，不提示警告； </span><br><span class="line">-i 		# 搜索时忽略大小写；除非搜索串中包含大写字母； </span><br><span class="line">-I 		# 搜索时忽略大小写，除非搜索串中包含小写字母； </span><br><span class="line">-m 		# 显示读取文件的百分比； </span><br><span class="line">-M 		# 显法读取文件的百分比、行号及总行数； </span><br><span class="line">-N 		# 在每行前输出行号； </span><br><span class="line">-p 		# pattern 搜索pattern；比如在/etc/profile搜索单词MAIL，就用 less -p MAIL /etc/profile </span><br><span class="line">-s 		# 把连续多个空白行作为一个空白行显示； </span><br><span class="line">-Q 		# 在终端下不响铃； </span><br></pre></td></tr></table></figure>

<p>less的动作命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">回车键 	# 向下移动一行； </span><br><span class="line">y 		  # 向上移动一行； </span><br><span class="line">空格键 	# 向下滚动一屏； </span><br><span class="line">b 		  # 向上滚动一屏； </span><br><span class="line">d 		  # 向下滚动半屏； </span><br><span class="line">h 		  # less的帮助； </span><br><span class="line">u 		  # 向上洋动半屏； </span><br><span class="line">w 		  # 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示； </span><br><span class="line">g 		  # 跳到第一行； </span><br><span class="line">G 		  # 跳到最后一行； </span><br><span class="line">p 		  # n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示； </span><br><span class="line">/pattern  # 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词； </span><br><span class="line">v 		  # 调用vi编辑器； </span><br><span class="line">q 		  # 退出less </span><br><span class="line">!command  # 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件； </span><br></pre></td></tr></table></figure>

<h4 id="3-9-3-head"><a href="#3-9-3-head" class="headerlink" title="3.9.3 head"></a>3.9.3 head</h4><p>head 是显示一个文件的内容的前多少行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -n 10 /etc/profile</span> </span><br></pre></td></tr></table></figure>

<h4 id="3-9-4-tail"><a href="#3-9-4-tail" class="headerlink" title="3.9.4 tail"></a>3.9.4 tail</h4><p>tail 是显示一个文件的内容的最后多少行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n 5 /etc/profile</span> </span><br></pre></td></tr></table></figure>

<h3 id="3-10-getopts-参数解析"><a href="#3-10-getopts-参数解析" class="headerlink" title="3.10 getopts 参数解析"></a>3.10 getopts 参数解析</h3><h4 id="3-10-1-getopts（shell内置命令）"><a href="#3-10-1-getopts（shell内置命令）" class="headerlink" title="3.10.1 getopts（shell内置命令）"></a>3.10.1 getopts（shell内置命令）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> getopt</span></span><br><span class="line">getopt 是 /usr/bin/getopt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="built_in">getopts</span></span> </span><br><span class="line">getopts 是 shell 内建</span><br></pre></td></tr></table></figure>

<p>getopts不能直接处理长的选项（如：–prefix&#x3D;&#x2F;home等）</p>
<p>关于getopts的使用方法，可以man bash  搜索getopts。</p>
<p>getopts有两个参数，第一个参数是一个字符串，包括字符和“：”，每一个字符都是一个有效的选项，如果字符后面带有“：”，表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了“-”，并将其赋值在第二个参数中，如果带有自己参数，这个参数赋值在 <code>$OPTARG</code>中。提供getopts的shell内置了 <code>$OPTARG</code> 这个变变，getopts修改了这个变量。</p>
<p>这里变量 <code>$OPTARG</code> 存储相应选项的参数，而 <code>$OPTIND</code> 总是存储原始 <code>$*</code> 中下一个要处理的元素位置。<code>while getopts &quot;:a:bc&quot; opt</code>   #第一个冒号表示忽略错误；字符后面的冒号表示该选项必须有自己的参数</p>
<p>getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带:的意味着选项除了定义本身之外，还会带上一个参数作为选项的值，比如d:在实际的使用中就会对应-d 30，选项的值就是30；getopts字符串中没有跟随:的是开关型选项，不需要再指定值，相当于true&#x2F;false，只要带了这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串前面也加上个:，就能消除警告信息了。</p>
<p>两个特殊变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OPTIND     <span class="comment"># 特殊变量，option index，会逐个递增, 初始值为1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">OPTARG     <span class="comment"># 特殊变量，option argument，不同情况下有不同的值</span></span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo $*</span><br><span class="line">while getopts &quot;:a:bc&quot; opt</span><br><span class="line">do</span><br><span class="line">        case $opt in</span><br><span class="line">                a ) echo $OPTARG</span><br><span class="line">                    echo $OPTIND;;</span><br><span class="line">                b ) echo &quot;b $OPTIND&quot;;;</span><br><span class="line">                c ) echo &quot;c $OPTIND&quot;;;</span><br><span class="line">                ? ) echo &quot;error&quot;</span><br><span class="line">                    exit 1;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo $OPTIND</span><br><span class="line">shift $(($OPTIND - 1))</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过<span class="built_in">shift</span> $((<span class="variable">$OPTIND</span> - <span class="number">1</span>))的处理，$*中就只保留了除去选项内容的参数，可以在其后进行正常的shell编程处理了。</span></span><br><span class="line">echo $0</span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./getopts.sh -a 11 -b -c</span></span><br><span class="line">-a 11 -b -c</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">b 4</span><br><span class="line">c 5</span><br><span class="line">5</span><br><span class="line">./getopts.sh</span><br></pre></td></tr></table></figure>

<h4 id="3-10-2-getopt（一个外部工具）"><a href="#3-10-2-getopt（一个外部工具）" class="headerlink" title="3.10.2 getopt（一个外部工具）"></a>3.10.2 getopt（一个外部工具）</h4><p>具体用用法可以 man getopt</p>
<p><code>-o</code> 表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，如 <code>-carg</code> 而不能是 <code>-c arg</code>。</p>
<p><code>--long</code> 表示长选项</p>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A small example program <span class="keyword">for</span> using the new getopt(1) program.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This program will only work with bash(1)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">An similar program using the tcsh(1) script. language can be found</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">as parse.tcsh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example input and output (from the bash prompt):</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./parse.bash -a par1 <span class="string">&#x27;another arg&#x27;</span> --c-long <span class="string">&#x27;wow!*\?&#x27;</span> -cmore -b <span class="string">&quot; very long &quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Option a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Option c, no argument</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Option c, argument `more<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Option b, argument ` very long &#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Remaining arguments:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--&gt; `par1<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">--&gt; `another arg&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--&gt; `wow!*\?<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Note that we use `&quot;$@&quot;&#x27;</span> to <span class="built_in">let</span> each command-line parameter <span class="built_in">expand</span> to a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">separate word. The quotes around `<span class="variable">$@</span><span class="string">&#x27; are essential!</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">We need TEMP as the `eval set --&#x27;</span> would nuke the <span class="built_in">return</span> value of getopt.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如-carg 而不能是-c arg</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--long表示长选项</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">&quot;<span class="variable">$@</span>&quot;</span>在上面解释过</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n:出错时的信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们要创建一个名字为 <span class="string">&quot;-f&quot;</span>的目录你会怎么办？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -f <span class="comment">#不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"></span><br><span class="line">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span><br><span class="line">     -n &#x27;example.bash&#x27; -- &quot;$@&quot;`</span><br><span class="line"></span><br><span class="line">if [ $? != 0 ] ; then echo &quot;Terminating...&quot; &gt;&amp;2 ; exit 1 ; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note the quotes around `<span class="variable">$TEMP</span><span class="string">&#x27;: they are essential!</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了</span></span></span><br><span class="line">eval set -- &quot;$TEMP&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">经过getopt的处理，下面处理具体选项。</span></span></span><br><span class="line"></span><br><span class="line">while true ; do</span><br><span class="line">        case &quot;$1&quot; in</span><br><span class="line">                -a|--a-long) echo &quot;Option a&quot; ; shift ;;</span><br><span class="line">                -b|--b-long) echo &quot;Option b, argument \`$2&#x27;&quot; ; shift 2 ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        # c has an optional argument. As we are in quoted mode,</span><br><span class="line">                        # an empty parameter will be generated if its optional</span><br><span class="line">                        # argument is not found.</span><br><span class="line">                        case &quot;$2&quot; in</span><br><span class="line">                                &quot;&quot;) echo &quot;Option c, no argument&quot;; shift 2 ;;</span><br><span class="line">                                *)  echo &quot;Option c, argument \`$2&#x27;&quot; ; shift 2 ;;</span><br><span class="line">                        esac ;;</span><br><span class="line">                --) shift ; break ;;</span><br><span class="line">                *) echo &quot;Internal error!&quot; ; exit 1 ;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br><span class="line">echo &quot;Remaining arguments:&quot;</span><br><span class="line">for arg do</span><br><span class="line">   echo &#x27;--&gt; &#x27;&quot;\`$arg&#x27;&quot; ;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./getopt.sh --b-long abc -a -c33 remain</span></span><br><span class="line">Option b, argument `abc&#x27;</span><br><span class="line">Option a</span><br><span class="line">Option c, argument `33&#x27;</span><br><span class="line">Remaining arguments:</span><br><span class="line"><span class="meta prompt_">--&gt; </span><span class="language-bash">`remain<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-11-只列出目录的各种方法"><a href="#3-11-只列出目录的各种方法" class="headerlink" title="3.11 只列出目录的各种方法"></a>3.11 只列出目录的各种方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">ls</span> –d：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -d */</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用grep结合<span class="built_in">ls</span> –F：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F | grep <span class="string">&quot;/$&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当使用-F时，所有的输出项都会添加上一个代表文件类型的字符，如@、 *、 |等。目录对应的是 / 字符。我们用grep只过滤那些以 /$ 作为行尾标记的输出项。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用grep结合<span class="built_in">ls</span> –l：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep <span class="string">&quot;^d&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用find：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> d -maxdepth 1 -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-12-使用pushd和popd进行快速定位"><a href="#3-12-使用pushd和popd进行快速定位" class="headerlink" title="3.12 使用pushd和popd进行快速定位"></a>3.12 使用pushd和popd进行快速定位</h3><p>使用pushd和popd时，可以无视cd命令。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压入并切换路径：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pushd</span> /var/www</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再压入下一个目录路径：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pushd</span> /usr/src</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的命令查看栈内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dirs</span></span></span><br><span class="line">/usr/src /var/www ~ /usr/share /etc</span><br><span class="line">0 			1 	  2 	3 		4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当你想切换到列表中任意一个路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pushd</span> +3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这条命令会将栈进行翻转并切换到目录 /use/share。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">popd</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用<span class="built_in">popd</span> +num可以从列表中移除特定的路径。num是从左到右，从0到n开始计数的。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-13-tree打印目录树"><a href="#3-13-tree打印目录树" class="headerlink" title="3.13 tree打印目录树"></a>3.13 tree打印目录树</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重点标记出匹配某种样式的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree PATH -P <span class="string">&quot;*.sh&quot;</span> <span class="comment"># 用一个目录路径代替PATH</span></span></span><br><span class="line">|-- home</span><br><span class="line">| |-- packtpub</span><br><span class="line">| | `-- automate.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重点标记出除符合某种样式之外的那些文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree path -I PATTERN</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 -h选项同时打印出文件和目录的大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -h</span></span><br></pre></td></tr></table></figure>

<h2 id="4-让文件飞"><a href="#4-让文件飞" class="headerlink" title="4 让文件飞"></a>4 让文件飞</h2><h3 id="4-1-正则表达式"><a href="#4-1-正则表达式" class="headerlink" title="4.1 正则表达式"></a>4.1 正则表达式</h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行起始标记</td>
<td align="left">^tux 匹配以tux起始的行</td>
</tr>
<tr>
<td>$</td>
<td>行尾标记</td>
<td align="left">tux$ 匹配以tux结尾的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符</td>
<td align="left">Hack.匹配Hackl和Hacki，它只能匹配单个字符</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配包含在 [字符] 之中的任意一个字符</td>
<td align="left">coo[kl] 匹配cook或cool</td>
</tr>
<tr>
<td>[ ^ ]</td>
<td>匹配除 <code> [^字符]</code> 之外的任意一个字符</td>
<td align="left"><code>9[^01]</code>匹配92、 93，但是不匹配91或90</td>
</tr>
<tr>
<td>[ - ]</td>
<td>匹配 [ ] 中指定范围内的任意一个字符</td>
<td align="left">[1-5] 匹配从1～5的任意一个数字</td>
</tr>
<tr>
<td>?</td>
<td>匹配之前的项1次或0次</td>
<td align="left">colou?r 匹配color或colour，但是不能匹配colouur</td>
</tr>
<tr>
<td>+</td>
<td>匹配之前的项1次或多次</td>
<td align="left">Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td>
</tr>
<tr>
<td>*</td>
<td>匹配之前的项0次或多次</td>
<td align="left">co*l 匹配cl、 col、 coool等</td>
</tr>
<tr>
<td>( )</td>
<td>创建一个用于匹配的子串</td>
<td align="left">ma(tri)?x 匹配max或maxtrix</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配之前的项n次</td>
<td align="left">[0-9]{3} 匹 配 任 意 一 个 三 位 数 ， [0-9]{3} 可 以 扩 展 为<code>[0-9][0-9][0-9]</code></td>
</tr>
<tr>
<td>{n, }</td>
<td>之前的项至少需要匹配n次</td>
<td align="left">[0-9]{2,} 匹配任意一个两位或更多位的数字</td>
</tr>
<tr>
<td>{n, m}</td>
<td>指定之前的项所必需匹配的最小次数和最大次数</td>
<td align="left">[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字</td>
</tr>
<tr>
<td>|</td>
<td>交替——匹配 | 两边的任意一项</td>
<td align="left">Oct  (1st | 2nd) 匹配Oct 1st或Oct 2nd</td>
</tr>
<tr>
<td>\</td>
<td>转义符可以将上面介绍的特殊字符进行转义</td>
<td align="left"><code>a\.b</code> 匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>所有的字母和数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>所有字母</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>水平制表符，空白等</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>所有控制字符</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>所有的数字</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>所有可打印字符，不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>所有的小写字符</td>
</tr>
<tr>
<td>[:print:]</td>
<td>所有可打印字符，包括空格</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>所有的标点字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有的横向或纵向的空白</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>所有大写字母</td>
</tr>
</tbody></table>
<h3 id="4-2-grep命令"><a href="#4-2-grep命令" class="headerlink" title="4.2 grep命令"></a>4.2 grep命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a				# 不要忽略二进制的数据。</span><br><span class="line">-A&lt;显示列数&gt; 	 # 除了显示符合范本样式的那一列之外，并显示该列之后的内容。</span><br><span class="line">-b				# 在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</span><br><span class="line">-B&lt;显示列数&gt;	 # 除了显示符合范本样式的那一列之外，并显示该列之前的内容。</span><br><span class="line">-c				# 计算符合范本样式的列数。</span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;	# 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span><br><span class="line">-d&lt;进行动作&gt;	 # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span><br><span class="line">-e&lt;范本样式&gt;	 # 指定字符串做为查找文件内容的范本样式。</span><br><span class="line">-E				# 将范本样式为延伸的普通表示法来使用。</span><br><span class="line">-f&lt;范本文件&gt;	 # 指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</span><br><span class="line">-F				# 将范本样式视为固定字符串的列表。</span><br><span class="line">-G				# 将范本样式视为普通的表示法来使用。</span><br><span class="line">-h				# 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span><br><span class="line">-H				# 在显示符合范本样式的那一列之前，表示该列所属的文件名称。</span><br><span class="line">-i				# 忽略字符大小写的差别。</span><br><span class="line">-l				# 列出文件内容符合指定的范本样式的文件名称。</span><br><span class="line">-L				# 列出文件内容不符合指定的范本样式的文件名称。</span><br><span class="line">-n				# 在显示符合范本样式的那一列之前，标示出该列的列数编号。</span><br><span class="line">-q				# 不显示任何信息。</span><br><span class="line">-r				# 此参数的效果和指定“-d recurse”参数相同。</span><br><span class="line">-s				# 不显示错误信息。</span><br><span class="line">-v				# 反转查找。</span><br><span class="line">-V				# 显示版本信息。</span><br><span class="line">-w				# 只显示全字符合的列。</span><br><span class="line">-x				# 只显示全列符合的列。</span><br><span class="line">-o 				# 只输出文件中匹配到的部分。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单个grep命令也可以对多个文件进行搜索：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;match_text&quot;</span> file1 file2 file3 ...</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep -E选项——这意味着使用扩展（extended）正则表达式：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">&quot;[a-z]+&quot;</span> filename</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">egrep <span class="string">&quot;[a-z]+&quot;</span> filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只输出文件中匹配到的文本部分，可以使用选项 -o：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> this is a line. | egrep -o <span class="string">&quot;[a-z]+\.&quot;</span></span></span><br><span class="line">line.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要打印除包含match_pattern行之外的所有行，选项-v可以将匹配结果进行反转（invert）。可使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -v match_pattern file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计文件或文本中包含匹配字符串的行数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -c <span class="string">&quot;text&quot;</span> filename</span></span><br><span class="line">10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;1 2 3 4\nhello\n5 6&quot;</span> | egrep -c <span class="string">&quot;[0-9]&quot;</span></span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要文件中统计匹配项的数量，可以使用下面的技巧：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;1 2 3 4\nhello\n5 6&quot;</span> | egrep -o <span class="string">&quot;[0-9]&quot;</span> | <span class="built_in">wc</span> -l</span></span><br><span class="line">6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印模式匹配所位于的字符或字节偏移：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> gnu is not unix | grep -b -o <span class="string">&quot;not&quot;</span></span></span><br><span class="line">7:not</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项 -b总是和 -o配合使用。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索多个文件并找出匹配文本位于哪一个文件中：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -l linux sample1.txt sample2.txt</span></span><br><span class="line">sample1.txt</span><br><span class="line">sample2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">和-l相反的选项是-L，它会返回一个不匹配的文件列表。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep的选项-R和-r功能一样。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略样式中的大小写</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello world | grep -i <span class="string">&quot;HELLO&quot;</span></span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep匹配多个样式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> this is a line of text | grep -e <span class="string">&quot;this&quot;</span> -e <span class="string">&quot;line&quot;</span> -o</span></span><br><span class="line">this</span><br><span class="line">line</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在grep搜索中指定或排除文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;main()&quot;</span> . -r --include *.&#123;c,cpp&#125; 		<span class="comment"># 目录中递归搜索所有的 .c和 .cpp文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要排除目录，可以使用 --exclude-dir选项。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用0值字节作为后缀的grep与xargs，为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep使用-Z选项输出以0值字节作为终结符的文件名（\0）。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&quot;test&quot;</span> file* -lZ | xargs -0 <span class="built_in">rm</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-Z通常和 -l结合使用。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep的静默输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep的静默选项（-q）来实现。在静默模式中， grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要打印匹配某个结果之后的3行，使用 -A选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">seq</span> 10 | grep 5 -A 3</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要打印匹配某个结果之前的3行，使用 -B选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">seq</span> 10 | grep 5 -B 3</span></span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要打印匹配某个结果之前以及之后的3行，使用-C选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">seq</span> 10 | grep 5 -C 3</span></span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有多个匹配，那么使用--作为各部分之间的定界符：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc\na\nb\nc&quot;</span> | grep a -A 1</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h3 id="4-3-cut-按列切分文件"><a href="#4-3-cut-按列切分文件" class="headerlink" title="4.3 cut 按列切分文件"></a>4.3 cut 按列切分文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示第2列和第3列：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -f 2,3 filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>记法</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>N -</td>
<td>从第N个字节，字符或字段到行尾</td>
</tr>
<tr>
<td>N - M</td>
<td>从第N个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
<tr>
<td>- M</td>
<td>第1个字节，字符或字段到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
</tbody></table>
<p>结合下列选项将字段指定为某个范围内的字节或字符 ：</p>
<ul>
<li>-b ：表示字节</li>
<li>-c ：表示字符</li>
<li>-f ：用于定义字段</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> range_fields.txt</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印第1个到第5个字符：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -c1-5 range_fields.txt</span></span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印前2个字符：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> range_fields.txt -c -2</span></span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>

<h3 id="4-4-sed-进行文本替换"><a href="#4-4-sed-进行文本替换" class="headerlink" title="4.4 sed 进行文本替换"></a>4.4 sed 进行文本替换</h3><p>选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;script&gt;			# 以选项中指定的script来处理输入的文本文件</span><br><span class="line">-f &lt;script&gt;			# 以选项中指定的script文件来处理输入的文本文件</span><br><span class="line">-h					# 显示帮助</span><br><span class="line">-n					# 仅显示script处理后的结果</span><br><span class="line">-V					# 显示版本信息</span><br></pre></td></tr></table></figure>

<p>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a\ 			# 在当前行下面插入文本。</span><br><span class="line">i\ 			# 在当前行上面插入文本。</span><br><span class="line">c\ 			# 把选定的行改为新的文本。 </span><br><span class="line">d 			# 删除，删除选择的行。 </span><br><span class="line">D 			# 删除模板块的第一行。</span><br><span class="line">s 			# 替换指定字符 h 拷贝模板块的内容到内存中的缓冲区。 </span><br><span class="line">H 			# 追加模板块的内容到内存中的缓冲区。 </span><br><span class="line">g 			# 获得内存缓冲区的内容，并替代当前模板块中的文本。 </span><br><span class="line">G 			# 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 </span><br><span class="line">l 			# 列表不能打印字符的清单。 </span><br><span class="line">n 			# 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 </span><br><span class="line">N 			# 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 </span><br><span class="line">p 			# 打印模板块的行。 P(大写) 打印模板块的第一行。 </span><br><span class="line">q 			# 退出Sed。 </span><br><span class="line">b lable 	# 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 </span><br><span class="line">r file 		# 从file中读行。 </span><br><span class="line">t label 	# if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 </span><br><span class="line">T label 	# 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span><br><span class="line">w file 		# 写并追加模板块到file末尾。 </span><br><span class="line">W file 		# 写并追加模板块的第一行到file末尾。 </span><br><span class="line">! 			# 表示后面的命令对所有没有被选定的行发生作用。 </span><br><span class="line">= 			# 打印当前行号码。 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure>

<p>sed 替换标记：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g 		# 表示行内全面替换。</span><br><span class="line">p 		# 表示打印行。 </span><br><span class="line">w 		# 表示把行写入一个文件。 </span><br><span class="line">x 		# 表示互换模板块中的文本和缓冲区中的文本。 </span><br><span class="line">y 		# 表示把一个字符翻译为另外的字符（但是不用于正则表达式） </span><br><span class="line">\1 		# 子串匹配标记 </span><br><span class="line">&amp; 		# 已匹配字符串标记</span><br></pre></td></tr></table></figure>

<p>sed 元字符集：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^ 		# 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">		<span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。</span></span> </span><br><span class="line">. 		# 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 </span><br><span class="line">* 		# 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 </span><br><span class="line">[] 		# 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 </span><br><span class="line">[^] 	# 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span><br><span class="line">\(..\) 	# 匹配子串，保存匹配的字符，如s/(love)able/\1rs，loveable被替换成lovers。 </span><br><span class="line">&amp; 		# 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 </span><br><span class="line">\&lt; 	 	# 匹配单词的开始，如:/\&lt;love/匹配包含以开头的单词的行。</span><br><span class="line">\&gt;		# 匹配单词的结束，如:/love\&gt;/匹配包含以love结尾的单词的行。</span><br><span class="line">x\&#123;m\&#125; 		# 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。 </span><br><span class="line">x\&#123;m,\&#125; 	# 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。 </span><br><span class="line">x\&#123;m,n\&#125; 	# 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed可以替换给定文本中的字符串。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/pattern/replace_string/&#x27;</span> file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要在替换的同时保存更改，可以使用-i选项</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/text/replace/&#x27;</span> file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后缀/g意味着sed会替换每一处匹配。但是有时候我们只需要从第n处匹配开始替换。对此，可以使用/Ng选项。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/pattern/replace_string/g&#x27;</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> thisthisthisthis | sed <span class="string">&#x27;s/this/THIS/2g&#x27;</span></span></span><br><span class="line">thisTHISTHISTHIS</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> thisthisthisthis | sed <span class="string">&#x27;s/this/THIS/3g&#x27;</span></span></span><br><span class="line">thisthisTHISTHIS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符/在sed中被作为定界符使用。我们可以像下面一样使用任意的定界符：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s:text:replace:g&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s|text|replace|g&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当定界符出现在样式内部时，我们必须用前缀\对它进行转义：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s|te\|xt|replace|g&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">\|是一个出现在样式内部并经过转义的定界符。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除空白行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/^$/d&#x27;</span> file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已匹配字符串标记（&amp;）在sed中，我们可以用 &amp;标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> this is an example | sed <span class="string">&#x27;s/\w\+/[&amp;]/g&#x27;</span></span></span><br><span class="line">[this] [is] [an] [example]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它。 &amp; 对应于之前所匹配到的单词。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">组合多个表达式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;expression&#x27;</span> | sed <span class="string">&#x27;expression&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它等价于</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;expression; expression&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -e <span class="string">&#x27;expression&#x27;</span> -e expression<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">引用。sed表达式通常用单引号来引用。双引号会通过对表达式求值来对其进行扩展。</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">text=hello</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo hello world | sed &quot;s/$text/HELLO/&quot;</span></span></span><br><span class="line">HELLO world</span><br></pre></td></tr></table></figure>

<h3 id="4-5-awk-进行高级文本处理"><a href="#4-5-awk-进行高级文本处理" class="headerlink" title="4.5 awk 进行高级文本处理"></a>4.5 awk 进行高级文本处理</h3><h4 id="4-5-1-awk-常用命令选项"><a href="#4-5-1-awk-常用命令选项" class="headerlink" title="4.5.1 awk 常用命令选项"></a>4.5.1 awk 常用命令选项</h4><ul>
<li><code>-F fs</code>		fs指定输入分隔符，fs可以是字符串或正则表达式，如<code>-F:</code><ul>
<li><code>-v var=value</code>   赋值一个用户定义变量，将外部变量传递给awk</li>
</ul>
</li>
<li><code>-f scripfile</code>      从脚本文件中读取awk命令 </li>
<li><code>-m[fr] val</code>          对val值设置内在限制，<code>-mf</code> 选项限制分配给val的最大块数目；<code>-mr</code> 选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
<h4 id="4-5-2-awk-脚本基本结构"><a href="#4-5-2-awk-脚本基本结构" class="headerlink" title="4.5.2 awk 脚本基本结构"></a>4.5.2 awk 脚本基本结构</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#x27;</span> file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#x27;</span> filename</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&quot;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&quot;</span> filename</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-5-3-awk-的工作原理"><a href="#4-5-3-awk-的工作原理" class="headerlink" title="4.5.3 awk 的工作原理"></a>4.5.3 awk 的工作原理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：执行 <code>BEGIN&#123; commands &#125;</code> 语句块中的语句</li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行 <code>pattern&#123; commands &#125;</code> 语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕</li>
<li>第三步：当读至输入流末尾时，执行 <code>END&#123; commands &#125;</code> 语句块</li>
</ul>
<h4 id="4-5-4-awk-内置变量（预定义变量）"><a href="#4-5-4-awk-内置变量（预定义变量）" class="headerlink" title="4.5.4 awk 内置变量（预定义变量）"></a>4.5.4 awk 内置变量（预定义变量）</h4><p><strong>说明：</strong>  <code>[A][N][P][G]</code>表示第一个支持变量的工具，<code>[A]=awk</code>、<code>[N]=nawk</code>、<code>[P]=POSIXawk</code>、<code>[G]=gawk</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">n 				<span class="comment"># 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。</span></span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0 				<span class="comment"># 这个变量包含执行过程中当前行的文本内容。</span></span> </span><br><span class="line">[N] ARGC 		# 命令行参数的数目。 </span><br><span class="line">[G] ARGIND 		# 命令行中当前文件的位置（从0开始算）。 </span><br><span class="line">[N] ARGV 		# 包含命令行参数的数组。 </span><br><span class="line">[G] CONVFMT 	# 数字转换格式（默认值为%.6g）。 </span><br><span class="line">[P] ENVIRON 	# 环境变量关联数组。 </span><br><span class="line">[N] ERRNO 		# 最后一个系统错误的描述。 </span><br><span class="line">[G] FIELDWIDTHS # 字段宽度列表（用空格键分隔）。 </span><br><span class="line">[A] FILENAME 	# 当前输入文件的名。 </span><br><span class="line">[P] FNR 		# 同NR，但相对于当前文件。 </span><br><span class="line">[A] FS 			# 字段分隔符（默认是任何空格）。 </span><br><span class="line">[G] IGNORECASE 	# 如果为真，则进行忽略大小写的匹配。 </span><br><span class="line">[A] NF 			# 表示字段数，在执行过程中对应于当前的字段数。 </span><br><span class="line">[A] NR 			# 表示记录数，在执行过程中对应于当前的行号。 </span><br><span class="line">[A] OFMT 		# 数字的输出格式（默认值是%.6g）。 </span><br><span class="line">[A] OFS 		# 输出字段分隔符（默认值是一个空格）。 </span><br><span class="line">[A] ORS 		# 输出记录分隔符（默认值是一个换行符）。 </span><br><span class="line">[A] RS 			# 记录分隔符（默认是一个换行符）。 </span><br><span class="line">[N] RSTART 		# 由match函数所匹配的字符串的第一个位置。 </span><br><span class="line">[N] RLENGTH 	# 由match函数所匹配的字符串的长度。 </span><br><span class="line">[N] SUBSEP 		# 数组下标分隔符（默认值是34）。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;line1 f2 f3nline2 f4 f5nline3 f6 f7&quot;</span> | awk <span class="string">&#x27;&#123;print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3&#125;&#x27;</span></span> </span><br><span class="line">Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 </span><br><span class="line">Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5 </span><br><span class="line">Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">print</span> <span class="variable">$NF</span>可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;line1 f2 f3n line2 f4 f5&quot;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span> </span><br><span class="line">f3</span><br><span class="line">f5</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;line1 f2 f3n line2 f4 f5&quot;</span> | awk <span class="string">&#x27;&#123;print $(NF-1)&#125;&#x27;</span></span> </span><br><span class="line">f2 </span><br><span class="line">f4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印每一行的第二和第三个字段：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123; print $2,$3 &#125;&#x27;</span> filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计文件中的行数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;END&#123; print NR &#125;&#x27;</span> filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个每一行中第一个字段值累加的例子：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">seq</span> 5 | awk <span class="string">&#x27;BEGIN&#123; sum=0; print &quot;总和：&quot; &#125; &#123; print $1&quot;+&quot;; sum+=$1 &#125; END&#123; print &quot;等于&quot;; print sum &#125;&#x27;</span></span> </span><br><span class="line">总和： </span><br><span class="line">1+ </span><br><span class="line">2+ </span><br><span class="line">3+ </span><br><span class="line">4+ </span><br><span class="line">5+ </span><br><span class="line">等于 </span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-将外部变量值传递给awk"><a href="#4-5-5-将外部变量值传递给awk" class="headerlink" title="4.5.5 将外部变量值传递给awk"></a>4.5.5 将外部变量值传递给awk</h4><p>借助 <code>-v</code> 选项，可以将外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">VAR=10000</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">&#x27;&#123; print VARIABLE &#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种传递外部变量方法：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var1=<span class="string">&quot;aaa&quot;</span></span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">var2=<span class="string">&quot;bbb&quot;</span></span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123; print v1,v2 &#125;&#x27;</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当输入来自于文件时使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123; print v1,v2 &#125;&#x27;</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-6-awk-运算与判断"><a href="#4-5-6-awk-运算与判断" class="headerlink" title="4.5.6 awk 运算与判断"></a>4.5.6 awk 运算与判断</h4><p><strong>算数运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+ -</td>
<td>加、减</td>
</tr>
<tr>
<td>* &#x2F; &amp;</td>
<td>乘，除与求余</td>
</tr>
<tr>
<td>+ - !</td>
<td>一元加、减和逻辑非</td>
</tr>
<tr>
<td>^ ***</td>
<td>求幂</td>
</tr>
<tr>
<td>++ –</td>
<td>增加或减少，作为前缀或后缀</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=&quot;b&quot;;print a++,++a;&#125;&#x27;</span></span> </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>

<p style="color=red">**注意：**所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p>

<p><strong>赋值运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; **&#x3D;</td>
<td>赋值语句</td>
</tr>
</tbody></table>
<p><strong>逻辑运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;&#x27;</span></span></span><br><span class="line">0 1</span><br></pre></td></tr></table></figure>

<p><strong>正则运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>~  ~!</td>
<td>匹配正则表达式和不匹配正则表达式</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=&quot;100testa&quot;;if(a ~ /^100*/)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;</span></span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;  !&#x3D;  &#x3D;&#x3D;</td>
<td>关系运算符</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=11;if(a &gt;= 9)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;</span></span> </span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p style="color=red">**注意：**>  < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p>

<p><strong>其他运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>字段引用</td>
</tr>
<tr>
<td>空格</td>
<td>字符串连接符</td>
</tr>
<tr>
<td>? :</td>
<td>C条件表达式</td>
</tr>
<tr>
<td>in</td>
<td>数组中是否存在某键值</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;&#125;&#x27;</span></span> </span><br><span class="line">ok </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);&#125;&#x27;</span></span> </span><br><span class="line">0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);&#125;&#x27;</span></span> </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>运算级优先级表：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;, &amp;&#x3D;, ^&#x3D;, |&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;</td>
<td>赋值、运算</td>
</tr>
<tr>
<td>2</td>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>3</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>4</td>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>5</td>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>6</td>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>7</td>
<td>&#x3D;&#x3D;, !&#x3D;</td>
<td>等于、不等于</td>
</tr>
<tr>
<td>8</td>
<td>&lt;&#x3D;, &gt;&#x3D;, &lt;, &gt;</td>
<td>小于等于、大于等于、小于、大于</td>
</tr>
<tr>
<td>9</td>
<td>&lt;&lt;, &gt;&gt;</td>
<td>按位左移，按位右移</td>
</tr>
<tr>
<td>10</td>
<td>+, -</td>
<td>加、减</td>
</tr>
<tr>
<td>11</td>
<td>*, &#x2F;, %</td>
<td>乘、除、取模</td>
</tr>
<tr>
<td>12</td>
<td>!, ~</td>
<td>逻辑非、按位取反或补码</td>
</tr>
<tr>
<td>13</td>
<td>-, +</td>
<td>正、负</td>
</tr>
</tbody></table>
<p>级别越高越优先</p>
<h4 id="4-5-7-awk-高级输入输出"><a href="#4-5-7-awk-高级输入输出" class="headerlink" title="4.5.7 awk 高级输入输出"></a>4.5.7 awk 高级输入输出</h4><p><strong>读取下一条记录：</strong></p>
<p>awk中 <code>next</code> 语句使用：在循环逐行匹配，如果遇到 <code>next</code>，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> text.txt</span> </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c </span><br><span class="line">d </span><br><span class="line">e </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;&#x27;</span> text.txt</span> </span><br><span class="line">2 b </span><br><span class="line">4 d </span><br></pre></td></tr></table></figure>

<p>当记录行号除以2余1，就跳过当前行。下面的 <code>print NR,$0</code> 也不会执行。下一行开始，程序有开始判断 <code>NR%2</code> 值。这个时候记录行号是 <code>：2</code>  ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p>
<p>分析发现需要将包含有 “web” 行进行跳过，然后需要将内容与下面行合并为一行： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> text.txt</span> </span><br><span class="line">web01[192.168.2.100] </span><br><span class="line">httpd 		ok </span><br><span class="line">tomcat 		ok </span><br><span class="line">sendmail 	ok </span><br><span class="line">web02[192.168.2.101] </span><br><span class="line">httpd 		ok </span><br><span class="line">postfix 	ok </span><br><span class="line">web03[192.168.2.102] </span><br><span class="line">mysqld 		ok </span><br><span class="line">httpd 		ok </span><br><span class="line">0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;/^web/&#123;T=$0;next;&#125;&#123;print T&quot;:t&quot;$0;&#125;&#x27;</span> test.txt</span> </span><br><span class="line">web01[192.168.2.100]: httpd 		ok </span><br><span class="line">web01[192.168.2.100]: tomcat 		ok </span><br><span class="line">web01[192.168.2.100]: sendmail 		ok </span><br><span class="line">web02[192.168.2.101]: httpd 		ok </span><br><span class="line">web02[192.168.2.101]: postfix 		ok </span><br><span class="line">web03[192.168.2.102]: mysqld 		ok </span><br><span class="line">web03[192.168.2.102]: httpd 		ok</span><br></pre></td></tr></table></figure>

<p><strong>简单地读取一条记录：</strong></p>
<p><code>awk getline</code> 用法：输出重定向需用到 <code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。<p style="color=red">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 </p></p>
<blockquote>
<p>getline语法：getline var，变量var包含了特定行的内容。 </p>
</blockquote>
<p>awk getline从整体上来说，用法说明：</p>
<ul>
<li><strong>当其左右<p style="color=red">无</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量 <code>var</code> 或 <code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。</li>
<li><strong>当其左右<p style="color=red">有</p>重定向符 <code>|</code> 或 <code>&lt;</code> 时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行linux的<span class="built_in">date</span>命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; &quot;date&quot; | getline out; print out &#125;&#x27;</span> <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行shell的<span class="built_in">date</span>命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，<span class="built_in">split</span>函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; &quot;date&quot; | getline out; split(out,mon); print mon[2] &#125;&#x27;</span> <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令<span class="built_in">ls</span>的输出传递给geline作为输入，循环使getline从<span class="built_in">ls</span>的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; while( &quot;ls&quot; | getline) print &#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>关闭文件：</strong></p>
<p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(&quot;filename&quot;)</span><br></pre></td></tr></table></figure>

<p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p>
<p><strong>输出到一个文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;printf(&quot;hello word!n&quot;) &gt; &quot;datafile&quot;&#125;&#x27;</span></span></span><br><span class="line">或 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;printf(&quot;hello word!n&quot;) &gt;&gt; &quot;datafile&quot;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-8-设置字段定界符"><a href="#4-5-8-设置字段定界符" class="headerlink" title="4.5.8 设置字段定界符"></a>4.5.8 设置字段定界符</h4><p style="color=red">默认的字段定界符是空格</p>，可以使用 `-F "定界符"` 明确指定一个定界符：

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk -F: <span class="string">&#x27;&#123; print $NF &#125;&#x27;</span> /etc/passwd</span> </span><br><span class="line">或 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123; FS=&quot;:&quot; &#125; &#123; print $NF &#125;&#x27;</span> /etc/passwd</span></span><br></pre></td></tr></table></figure>

<p>在 <code>BEGIN语句块</code> 中则可以用 <code>OFS=“定界符”</code> 设置输出字段的定界符。</p>
<h4 id="4-5-9-流程控制语句"><a href="#4-5-9-流程控制语句" class="headerlink" title="4.5.9 流程控制语句"></a>4.5.9 流程控制语句</h4><p><strong>条件判断语句：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	test=100; </span><br><span class="line"><span class="meta prompt_">	if(test&gt;</span><span class="language-bash"><span class="string">90)&#123;</span></span> </span><br><span class="line">		print &quot;very good&quot;; </span><br><span class="line">	&#125; else if(test&gt;60)&#123; </span><br><span class="line">		print &quot;good&quot;; </span><br><span class="line">	&#125; else&#123; </span><br><span class="line">		print &quot;no pass&quot;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure>

<p>每条命令语句后面可以用 <code>;</code> <p style="color=red">分号</p>结尾。</p>
<p><strong>循环语句：</strong></p>
<p>while语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	test=100; </span><br><span class="line">	total=0; </span><br><span class="line">	while(i&lt;=test)&#123; </span><br><span class="line">		total+=i; i++; </span><br><span class="line">	&#125; </span><br><span class="line">	print total; </span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p>for循环：</p>
<p>格式1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	for(k in ENVIRON)&#123; </span><br><span class="line">		print k&quot;=&quot;ENVIRON[k]; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;&#x27; </span><br><span class="line">TERM=linux </span><br><span class="line">G_BROKEN_FILENAMES=1 </span><br><span class="line">SHLVL=1 </span><br><span class="line">pwd=/root/text </span><br><span class="line">... </span><br><span class="line">logname=root </span><br><span class="line">HOME=/root </span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>ENVIRON是awk常量，是子典型数组。</p>
<p>格式2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	total=0; </span><br><span class="line">	for(i=0;i&lt;=100;i++)&#123; </span><br><span class="line">		total+=i; </span><br><span class="line">	&#125; </span><br><span class="line">	print total; </span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p>do循环：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	total=0; </span><br><span class="line">	i=0; </span><br><span class="line">	do &#123;</span><br><span class="line">		total+=i;i++;</span><br><span class="line">	&#125; while(i&lt;=100) </span><br><span class="line">	print total; </span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p><strong>其他语句：</strong></p>
<ul>
<li><strong>break</strong>  		当 break 语句用于 while 或 for 语句时，导致退出程序循环</li>
<li><strong>continue</strong>       当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</li>
<li><strong>next</strong>               能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程</li>
<li><strong>exit</strong>                 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</li>
</ul>
<h4 id="4-5-10-数组应用"><a href="#4-5-10-数组应用" class="headerlink" title="4.5.10 数组应用"></a>4.5.10 数组应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">得到数组长度</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),lens;&#125;&#x27;</span></span> </span><br><span class="line">4 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">length返回字符串以及数组长度，<span class="built_in">split</span>进行分割字符串为数组，也会返回分割得到数组长度。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">asort对数组进行排序，返回数组长度。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);&#125;&#x27;</span></span> </span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出数组内容（无序，有序输出）：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;</span></span> </span><br><span class="line">4 test </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span>…<span class="keyword">in</span> 输出，因为数组是关联数组，默认是无序的。所以通过 <span class="keyword">for</span>…<span class="keyword">in</span> 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;&#x27;</span></span> </span><br><span class="line">1 it </span><br><span class="line">2 is </span><br><span class="line">3 a </span><br><span class="line">4 test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：数组下标是从1开始，与C数组不一样。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断键值存在以及删除键值：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB)&#123;print &quot;ok&quot;;&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27;</span></span> </span><br><span class="line">a a1 </span><br><span class="line">b b1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除键值：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27;</span></span> </span><br><span class="line">b b1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二维、多维数组使用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;</span></span> </span><br><span class="line">	for(i=1;i&lt;=9;i++)&#123; </span><br><span class="line">		for(j=1;j&lt;=9;j++)&#123; </span><br><span class="line">			tarr[i,j]=i*j; </span><br><span class="line">			print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j]; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;&#x27; </span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 </span><br><span class="line">1 * 3 = 3 </span><br><span class="line">1 * 4 = 4 </span><br><span class="line">1 * 5 = 5 </span><br><span class="line">1 * 6 = 6 </span><br><span class="line">... </span><br><span class="line">9 * 6 = 54 </span><br><span class="line">9 * 7 = 63 </span><br><span class="line">9 * 8 = 72 </span><br><span class="line">9 * 9 = 81</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">可以通过array[k,k2]引用获得数组内容。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">另一种方法：</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">awk &#x27;</span>BEGIN&#123;</span> </span><br><span class="line">	for(i=1;i&lt;=9;i++)&#123; </span><br><span class="line">		for(j=1;j&lt;=9;j++)&#123; </span><br><span class="line">			tarr[i,j]=i*j; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	for(m in tarr)&#123; </span><br><span class="line">		split(m,tarr2,SUBSEP); print tarr2[1],&quot;*&quot;,tarr2[2],&quot;=&quot;,tarr[m]; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-11-内置函数"><a href="#4-5-11-内置函数" class="headerlink" title="4.5.11 内置函数"></a>4.5.11 内置函数</h4><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p>
<p><strong>算数函数：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>atan2( y, x )</td>
<td>返回 y&#x2F;x 的反正切</td>
</tr>
<tr>
<td>cos( x )</td>
<td>返回 x 的余弦；x 是弧度</td>
</tr>
<tr>
<td>sin( x )</td>
<td>返回 x 的正弦；x 是弧度</td>
</tr>
<tr>
<td>exp( x )</td>
<td>返回 x 幂函数</td>
</tr>
<tr>
<td>log( x )</td>
<td>返回 x 的自然对数</td>
</tr>
<tr>
<td>sqrt( x )</td>
<td>返回 x 平方根</td>
</tr>
<tr>
<td>int( x )</td>
<td>返回 x 的截断至整数的值</td>
</tr>
<tr>
<td>rand( )</td>
<td>返回任意数字 n，其中 0 &lt;&#x3D; n &lt; 1</td>
</tr>
<tr>
<td>srand( [expr] )</td>
<td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;&#x27;</span></span> </span><br><span class="line">0.841 22026.466 2.303 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得随机数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span></span> </span><br><span class="line">78 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span></span> </span><br><span class="line">31 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span></span> </span><br><span class="line">41 </span><br></pre></td></tr></table></figure>

<p><strong>字符串函数：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>gsub( Ere, Repl, [ In ] )</td>
<td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行</td>
</tr>
<tr>
<td>sub( Ere, Repl, [ In ] )</td>
<td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）</td>
</tr>
<tr>
<td>index( String1, String2 )</td>
<td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）</td>
</tr>
<tr>
<td>length [(String)]</td>
<td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td>
</tr>
<tr>
<td>blength [(String)]</td>
<td>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）</td>
</tr>
<tr>
<td>substr( String, M, [ N ] )</td>
<td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度</td>
</tr>
<tr>
<td>match( String, Ere )</td>
<td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）</td>
</tr>
<tr>
<td>split( String, A, [Ere] )</td>
<td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建</td>
</tr>
<tr>
<td>tolower( String )</td>
<td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td>
</tr>
<tr>
<td>toupper( String )</td>
<td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义</td>
</tr>
<tr>
<td>sprintf(Format, Expr, Expr, . . . )</td>
<td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串</td>
</tr>
</tbody></table>
<p><strong>注：</strong>Ere都可以是正则表达式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsub,sub使用</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info&#125;&#x27;</span></span> </span><br><span class="line">this is a test!test!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找字符串（index使用）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;</span></span> </span><br><span class="line">ok</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正则表达式匹配查找(match使用）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;</span></span> </span><br><span class="line">ok</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截取字符串(substr使用）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#x27;</span></span> </span><br><span class="line">s is a tes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串分割（<span class="built_in">split</span>使用）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;</span></span> </span><br><span class="line">4 </span><br><span class="line">4 test </span><br><span class="line">1 this </span><br><span class="line">2 is </span><br><span class="line">3 a</span><br></pre></td></tr></table></figure>

<p><strong>格式化字符串输出（sprintf使用）</strong> </p>
<p>格式化字符串格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>十进制有符号整数</td>
</tr>
<tr>
<td>%u</td>
<td>十进制无符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符</td>
</tr>
<tr>
<td>%p</td>
<td>指针的值</td>
</tr>
<tr>
<td>%e</td>
<td>指数形式的浮点数</td>
</tr>
<tr>
<td>%x</td>
<td>%X 无符号以十六进制表示的整数</td>
</tr>
<tr>
<td>%o</td>
<td>无符号以八进制表示的整数</td>
</tr>
<tr>
<td>%g</td>
<td>自动选择合适的表示法</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%on&quot;,n1,n2,n3,n1,n1);&#125;&#x27;</span></span> </span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure>

<p><strong>一般函数：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>close( Expression )</td>
<td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的</td>
</tr>
<tr>
<td>system(command )</td>
<td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程</td>
</tr>
<tr>
<td>Expression | getline [ Variable ]</td>
<td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td>
</tr>
<tr>
<td>getline [ Variable ] &lt; Expression</td>
<td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录</td>
</tr>
<tr>
<td>getline [ Variable ]</td>
<td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开外部文件（close用法）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;while(&quot;cat /etc/passwd&quot;|getline)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;</span></span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逐行读取外部文件(getline使用方法）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;while(getline &lt; &quot;/etc/passwd&quot;)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;</span></span> </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin </span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;print &quot;Enter your name:&quot;;getline name;print name;&#125;&#x27;</span></span> </span><br><span class="line">Enter your name: </span><br><span class="line">chengmo </span><br><span class="line">chengmo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用外部应用程序(system使用方法）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;b=system(&quot;ls -al&quot;);print b;&#125;&#x27;</span></span> </span><br><span class="line">total 42092 </span><br><span class="line">drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . </span><br><span class="line">drwxr-xr-x 95 root root 4096 10-08 14:01 .. </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">b返回值，是执行结果。</span></span><br></pre></td></tr></table></figure>

<p><strong>时间函数：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数名</td>
<td>说明</td>
</tr>
<tr>
<td>mktime( YYYY MM dd HH MM ss[ DST])</td>
<td>生成时间格式</td>
</tr>
<tr>
<td>strftime([format [, timestamp]])</td>
<td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.</td>
</tr>
<tr>
<td>systime()</td>
<td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建指定时间(mktime使用）</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);&#125;&#x27;</span></span> </span><br><span class="line">2001年01月01日 星期一 12时12分12秒 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;&#125;&#x27;</span></span> </span><br><span class="line">2634468 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求2个时间段中间时间差，介绍了strftime使用方法</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=systime();print tstamp2-tstamp1;&#125;&#x27;</span></span> </span><br><span class="line">308201392</span><br></pre></td></tr></table></figure>

<p>strftime日期和时间格式说明符</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%a</td>
<td>星期几的缩写（Sun）</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的完整写法（Sunday）</td>
</tr>
<tr>
<td>%b</td>
<td>月名的缩写（Oct）</td>
</tr>
<tr>
<td>%B</td>
<td>月名的完整写法（October）</td>
</tr>
<tr>
<td>%c</td>
<td>本地日期和时间</td>
</tr>
<tr>
<td>%d</td>
<td>十进制日期</td>
</tr>
<tr>
<td>%D</td>
<td>日期 08&#x2F;20&#x2F;99</td>
</tr>
<tr>
<td>%e</td>
<td>日期，如果只有一位会补上一个空格</td>
</tr>
<tr>
<td>%H</td>
<td>用十进制表示24小时格式的时间</td>
</tr>
<tr>
<td>%I</td>
<td>用十进制表示12小时格式的时间</td>
</tr>
<tr>
<td>%j</td>
<td>从1月1日期一年中的第几天</td>
</tr>
<tr>
<td>%m</td>
<td>十进制表示的月份</td>
</tr>
<tr>
<td>%M</td>
<td>十进制表示的分钟</td>
</tr>
<tr>
<td>%p</td>
<td>12小时表示法（AM&#x2F;PM）</td>
</tr>
<tr>
<td>%S</td>
<td>十进制表示的秒</td>
</tr>
<tr>
<td>%U</td>
<td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td>
</tr>
<tr>
<td>%w</td>
<td>十进制表示的星期几（星期天是0）</td>
</tr>
<tr>
<td>%W</td>
<td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td>
</tr>
<tr>
<td>%x</td>
<td>重新设置本地日期（08&#x2F;20&#x2F;99）</td>
</tr>
<tr>
<td>%X</td>
<td>重新设置本地时间（12 : 00 : 00）</td>
</tr>
<tr>
<td>%y</td>
<td>两位数字表示的年（99）</td>
</tr>
<tr>
<td>%Y</td>
<td>当前月份</td>
</tr>
<tr>
<td>%Z</td>
<td>时区（PDT）</td>
</tr>
<tr>
<td>%%</td>
<td>百分号（%）</td>
</tr>
</tbody></table>
<h3 id="4-6-find-对目录中的所有文件进行文本替换"><a href="#4-6-find-对目录中的所有文件进行文本替换" class="headerlink" title="4.6 find 对目录中的所有文件进行文本替换"></a>4.6 find 对目录中的所有文件进行文本替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将所有.cpp文件中的Copyright替换成Copyleft：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name *.cpp -print0 | xargs -I&#123;&#125; -0 sed -i <span class="string">&#x27;s/Copyright/Copyleft/g&#x27;</span> &#123;&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项-<span class="built_in">exec</span>实现同样的效果：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name *.cpp -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/Copyright/Copyleft/g&#x27;</span> \&#123;\&#125; \;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-一团乱麻"><a href="#5-一团乱麻" class="headerlink" title="5 一团乱麻"></a>5 一团乱麻</h2><h3 id="5-1-wget命令"><a href="#5-1-wget命令" class="headerlink" title="5.1 wget命令"></a>5.1 wget命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：			# 在指定的日志文件中记录资料的执行过程； </span><br><span class="line">-A&lt;后缀名&gt;：			 # 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔； </span><br><span class="line">-b：					   # 进行后台的方式运行wget； </span><br><span class="line">-B&lt;连接地址&gt;：			# 设置参考的连接地址的基地地址； </span><br><span class="line">-c：					   # 继续执行上次终端的任务； </span><br><span class="line">-C&lt;标志&gt;：				 # 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； </span><br><span class="line">-d：					   # 调试模式运行指令； </span><br><span class="line">-D&lt;域名列表&gt;：		    # 设置顺着的域名列表，域名之间用“，”分隔； </span><br><span class="line">-e&lt;指令&gt;：				 # 作为文件“.wgetrc”中的一部分执行指定的指令； </span><br><span class="line">-h：					   # 显示指令帮助信息； </span><br><span class="line">-i&lt;文件&gt;：				 # 从指定文件获取要下载的URL地址； </span><br><span class="line">-l&lt;目录列表&gt;：			# 设置顺着的目录列表，多个目录用“，”分隔； </span><br><span class="line">-L：					   # 仅顺着关联的连接； </span><br><span class="line">-r：					   # 递归下载方式； </span><br><span class="line">-nc：				   # 文件存在时，下载文件不覆盖原有文件； </span><br><span class="line">-nv：				   # 下载时只显示更新和出错信息，不显示指令的详细执行过程； </span><br><span class="line">-q：					   # 不显示指令执行过程； </span><br><span class="line">-nh：				   # 不查询主机名称； </span><br><span class="line">-v：					   # 显示详细执行过程； </span><br><span class="line">-V：					   # 显示版本信息； </span><br><span class="line">--passive-ftp：		   # 使用被动模式PASV连接FTP服务器； </span><br><span class="line">--follow-ftp：		   # 从HTML文件中下载FTP连接文件。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget下载单个文件</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载并以不同的文件名保存</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -O wordpress.zip http://www.linuxde.net/download.aspx?<span class="built_in">id</span>=1080</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget限速下载</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --limit-rate=300k http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget断点续传</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -c http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget后台下载</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -b http://www.linuxde.net/testfile.zip</span> </span><br><span class="line">Continuing in background, pid 1840. </span><br><span class="line">Output will be written to `wget-log&#x27;.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f wget-log</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">伪装代理名称下载</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --user-agent=<span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot;</span> http://www.linuxde.net/testfile.zip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。</span></span><br></pre></td></tr></table></figure>

<p><strong>测试下载链接：</strong></p>
<p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --spider URL</span></span><br></pre></td></tr></table></figure>

<p>如果下载链接正确，将会显示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 200 OK </span><br><span class="line">Length: unspecified [text/html] </span><br><span class="line">Remote file exists and could contain further links, </span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure>

<p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --spider url</span> </span><br><span class="line">Spider mode enabled. Check if remote file exists. </span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found </span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure>

<p>你可以在以下几种情况下使用–spider参数：</p>
<ul>
<li>定时下载之前进行检查</li>
<li>间隔检测网站是否可用</li>
<li>检查网站页面的死链接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加重试次数</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --tries=40 URL</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载多个文件</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -i filelist.txt</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，保存一份下载链接文件：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; filelist.txt</span> </span><br><span class="line">url1 </span><br><span class="line">url2 </span><br><span class="line">url3 </span><br><span class="line">url4 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接着使用这个文件和参数-i下载。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">过滤指定格式下载</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --reject=gif ur</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载一个网站，但你不希望下载图片，可以使用这条命令。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把下载信息存入日志文件</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -o download.log URL</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不希望下载信息直接显示在终端而是在一个日志文件，可以使用。</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制总下载文件大小</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -Q5m -i filelist.txt</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br></pre></td></tr></table></figure>

<p><strong>镜像网站：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --mirror -p --convert-links -P ./LOCAL URL</span> </span><br></pre></td></tr></table></figure>

<p>下载整个网站到本地。</p>
<ul>
<li>–mirror 开户镜像下载</li>
<li>-p 下载所有为了html页面显示正常的文件</li>
<li>–convert-links 下载后，转换成本地的链接</li>
<li>-P .&#x2F;LOCAL URL 保存所有文件和目录到本地指定目录</li>
</ul>
<p><strong>下载指定格式文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -r -A.pdf url</span></span><br></pre></td></tr></table></figure>

<p>可以在以下情况使用该功能：</p>
<ul>
<li>下载一个网站的所有图片</li>
<li>下载一个网站的所有视频</li>
<li>下载一个网站的所有PDF文件</li>
</ul>
<p><strong>FTP下载：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget ftp-url</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span></span><br></pre></td></tr></table></figure>

<p>可以使用wget来完成ftp链接的下载。 </p>
<p>使用wget匿名ftp下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget ftp-url</span></span><br></pre></td></tr></table></figure>

<p>使用wget用户名和密码认证的ftp下载： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-curl-命令"><a href="#5-2-curl-命令" class="headerlink" title="5.2 curl 命令"></a>5.2 curl 命令</h3><p>常见参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              # 设置用户代理发送给服务器</span><br><span class="line">-b/--cookie &lt;name=string/file&gt;    	  # cookie字符串或文件读取位置</span><br><span class="line">-c/--cookie-jar &lt;file&gt;                # 操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at &lt;offset&gt;             # 断点续转</span><br><span class="line">-D/--dump-header &lt;file&gt;               # 把header信息写入到该文件中</span><br><span class="line">-e/--referer                          # 来源网址</span><br><span class="line">-f/--fail                             # 连接失败时不显示http错误</span><br><span class="line">-o/--output                           # 把输出写到该文件中</span><br><span class="line">-O/--remote-name                      # 把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-r/--range &lt;range&gt;                    # 检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-s/--silent                           # 静音模式。不输出任何东西</span><br><span class="line">-T/--upload-file &lt;file&gt;               # 上传文件</span><br><span class="line">-u/--user &lt;user[:password]&gt;           # 设置服务器的用户和密码</span><br><span class="line">-w/--write-out [format]               # 什么输出完成后</span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              # 在给定的端口上使用HTTP代理</span><br><span class="line"><span class="meta prompt_">-#</span><span class="language-bash">/--progress-bar                     <span class="comment"># 进度条显示当前的传送状态</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不显示进度信息使用--silent选项。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL --silent</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用选项 -O 将下载的数据写入到文件，必须使用文件的绝对地址：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://man.linuxde.net/text.iso --silent -O</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://man.linuxde.net/test.iso -o filename.iso --progress</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######################################## 100.0%</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断点续传</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL/File -C 偏移量</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -C -URL</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--referer选项指定参照页字符串：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --referer http://www.google.com http://man.linuxde.net</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用curl设置cookies 使用--cookie <span class="string">&quot;COKKIES&quot;</span>选项来指定cookie，多个cookie使用分号分隔：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://man.linuxde.net --cookie <span class="string">&quot;user=root;pass=123456&quot;</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将cookie另存为一个文件，使用--cookie-jar选项：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL --cookie-jar cookie_file</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用--user-agent或者-A选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL --user-agent <span class="string">&quot;Mozilla/5.0&quot;</span> curl URL -A <span class="string">&quot;Mozilla/5.0&quot;</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他HTTP头部信息也可以使用curl来发送，使用-H<span class="string">&quot;头部信息&quot;</span> 传递多个头部信息，例如：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -H <span class="string">&quot;Host:man.linuxde.net&quot;</span> -H <span class="string">&quot;accept-language:zh-cn&quot;</span> URL</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl的带宽控制和下载配额 使用--limit-rate限制curl的下载速度：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL --limit-rate 50k</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中用k（千字节）和m（兆字节）指定下载速度限制。</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--max-filesize指定可下载的最大文件大小：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl URL --max-filesize bytes</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用curl进行认证 使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -u user:<span class="built_in">pwd</span> http://man.linuxde.net</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -u user http://man.linuxde.net</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只打印响应头部信息 通过-I或者-<span class="built_in">head</span>可以只打印出HTTP头部信息：</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -I http://man.linuxde.net</span> </span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: nginx/1.2.5 </span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT </span><br><span class="line">Content-Type: text/html; charset=UTF-8 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure>

<p>其他参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                    # 上传文件时，附加到目标文件</span><br><span class="line">--anyauth                      # 可以使用“任何”身份验证方法</span><br><span class="line">--basic                        # 使用HTTP基本验证</span><br><span class="line">-B/--use-ascii                 # 使用ASCII文本传输</span><br><span class="line">-d/--data &lt;data&gt;               # HTTP POST方式传送数据</span><br><span class="line">--data-ascii &lt;data&gt;            # 以ascii的方式post数据</span><br><span class="line">--data-binary &lt;data&gt;           # 以二进制的方式post数据</span><br><span class="line">--negotiate                    # 使用HTTP身份验证</span><br><span class="line">--digest                       # 使用数字身份验证</span><br><span class="line">--disable-eprt                 # 禁止使用EPRT或LPRT</span><br><span class="line">--disable-epsv                 # 禁止使用EPSV</span><br><span class="line">--egd-file &lt;file&gt;              # 为随机数据(SSL)设置EGD socket路径</span><br><span class="line">--tcp-nodelay                  # 使用TCP_NODELAY选项</span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      # 客户端证书文件和密码 (SSL)</span><br><span class="line">--cert-type &lt;type&gt;             # 证书文件类型 (DER/PEM/ENG) (SSL)</span><br><span class="line">--key &lt;key&gt;                    # 私钥文件名 (SSL)</span><br><span class="line">--key-type &lt;type&gt;              # 私钥文件类型 (DER/PEM/ENG) (SSL)</span><br><span class="line">--pass  &lt;pass&gt;                 # 私钥密码 (SSL)</span><br><span class="line">--engine &lt;eng&gt;                 # 加密引擎使用 (SSL). &quot;--engine list&quot; for list</span><br><span class="line">--cacert &lt;file&gt;                # CA证书 (SSL)</span><br><span class="line">--capath &lt;directory&gt;           # CA目   (made using c_rehash) to verify peer against (SSL)</span><br><span class="line">--ciphers &lt;list&gt;               # SSL密码</span><br><span class="line">--compressed                   # 要求返回是压缩的形势 (using deflate or gzip)</span><br><span class="line">--connect-timeout &lt;seconds&gt;    # 设置最大请求时间</span><br><span class="line">--create-dirs                  # 建立本地目录的目录层次结构</span><br><span class="line">--crlf                         # 上传是把LF转变成CRLF</span><br><span class="line">--ftp-create-dirs              # 如果远程目录不存在，创建远程目录</span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    # 控制CWD的使用</span><br><span class="line">--ftp-pasv                     # 使用 PASV/EPSV 代替端口</span><br><span class="line">--ftp-skip-pasv-ip             # 使用PASV的时候,忽略该IP地址</span><br><span class="line">--ftp-ssl                      # 尝试用 SSL/TLS 来进行ftp数据传输</span><br><span class="line">--ftp-ssl-reqd                 # 要求用 SSL/TLS 来进行ftp数据传输</span><br><span class="line">-F/--form &lt;name=content&gt;       # 模拟http表单提交数据</span><br><span class="line">-form-string &lt;name=string&gt;     # 模拟http表单提交数据</span><br><span class="line">-g/--globoff                   # 禁用网址序列和范围使用&#123;&#125;和[]</span><br><span class="line">-G/--get                       # 以get的方式来发送数据</span><br><span class="line">-h/--help                      # 帮助</span><br><span class="line">-H/--header &lt;line&gt;             # 自定义头信息传递给服务器</span><br><span class="line">--ignore-content-length        # 忽略的HTTP头信息的长度</span><br><span class="line">-i/--include                   # 输出时包括protocol头信息</span><br><span class="line">-I/--head                      # 只显示文档信息</span><br><span class="line">-j/--junk-session-cookies      # 读取文件时忽略session cookie</span><br><span class="line">--interface &lt;interface&gt;        # 使用指定网络接口/地址</span><br><span class="line">--krb4 &lt;level&gt;                 # 使用指定安全级别的krb4</span><br><span class="line">-k/--insecure                  # 允许不使用证书到SSL站点</span><br><span class="line">-K/--config                    # 指定的配置文件读取</span><br><span class="line">-l/--list-only                 # 列出ftp目录下的文件名称</span><br><span class="line">--limit-rate &lt;rate&gt;            # 设置传输速度</span><br><span class="line">--local-port&lt;NUM&gt;              # 强制使用本地端口号</span><br><span class="line">-m/--max-time &lt;seconds&gt;        # 设置最大传输时间</span><br><span class="line">--max-redirs &lt;num&gt;             # 设置最大读取的目录数</span><br><span class="line">--max-filesize &lt;bytes&gt;         # 设置最大下载的文件总量</span><br><span class="line">-M/--manual                    # 显示全手动</span><br><span class="line">-n/--netrc                     # 从netrc文件中读取用户名和密码</span><br><span class="line">--netrc-optional               # 使用 .netrc 或者 URL来覆盖-n</span><br><span class="line">--ntlm                         # 使用 HTTP NTLM 身份验证</span><br><span class="line">-N/--no-buffer                 # 禁用缓冲输出</span><br><span class="line">-p/--proxytunnel               # 使用HTTP代理</span><br><span class="line">--proxy-anyauth                # 选择任一代理身份验证方法</span><br><span class="line">--proxy-basic                  # 在代理上使用基本身份验证</span><br><span class="line">--proxy-digest                 # 在代理上使用数字身份验证</span><br><span class="line">--proxy-ntlm                   # 在代理上使用ntlm身份验证</span><br><span class="line">-P/--ftp-port &lt;address&gt;        # 使用端口地址，而不是使用PASV</span><br><span class="line">-Q/--quote &lt;cmd&gt;               # 文件传输前，发送命令到服务器</span><br><span class="line">--range-file                   # 读取（SSL）的随机文件</span><br><span class="line">-R/--remote-time               # 在本地生成文件时，保留远程文件时间</span><br><span class="line">--retry &lt;num&gt;                  # 传输出现问题时，重试的次数</span><br><span class="line">--retry-delay &lt;seconds&gt;        # 传输出现问题时，设置重试间隔时间</span><br><span class="line">--retry-max-time &lt;seconds&gt;     # 传输出现问题时，设置最大重试时间</span><br><span class="line">-S/--show-error                # 显示错误</span><br><span class="line">--socks4 &lt;host[:port]&gt;         # 用socks4代理给定主机和端口</span><br><span class="line">--socks5 &lt;host[:port]&gt;         # 用socks5代理给定主机和端口</span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;   # Telnet选项设置</span><br><span class="line">--trace &lt;file&gt;                 # 对指定文件进行debug</span><br><span class="line">--trace-ascii &lt;file&gt;           # Like --跟踪但没有hex输出</span><br><span class="line">--trace-time                   # 跟踪/详细输出时，添加时间戳</span><br><span class="line">--url &lt;URL&gt;                    # Spet URL to work with</span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  	# 设置代理用户名和密码</span><br><span class="line">-V/--version                   # 显示版本信息</span><br><span class="line">-X/--request &lt;command&gt;         # 指定什么命令</span><br><span class="line">-y/--speed-time                # 放弃限速所要的时间。默认为30</span><br><span class="line">-Y/--speed-limit               # 停止传输速度的限制，速度时间&#x27;秒</span><br><span class="line">-z/--time-cond                 # 传送时间设置</span><br><span class="line">-0/--http1.0                   # 使用HTTP 1.0</span><br><span class="line">-1/--tlsv1                     # 使用TLSv1（SSL）</span><br><span class="line">-2/--sslv2                     # 使用SSLv2的（SSL）</span><br><span class="line">-3/--sslv3                     # 使用的SSLv3（SSL）</span><br><span class="line">--3p-quote                     # like -Q for the source URL for 3rd party transfer</span><br><span class="line">--3p-url                       # 使用url，进行第三方传送</span><br><span class="line">--3p-user                      # 使用用户名和密码，进行第三方传送</span><br><span class="line">-4/--ipv4                      # 使用IP4</span><br><span class="line">-6/--ipv6                      # 使用IP6</span><br></pre></td></tr></table></figure>

<h3 id="5-3-curl-wget两种方法模拟http的get-post请求"><a href="#5-3-curl-wget两种方法模拟http的get-post请求" class="headerlink" title="5.3 curl wget两种方法模拟http的get post请求"></a>5.3 curl wget两种方法模拟http的get post请求</h3><p><strong>get请求：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用curl命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl <span class="string">&quot;http://www.baidu.com&quot;</span>  		<span class="comment"># 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -i <span class="string">&quot;http://www.baidu.com&quot;</span>  	<span class="comment"># 显示全部信息</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -l <span class="string">&quot;http://www.baidu.com&quot;</span> 	<span class="comment"># 只显示头部信息</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v <span class="string">&quot;http://www.baidu.com&quot;</span> 	<span class="comment"># 显示get请求全过程解析</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget <span class="string">&quot;http://www.baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>post请求：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用curl命令(通过-d参数，把访问参数放在里面)：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> <span class="string">&quot;http://www.baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget命令：（--post-data参数来实现）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --post-data <span class="string">&#x27;user=foo&amp;password=bar&#x27;</span>  http://server.com/auth.PHP</span></span><br></pre></td></tr></table></figure>

<h2 id="6-B计划"><a href="#6-B计划" class="headerlink" title="6 B计划"></a>6 B计划</h2><h3 id="6-1-用tar归档"><a href="#6-1-用tar归档" class="headerlink" title="6.1 用tar归档"></a>6.1 用tar归档</h3><p>tar支持的参数包括： <code>A</code>、 <code>c</code>、 <code>d</code>、 <code>r</code>、 <code>u</code>、 <code>x</code>、 <code>f</code> 和 <code>v</code> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用tar对文件进行归档：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cf output.tar file1 file2 file3 folder1 ..</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用选项-t列出归档文件中所包含的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tf archive.tar</span></span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要在归档或列出归档文件列表时获知更多的细节信息，可以使用-v或-vv参数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">$ tar -tvf archive.tar</span></span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file1</span><br><span class="line">-rw-rw-r-- shaan/shaan 0 2013-04-08 21:34 file2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向归档文件中添加文件,追加选项-r</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -rvf original.tar new_file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的方法列出归档文件中的内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tf archive.tar</span></span><br><span class="line">hello.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从归档文件中提取文件或文件夹, -x 表示提取</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf archive.tar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用选项-C来指定需要将文件提取到哪个目录：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf archive.tar -C /path/to/extraction_directory</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过将文件名指定为命令行参数来提取特定的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvf file.tar file1 file4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面的命令只提取file1和file4，忽略其他文件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在tar中使用stdin和stdout</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar cvf - files/ | ssh user@example.com <span class="string">&quot;tar xv -C Documents/&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上面的例子中，对files目录中的内容进行了归档并输出到stdout（由<span class="string">&#x27;-&#x27;</span>指明）。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拼接两个归档文件, -A 选项轻松地合并多个tar文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -Af file1.tar file2.tar</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内容，验证操作是否成功：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tvf file1.tar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过检查时间戳来更新归档文件中的内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以用更新选项-u指明：只有比归档文件中的同名文件更新时才会被添加。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tf archive.tar</span></span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅当filea自上次被加入archive.tar后出现了变动才对其进行追加，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -uf archive.tar filea</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果两个filea的时间戳相同，则什么都不会发生。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可用<span class="built_in">touch</span>命令修改文件的时间戳，然后再用tar命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -uvvf archive.tar filea</span></span><br><span class="line">-rw-r--r-- slynux/slynux 0 2010-08-14 17:53 filea</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较归档文件与文件系统中的内容, 选项 -d 可以打印出两者之间的差别：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -<span class="built_in">df</span> archive.tar</span></span><br><span class="line">afile: Mod time differs</span><br><span class="line">afile: Size differs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从归档文件中删除文件, --delete选项从给定的归档文件中删除文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tf archive.tar</span></span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line">filec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除filea：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar --delete --file archive.tar filea</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -tf archive.tar</span></span><br><span class="line">fileb</span><br><span class="line">filec</span><br></pre></td></tr></table></figure>

<p><strong>压缩tar归档文件：</strong></p>
<p>归档文件通常被压缩成下列格式之一： </p>
<ul>
<li>file.tar.gz </li>
<li>file.tar.bz2 </li>
<li>file.tar.lzma</li>
</ul>
<p>不同的tar选项可以用来指定不同的压缩格式： </p>
<ul>
<li>-j 指定bunzip2格式； </li>
<li>-z 指定gzip格式； </li>
<li>–lzma 指定lzma格式。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了让tar支持根据扩展名自动进行压缩，使用 -a或 --auto-compress选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar acvf archive.tar.gz filea fileb filec</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从归档中排除部分文件,  --exclude [PATTERN]排除匹配通配符样式的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cf arch.tar * --exclude <span class="string">&quot;*.txt&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">样式应该使用双引号来引用，避免shell对其进行扩展。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以将需要排除的文件列表放入文件中，同时配合选项 -X：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> list</span></span><br><span class="line">filea</span><br><span class="line">fileb</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cf arch.tar * -X list</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除版本控制目录， 可以使用tar的 --exclude-vcs选项。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar --exclude-vcs -czvvf source_code.tar.gz eye_of_gnome_svn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印总字节数，用–totals就可以在归档完成之后打印出总归档字节数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cf arc.tar * --exclude <span class="string">&quot;*.txt&quot;</span> --totals</span></span><br><span class="line">Total bytes written: 20480 (20KiB, 12MiB/s)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-用cpio归档"><a href="#6-2-用cpio归档" class="headerlink" title="6.2 用cpio归档"></a>6.2 用cpio归档</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file1 file2 file3</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将测试文件按照下面的方法进行归档：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> file1 file2 file3 | cpio -ov &gt; archive.cpio</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出cpio归档文件中的内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpio -it &lt; archive.cpio</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从cpio归档文件中提取文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpio -<span class="built_in">id</span> &lt; archive.cpio</span></span><br></pre></td></tr></table></figure>

<p>对于归档命令： </p>
<ul>
<li>-o 指定了输出； </li>
<li>-v 用来打印归档文件列表。</li>
</ul>
<p>在列出给定cpio归档文件所有内容的命令中： </p>
<ul>
<li>-i 用于指定输入； </li>
<li>-t 表示列出归档文件中的内容。</li>
</ul>
<p>当使用命令进行提取时， -d用来表示提取。 cpio在覆盖文件时不会发出提示。 </p>
<h3 id="6-3-使用gzip压缩数据"><a href="#6-3-使用gzip压缩数据" class="headerlink" title="6.3 使用gzip压缩数据"></a>6.3 使用gzip压缩数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要使用gzip压缩文件，可以使用下面的命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip filename</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">filename.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将gzip文件解压缩的方法如下：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gunzip filename.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出压缩文件的属性信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -l test.txt.gz</span></span><br><span class="line">compressed uncompressed ratio uncompressed_name</span><br><span class="line">35 				6 		-33.3% 	test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gzip命令可以从stdin中读入文件，也可以将压缩文件写出到stdout，选项 -c用来将输出指定到stdout。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file | gzip -c &gt; file.gz</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以指定gzip的压缩级别。用 --fast或 --best选项分别提供最低或最高的压缩比。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩归档文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -czvvf archive.tar.gz [FILES]</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cavvf archive.tar.gz [FILES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项 -a表明从文件扩展名自动推断压缩格式。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，创建一个tar归档文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cvvf archive.tar [FILES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩tar归档文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip archive.tar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zcat——无需解压缩，直接读取gzip格式文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">test.gz</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zcat test.gz</span></span><br><span class="line">A test file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件<span class="built_in">test</span>包含了一行文本<span class="string">&quot;A test file&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">test.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩率</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以指定压缩率，它共有9级，其中：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1级的压缩率最低，但是压缩速度最快；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9级的压缩率最高，但是压缩速度最慢。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -5 test.img</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这应该能在压缩速度和压缩比之间获得一个不错的平衡。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用bzip2，唯一的不同在于bzip2的压缩效率比gzip更高，但花费的时间比gzip更长</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bzip2 filename</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩bzip2格式的文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bunzip2 filename.bz2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成tar.bz2文件并从中提取内容的方法同之前介绍的tar.gz类似：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xjvf archive.tar.bz2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中-j表明该归档文件是bzip2格式。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用lzma</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lzma是另一种压缩工具，它的压缩率甚至比gzip和bzip2更好。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lzma filename</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩lzma文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unlzma filename.lzma</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以使用tar命令的--lzma选项对生成的tar归档文件进行压缩或提取：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cvvf --lzma archive.tar.lzma [FILES]</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cavvf archive.tar.lzma [FILES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要将经过lzma压缩过的tar归档文件中的内容提取到指定的目录中，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvvf --lzma archive.tar.lzma -C extract_directory</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中， -x用于提取内容， --lzma指定使用lzma对归档文件进行解压缩。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们也可以用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xavvf archive.tar.lzma -C extract_directory</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-用-zip-归档和压缩"><a href="#6-4-用-zip-归档和压缩" class="headerlink" title="6.4 用 zip 归档和压缩"></a>6.4 用 zip 归档和压缩</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对归档文件采用ZIP格式进行压缩：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zip file.zip file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对目录和文件进行递归操作, -r 用于指定递归操作：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zip -r archive.zip folder1 folder2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 要从ZIP文件中提取内容，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip file.zip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在完成提取操作之后， unzip并不会删除file.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要更新压缩文件中的内容，使用选项 -u：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zip file.zip -u newfile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从压缩文件中删除内容，则使用-d：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zip -d arc.zip file.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出压缩文件中的内容：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -l archive.zip</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-更快的归档工具-pbzip2"><a href="#6-5-更快的归档工具-pbzip2" class="headerlink" title="6.5 更快的归档工具 pbzip2"></a>6.5 更快的归档工具 pbzip2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩单个文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pbzip2 myfile.tar</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pbzip2会自动检测系统中处理器核心的数量，然后将myfile.tar压缩成myfile.tar.bz2。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要将多个文件或目录进行归档及压缩，可以使用tar配合pbzip2来实现：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -c directory_to_compress/ | pbzip2 -c &gt; myfile.tar.bz2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从pbzip2格式的文件中进行提取。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是tar.bz2文件，我们可以一次性完成解压缩和提取工作：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pbzip2 -dc myfile.tar.bz2 | tar x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是经过pbzip2压缩过的归档文件，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pbzip2 -d myfile.tar.bz2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动指定处理器数量, 使用pbzip2的-p选项来手动指定处理器核心的数量</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pbzip2 -p4 myfile.tar</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面的命令告诉pbzip2使用4个处理器核心。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定压缩比</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">像其他压缩工具一样，我们可以使用从1到9的选项来分别指定最快和最优的压缩比。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-6-创建压缩文件系统"><a href="#6-6-创建压缩文件系统" class="headerlink" title="6.6 创建压缩文件系统"></a>6.6 创建压缩文件系统</h3><p>squashfs是一种具有超高压缩率的只读型文件系统，这种文件系统能够将2GB~3GB的数据压缩成一个700MB的文件。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加源目录和文件，创建一个squashfs文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mksquashfs /etc test.squashfs</span></span><br><span class="line">Parallel mksquashfs: Using 2 processors</span><br><span class="line">Creating 4.0 filesystem on test.squashfs, block size 131072.</span><br><span class="line">[=======================================] 1867/1867 100%</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用环回形式挂载squashfs文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /mnt/squash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -o loop compressedfs.squashfs /mnt/squash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你可以访问/mnt/squashfs访问其中的内容。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在创建squashfs文件时排除部分文件, 选项-e，将需要排除的文件列表以命令行参数的方式来指定。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mksquashfs /etc test.squashfs -e /etc/passwd /etc/shadow</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以将需要排除的文件名列表写入文件，然后用 -ef指定该文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> excludelist</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mksquashfs /etc test.squashfs -ef excludelist</span></span><br></pre></td></tr></table></figure>

<h3 id="6-7-使用-rsync-备份系统快照"><a href="#6-7-使用-rsync-备份系统快照" class="headerlink" title="6.7 使用 rsync 备份系统快照"></a>6.7 使用 rsync 备份系统快照</h3><p>rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。 </p>
<p>rsync也支持压缩、加密等多种特性。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将源目录复制到目的端：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -av /home/slynux/data slynux@192.168.0.6:/home/backups/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中：</span></span><br><span class="line"> -a表示要进行归档；</span><br><span class="line"> -v表示在stdout上打印出细节信息或进度。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数据备份到远程服务器或主机：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -av source_dir username@host:PATH</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的方法将远程主机上的数据恢复到本地主机：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -av username@host:PATH destination</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过网络进行传输时，压缩数据能够明显改善传输效率。我们可以用rsync的选项 -z 指定在网络传输时压缩数据。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -avz <span class="built_in">source</span> destination</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个目录中的内容同步到另一个目录：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -av /home/test/ /home/backups</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这条命令将源目录（/home/test）中的内容（不包括目录本身）复制到现有的backups目录中</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在使用rsync进行归档的过程中排除部分文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude <span class="string">&quot;*.txt&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者我们可以通过一个列表文件指定需要排除的文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这可以利用--exclude-from FILEPATH。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在更新rsync备份时，删除不存在的文件, rsync并不会在目的端删除那些在源端已不存在的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rsync -avz SOURCE DESTINATION --delete</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定期进行备份</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -ev</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加上这么一行：</span></span><br><span class="line">0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面的crontab条目将rsync调度为每10个小时运行一次。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-8-用-fsarchiver-创建全盘镜像"><a href="#6-8-用-fsarchiver-创建全盘镜像" class="headerlink" title="6.8 用 fsarchiver 创建全盘镜像"></a>6.8 用 fsarchiver 创建全盘镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件系统/分区备份。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用fsarchiver的savefs选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsarchiver savefs backup.fsa /dev/sda1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时备份多个分区。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsarchiver savefs backup.fsa /dev/sda1 /dev/sda2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从备份归档中恢复分区。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsarchiver restfs backup.fsa <span class="built_in">id</span>=0,dest=/dev/sda1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">id</span>=0 表 明 我 们 希 望 从 备 份 归 档 中 提 取 第 一 个 分 区 的 内 容 ， 将 其 恢 复 到 由 dest=/dev/sda1所指定的分区中。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从备份归档中恢复多个分区。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">像之前一样，使用restfs选项：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsarchiver restfs backup.fsa <span class="built_in">id</span>=0,dest=/dev/sda1 <span class="built_in">id</span>=1,dest=/dev/sdb1</span></span><br></pre></td></tr></table></figure>

<h2 id="7-无网不利"><a href="#7-无网不利" class="headerlink" title="7 无网不利"></a>7 无网不利</h2><h3 id="7-1-设置网络"><a href="#7-1-设置网络" class="headerlink" title="7.1 设置网络"></a>7.1 设置网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动设置网络接口的IP地址：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig wlan0 192.168.0.80</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用以下命令设置比IP地址的子网掩码：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动配置网络接口</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dhclient eth0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印网络接口列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig | <span class="built_in">cut</span> -c-10 | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">lo</span><br><span class="line">wlan0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示IP地址</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig wlan0 | egrep -o <span class="string">&quot;inet addr:[^ ]*&quot;</span> | grep -o <span class="string">&quot;[0-9.]*&quot;</span></span></span><br><span class="line">192.168.0.82</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">硬件地址（MAC地址）欺骗</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig eth0 hw ether 00:1c:bf:87:25:d5</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">名字服务器与DNS（域名服务）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/resolv.conf</span></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以像下面这样手动添加名字服务器：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DNS查找</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">host google.com</span></span><br><span class="line">google.com has address 64.233.181.105</span><br><span class="line">google.com has address 64.233.181.99</span><br><span class="line">google.com has address 64.233.181.147</span><br><span class="line">google.com has address 64.233.181.106</span><br><span class="line">google.com has address 64.233.181.103</span><br><span class="line">google.com has address 64.233.181.104</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nslookup google.com</span></span><br><span class="line">Server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8#53</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.105</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.99</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.147</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.106</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.103</span><br><span class="line">Name: google.com</span><br><span class="line">Address: 64.233.181.104</span><br><span class="line">Server: 8.8.8.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面最后一行对应着用于DNS解析的默认名字服务器。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不使用DNS服务器，也可以为IP地址解析添加符号名，这只需要向文件 /etc/hosts中加入条目即可。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用下面的方法进行添加：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> IP_ADDRESS symbolic_name &gt;&gt; /etc/hosts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 192.168.0.9 backupserver &gt;&gt; /etc/hosts</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加了条目之后，任何时候解析backupserver，都会返回192.168.0.9。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示路由表信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination 	Gateway 	Genmask 		Flags 	Metric 	Ref 	UseIface</span><br><span class="line">192.168.0.0 	* 			255.255.252.0 	U 		2 		0 		0wlan0</span><br><span class="line">link-local 		* 			255.255.0.0 	U 		1000 	0 		0wlan0</span><br><span class="line">default 		p4.local 	0.0.0.0 		UG 		0 		0 		0wlan0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination 	Gateway 	Genmask 		Flags 	Metric 	Ref 	Use 	Iface</span><br><span class="line">192.168.0.0 	0.0.0.0 	255.255.252.0 	U 		2 		0 		0 		wlan0</span><br><span class="line">169.254.0.0 	0.0.0.0 	255.255.0.0 	U 		1000 	0 		0 		wlan0</span><br><span class="line">0.0.0.0 		192.168.0.4 0.0.0.0 		UG 		0 		0 		0 		wlan0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n指定以数字形式显示地址。如果使用-n， route会以数字形式的IP地址显示每一个条目；否则，如果IP地址具有对应的DNS条目，就会显示符号形式的主机名。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认网关：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route add default gw 192.168.0.1 wlan0</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-traceroute-命令"><a href="#7-2-traceroute-命令" class="headerlink" title="7.2 traceroute 命令"></a>7.2 traceroute 命令</h3><p>traceroute，它可以显示分组途径的所有网关的地址。 traceroute信息可以帮助我们搞明白分组到达目的地需要经过多少跳（hop）。中途的网关或路由器的数量给出了一个测量网络上两个节点之间距离的度量<br>（metric）。 traceroute的输出如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">traceroute google.com</span></span><br><span class="line">traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</span><br><span class="line">1 gw-c6509.lxb.as5577.net (195.26.4.1) 0.313 ms 0.371 ms 0.457 ms</span><br><span class="line">2 40g.lxb-fra.as5577.net (83.243.12.2) 4.684 ms 4.754 ms 4.823 ms</span><br><span class="line">3 de-cix10.net.google.com (80.81.192.108) 5.312 ms 5.348 ms 5.327 ms</span><br><span class="line">4 209.85.255.170 (209.85.255.170) 5.816 ms 5.791 ms 209.85.255.172</span><br><span class="line">(209.85.255.172) 5.678 ms</span><br><span class="line">5 209.85.250.140 (209.85.250.140) 10.126 ms 9.867 ms 10.754 ms</span><br><span class="line">6 64.233.175.246 (64.233.175.246) 12.940 ms 72.14.233.114</span><br><span class="line">(72.14.233.114) 13.736 ms 13.803 ms</span><br><span class="line">7 72.14.239.199 (72.14.239.199) 14.618 ms 209.85.255.166</span><br><span class="line">(209.85.255.166) 12.755 ms 209.85.255.143 (209.85.255.143) 13.803 ms</span><br><span class="line">8 209.85.255.98 (209.85.255.98) 22.625 ms 209.85.255.110</span><br><span class="line">(209.85.255.110) 14.122 ms</span><br><span class="line">*</span><br><span class="line">9 ew-in-f104.1e100.net (74.125.77.104) 13.061 ms 13.256 ms 13.484 ms</span><br></pre></td></tr></table></figure>

<h3 id="7-3-列出网络上所有的活动主机-fping"><a href="#7-3-列出网络上所有的活动主机-fping" class="headerlink" title="7.3 列出网络上所有的活动主机 (fping)"></a>7.3 列出网络上所有的活动主机 (fping)</h3><p>fping的选项如下： </p>
<ul>
<li>选项 -a指定打印出所有活动主机的IP地址； </li>
<li>选项 -u指定打印出所有无法到达的主机； </li>
<li>选项 -g指定从 “IP地址&#x2F;子网掩码”记法或者”IP地址范围”记法中生成一组IP地址；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a 192.160.1/24 -g</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a 192.160.1 192.168.0.255 -g</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以用已有的命令行工具来查询网络上的主机状态：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a 192.160.1/24 -g 2&gt; /dev/null</span></span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.90</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者，使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a 192.168.0.1 192.168.0.255 -g</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;/dev/null将由于主机无法到达所产生的错误信息打印到null设备。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a 192.168.0.1 192.168.0.5 192.168.0.6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将IP地址作为参数传递</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fping -a &lt; ip.list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从文件中传递一组IP地址</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-ssh-命令"><a href="#7-4-ssh-命令" class="headerlink" title="7.4 ssh 命令"></a>7.4 ssh 命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SSH的压缩功能,选项-C启用这一功能：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -C user@hostname COMMANDS</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数据重定向至远程shell命令的stdin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;text&#x27;</span> | ssh user@remote_host <span class="string">&#x27;echo&#x27;</span></span></span><br><span class="line">text</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件中的数据进行重定向</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh user@remote_host <span class="string">&#x27;echo&#x27;</span> &lt; file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在远程主机中执行图形化命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对此，你需要像这样设置变量<span class="variable">$DISPLAY</span>：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh user@host <span class="string">&quot;export DISPLAY=:0 ; command1; command2&quot;</span><span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这将启用远程主机上的图形化输出。如果你想在本地主机上也显示图形化输出，使用SSH的X11转发选项（forwarding option）：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -X user@host <span class="string">&quot;command1; command2</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-通过网络传输文件"><a href="#7-5-通过网络传输文件" class="headerlink" title="7.5 通过网络传输文件"></a>7.5 通过网络传输文件</h3><p>计算机联网的主要目的就是资源共享。在资源共享方面，使用最多的是文件共享。有多种方法可以用来在网络中传输文件。这则攻略就讨论了如何用常见的协议FTP、 SFTP、 RSYNC和SCP传输文件。 </p>
<p>通过FTP传输文件可以使用lftp命令，通过SSH连接传输文件可以使用sftp， RSYNC使用SSH与rsync命令， scp通过SSH进行传输。 </p>
<p><strong>文件传输协议（File Transfer Protocol， FTP） ：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要连接FTP服务器传输文件，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lftp username@ftphost</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它会提示你输入密码，然后显示一个像下面那样的登录提示符：</span></span><br><span class="line">lftp username@ftphost:~&gt;</span><br></pre></td></tr></table></figure>

<p>你可以在提示符后输入命令，如下所示。 </p>
<ul>
<li>用cd directory改变目录。 </li>
<li>用lcd改变本地主机的目录。 </li>
<li>用mkdir创建目录。 </li>
<li>列出远程机器当前目录下的文件使用Is。 </li>
<li>用get filename下载文件：<br><code>lftp username@ftphost:~&gt; get filename </code></li>
<li>用put filename从当前目录上传文件：<br><code>lftp username@ftphost:~&gt; put filename </code></li>
<li>用quit退出lftp会话。</li>
</ul>
<p><strong>FTP自动传输 ：</strong></p>
<p>ftp是另一个可用于FTP文件传输的命令。相比较而言， lftp的用法更灵活。 lftp和ftp为用户启动一个交互式会话（通过显示消息来提示用户输入）。 </p>
<p><strong>SFTP（Secure FTP，安全FTP） ：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/slynux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">put testfile.jpg</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">get serverfile.jpg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行sftp：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sftp user@domainname</span></span><br></pre></td></tr></table></figure>

<p><strong>rsync命令 ：</strong></p>
<p>rsync广泛用于网络文件复制及系统备份。 </p>
<p><strong>SCP（Secure Copy Program，安全复制程序） ：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp filename user@remotehost:/home/path</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp user@remotehost:/home/path/filename filename</span></span><br></pre></td></tr></table></figure>

<p>用SCP进行递归复制 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp -r /home/slynux user@remotehost:/home/backups</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录/home/slynux递归复制到远程主机中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scp的 -p 选项能够在复制文件的同时保留文件的权限和模式。</span></span><br></pre></td></tr></table></figure>

<h3 id="7-6-连接网线网络"><a href="#7-6-连接网线网络" class="headerlink" title="7.6 连接网线网络"></a>7.6 连接网线网络</h3><p>我们需要用ifconfig分配IP地址和子网掩码才能连接上有线网络。对于无线网络来说，还需要其他工具（如iwconfig和iwlist）来配置更多的参数。 </p>
<p>iwlist工具扫描并列出可用的无线网络。用下面的命令进行扫描： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iwlist scan</span></span><br><span class="line">wlan0 		Scan completed :</span><br><span class="line">			Cell 01 - Address: 00:12:17:7B:1C:65</span><br><span class="line">					Channel:11</span><br><span class="line">					Frequency:2.462 GHz (Channel 11)</span><br><span class="line">					Quality=33/70 Signal level=-77 dBm</span><br><span class="line">                    Encryption key:on</span><br><span class="line">					ESSID:&quot;model-2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-在本地挂载点上挂载远程驱动器"><a href="#7-7-在本地挂载点上挂载远程驱动器" class="headerlink" title="7.7 在本地挂载点上挂载远程驱动器"></a>7.7 在本地挂载点上挂载远程驱动器</h3><p>sshfs允许你将远程文件系统挂载到本地挂载点上。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将位于远程主机上的文件系统挂载到本地挂载点上：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sshfs -o allow_other user@remotehost:/home/path /mnt/mountpoint</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成任务后，可用下面的方法卸载：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">umount /mnt/mountpoint</span></span><br></pre></td></tr></table></figure>

<h3 id="7-8-网络流量与端口分析"><a href="#7-8-网络流量与端口分析" class="headerlink" title="7.8 网络流量与端口分析"></a>7.8 网络流量与端口分析</h3><p>列出系统中的开放端口以及运行在端口上的服务的详细信息，可以使用以下命令： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsof -i</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要列出本地主机当前的开放端口，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsof -i | grep <span class="string">&quot;:[0-9]\+-&gt;&quot;</span> -o | grep <span class="string">&quot;[0-9]\+&quot;</span> -o | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span></span><br></pre></td></tr></table></figure>

<p>用netstat查看开放端口与服务 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -tnp列出开放端口与服务：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -tnp</span></span><br></pre></td></tr></table></figure>

<h3 id="7-9-创建套接字"><a href="#7-9-创建套接字" class="headerlink" title="7.9 创建套接字"></a>7.9 创建套接字</h3><p>最简单的方法就是使用netcat命令（或nc）。我们需要两个套接字：一个用来侦听，一个用来连接。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置侦听套接字：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -l 1234</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这会在本地主机的端口1234上创建一个侦听套接字。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接到该套接字：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc HOST 1234</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想发送消息，只需要在执行第2步操作的主机终端中输入信息并按回车键就行了。消息会出现在执行第1步操作的主机终端中。</span></span><br></pre></td></tr></table></figure>

<p>在网络上进行快速文件复制 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在接收端执行下列命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -l 1234 &gt; destination_filename</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在发送端执行下列命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc HOST 1234 &lt; source_filename</span></span><br></pre></td></tr></table></figure>

<h3 id="7-10-iptables防火墙设置"><a href="#7-10-iptables防火墙设置" class="headerlink" title="7.10 iptables防火墙设置"></a>7.10 iptables防火墙设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阻塞发送到特定IP地址的流量：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -A OUTPUT -d 8.8.8.8 -j DROP</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阻塞发送到特定端口的流量：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -A OUTPUT -p tcp -dport 21 -j DROP</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> iptables中的第一个选项-A表明向链（chain）中添加一条新的规则，该规则由后续参数给出。OUTPUT链，它可以对所有出站（outgoing）的流量进行控制。-d指定了所要匹配的分组目的地址。-j来使iptables丢弃（DROP）符合条件的分组。-p指定该规则是适用于TCP， -dport指定了对应的端口。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除对iptables链所做出的所有改动。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables --flush</span></span><br></pre></td></tr></table></figure>

<h2 id="8-当个好管家"><a href="#8-当个好管家" class="headerlink" title="8 当个好管家"></a>8 当个好管家</h2><h3 id="8-1-监视磁盘使用情况"><a href="#8-1-监视磁盘使用情况" class="headerlink" title="8.1 监视磁盘使用情况"></a>8.1 监视磁盘使用情况</h3><p><code>df</code> 是disk free的缩写， <code>du</code> 是disk usage的缩写。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出某个文件（或多个文件）占用的磁盘空间：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> file.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要获得某个目录中所有文件的磁盘使用情况，并在每一行中显示各个文件的磁盘占用详情，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -a DIRECTORY</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以KB、 MB或块（block）为单位显示磁盘使用情况</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -h FILENAME</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示磁盘使用总计, -c 可以输出作为命令参数的所有文件和目录的磁盘使用情况</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -c process_log.shpcpu.sh</span></span><br><span class="line">4 process_log.sh</span><br><span class="line">4 pcpu.sh</span><br><span class="line">8 total</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s（summarize，合计）则只输出合计数据。它可以配合 -h打印出人们易读的格式。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -sh slynux</span></span><br><span class="line">680K slynux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印以字节（默认输出）为单位的文件大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -b FILE(s)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印以KB为单位的文件大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -k FILE(s)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印以MB为单位的文件大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -m FILE(s)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印以指定块为单位的文件大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -B BLOCK_SIZE FILE(s)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从磁盘使用统计中排除部分文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> --exclude <span class="string">&quot;*.txt&quot;</span> FILES(s)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除所有的.txt文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> --exclude-from EXCLUDE.txt DIRECTORY</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EXCLUDE.txt包含了需要排除的文件列表</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--max-depth指定<span class="built_in">du</span>应该遍历的目录层次的最大深度。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> --max-depth 2 DIRECTORY</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出指定目录中最大的10个文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -ak /home/slynux | <span class="built_in">sort</span> -nrk 1 | <span class="built_in">head</span> -n 4</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">du</span> -k &#123;&#125; \; | <span class="built_in">sort</span> -nrk 1 | <span class="built_in">head</span></span></span><br></pre></td></tr></table></figure>

<p>du提供磁盘使用情况信息，而df提供磁盘可用空间信息。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span> -h</span></span><br><span class="line">Filesystem 			Size 	Used 	Avail 	Use% 	Mounted on</span><br><span class="line">/dev/sda1 			9.2G 	2.2G 	6.6G 	25% 	/</span><br><span class="line">none 				497M 	240K 	497M 	1% 		/dev</span><br><span class="line">none 				502M 	168K 	501M 	1% 		/dev/shm</span><br><span class="line">none 				502M 	88K 	501M 	1% 		/var/run</span><br><span class="line">none 				502M 	0 		502M 	0% 		/var/lock</span><br><span class="line">none 				502M 	0 		502M 	0% 		/lib/init/rw</span><br><span class="line">none 				9.2G 	2.2G 	6.6G 	25% 	/var/lib/ureadahead/debugfs</span><br></pre></td></tr></table></figure>

<h3 id="8-2-计算命令执行时间"><a href="#8-2-计算命令执行时间" class="headerlink" title="8.2 计算命令执行时间"></a>8.2 计算命令执行时间</h3><ul>
<li>real: %e </li>
<li>user: %U </li>
<li>sys: %S</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">time COMMAND</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以用选项-o filename将相关的时间统计信息写入文件：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/time -o output.txt COMMAND</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要将命令执行时间添加到文件而不影响其原有内容，使用选项-a以及-o：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/time -a -o output.txt COMMAND</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建格式化输出：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/time -f <span class="string">&quot;Time: %U&quot;</span> -a -o timing.log <span class="built_in">uname</span></span></span><br><span class="line">Linux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用错误重定向操作符（2&gt;）对时间信息重定向。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/time -f <span class="string">&quot;Time: %U&quot;</span> <span class="built_in">uname</span>&gt; command_output.txt 2&gt;time.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> time.log</span></span><br><span class="line">Time: 0.00</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> command_output.txt</span></span><br><span class="line">Linux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用参数%Z显示系统页面大小：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/time -f <span class="string">&quot;Page size: %Z bytes&quot;</span> <span class="built_in">ls</span>&gt; /dev/null</span></span><br><span class="line">Page size: 4096 bytes</span><br></pre></td></tr></table></figure>

<p>三种不同类型的时：</p>
<ul>
<li>Real时间指的是挂钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所花费的时间（例如，为等待I&#x2F;O操作完成所用的时间）。 </li>
<li>User时间是指进程花费在用户模式（内核之外）中的CPU时间。这是唯一真正用于执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。 </li>
<li>Sys时间是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。</li>
</ul>
<p>time命令 一些可以使用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%C</td>
<td>进行计时的命令名称以及命令行参数</td>
</tr>
<tr>
<td>%D</td>
<td>进程非共享数据区域的大小，以KB为单位</td>
</tr>
<tr>
<td>%E</td>
<td>进程使用的real时间（挂钟时间），显示格式为[小时:]分钟:秒</td>
</tr>
<tr>
<td>%x</td>
<td>命令的退出状态</td>
</tr>
<tr>
<td>%k</td>
<td>进程接收到的信号数量</td>
</tr>
<tr>
<td>%W</td>
<td>进程被交换出主存的次数</td>
</tr>
<tr>
<td>%Z</td>
<td>系统的页面大小。这是一个系统常量，但在不同的系统中，这个常量值也不同</td>
</tr>
<tr>
<td>%P</td>
<td>进程所获得的CPU时间百分比。这个值等于user+system时间除以总运行时间。结果以百分比形式显示</td>
</tr>
<tr>
<td>%K</td>
<td>进程的平均总（data+stack+text）内存使用量，以KB为单位</td>
</tr>
<tr>
<td>%w</td>
<td>进程主动进行上下文切换的次数，例如等待I&#x2F;O操作完成</td>
</tr>
<tr>
<td>%c</td>
<td>进程被迫进行上下文切换的次数（由于时间片到期）</td>
</tr>
</tbody></table>
<h3 id="8-3-收集与当前登录用户、启动日志及启动故障的相关信息"><a href="#8-3-收集与当前登录用户、启动日志及启动故障的相关信息" class="headerlink" title="8.3 收集与当前登录用户、启动日志及启动故障的相关信息"></a>8.3 收集与当前登录用户、启动日志及启动故障的相关信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前登录用户的相关信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span></span></span><br><span class="line">slynux 	pts/0 	2010-09-29 05:24 (slynuxs-macbook-pro.local)</span><br><span class="line">slynux 	tty7 	2010-09-29 07:08 (:0)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得有关登录用户更详细的信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">w</span></span><br><span class="line">  07:09:05 up 1:45, 2 users, load average: 0.12, 0.06, 0.02</span><br><span class="line">USER 	TTY 	FROM 	LOGIN@ 	IDLE 	JCPU 	PCPU 	WHAT</span><br><span class="line">slynux 	pts/0 	slynuxs 05:24 	0.00s 	0.65s 	0.11s 	sshd: slynux</span><br><span class="line">slynux 	tty7 	:0		07:08 	1:45m 	3.28s 	0.26s 	gnome-session</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一行列出了当前时间，系统运行时间，当前登录的用户数量以及过去的1分钟、 5分钟、 15分钟内的系统平均负载。接下来的每一行显示了每一个登录用户的详细信息，其中包括登录名、 TTY、远程主机、登录时间、空闲时间、自该用户登录后所使用的总CPU时间、当前运行进程所使用的CPU时间以及进程所对应的命令行。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前登录主机的用户列表：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">users</span></span></span><br><span class="line">slynux slynux slynux hacker</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">users</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span></span><br><span class="line">slynux</span><br><span class="line">hacker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统已经加电运行了多长时间：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line">21:44:33 up 3:17, 8 users, load average: 0.09, 0.14, 0.09</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span> | grep -Po <span class="string">&#x27;\d&#123;2&#125;\:\d&#123;2&#125;\:\d&#123;2&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取上一次启动以及用户登录会话的信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">last</span></span><br><span class="line">slynux tty7 :0 Tue Sep 28 18:27 still logged in</span><br><span class="line">reboot system boot 2.6.32-21-generic Tue Sep 28 18:10 - 21:46 (03:35)</span><br><span class="line">slynux pts/0 :0.0 Tue Sep 28 05:31 - crash (12:39)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">last命令可以提供登录会话信息。它实际上是一个系统登录日志，包括了登录<span class="built_in">tty</span>、登录时间、状态等信息。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">last命令以日志文件/var/log/wtmp作为输入日志数据。它也可以用选项-f明确地指定日志文件。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">last -f /var/log/wtmp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取单个用户登录会话的信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">last USER</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取重启会话（reboot session）信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">last reboot</span></span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 18:10 - 21:48 (03:37)</span><br><span class="line">reboot system boot 2.6.32-21-generi Tue Sep 28 05:14 - 21:48 (16:33)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取失败的用户登录会话信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lastb</span></span><br><span class="line">test tty8 :0 Wed Dec 15 03:56 - 03:56 (00:00)</span><br><span class="line">slynux tty8 :0 Wed Dec 15 03:55 - 03:55 (00:00)</span><br></pre></td></tr></table></figure>

<h3 id="8-4-使用-watch-监视命令输出"><a href="#8-4-使用-watch-监视命令输出" class="headerlink" title="8.4 使用 watch 监视命令输出"></a>8.4 使用 watch 监视命令输出</h3><p>watch命令可以用来在终端中以固定的间隔监视命令输出。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch <span class="string">&#x27;ls -l | grep &quot;^d&quot;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只列出目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令默认每2秒更新一次输出。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n SECOND指定更新输出的时间间隔。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch -n 5 <span class="string">&#x27;ls -l&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以5秒为间隔，监视<span class="built_in">ls</span> -l的输出</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">突出标示watch输出中的差异, -d 可以启用这一功能：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch -d <span class="string">&#x27;COMMANDS&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-用-logrotate-管理日志文件"><a href="#8-5-用-logrotate-管理日志文件" class="headerlink" title="8.5 用 logrotate 管理日志文件"></a>8.5 用 logrotate 管理日志文件</h3><p>用一种被称为轮替（rotation）的技术来限制日志文件的体积，一旦它超过了限定的大小，就对其内容进行抽取（strip），同时将 日志文件中的旧条目存储到日志目录中的归档文件内。旧的日志文件就会得以保存以便随后参阅。 </p>
<p><code>logrotate</code> 的配置目录位于&#x2F;etc&#x2F;logrotate.d。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/logrotate.d/program</span></span><br><span class="line">/var/log/program.log &#123;</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">size 30k</span><br><span class="line">compress</span><br><span class="line">weekly</span><br><span class="line">rotate 5</span><br><span class="line">create 0600 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中各个参数的含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>missingok</td>
<td>如果日志文件丢失，则忽略；然后返回（不对日志文件进行轮替）</td>
</tr>
<tr>
<td>notifempty</td>
<td>仅当源日志文件非空时才对其进行轮替</td>
</tr>
<tr>
<td>size 30k</td>
<td>限制实施轮替的日志文件的大小。可以用1M表示1MB</td>
</tr>
<tr>
<td>compress</td>
<td>允许用gzip压缩较旧的日志</td>
</tr>
<tr>
<td>weekly</td>
<td>指定进行轮替的时间间隔。可以是weekly、 yearly或daily</td>
</tr>
<tr>
<td>rotate 5</td>
<td>这是需要保留的旧日志文件的归档数量。在这里指定的是5，所以这些文件名将会是program.log.1.gz、 program.log.2.gz等直到program.log.5.gz</td>
</tr>
<tr>
<td>create 0600 root root</td>
<td>指定所要创建的归档文件的模式、用户以及用户组</td>
</tr>
</tbody></table>
<h3 id="8-6-用-syslog-记录日志"><a href="#8-6-用-syslog-记录日志" class="headerlink" title="8.6 用 syslog 记录日志"></a>8.6 用 syslog 记录日志</h3><p>每一个标准应用进程都可以利用syslog记录日志信息。 </p>
<p>使用命令logger通过syslogd记录日志。 </p>
<p>Linux中一些重要的日志文件 ：</p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;boot.log</td>
<td>系统启动信息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;httpd</td>
<td>Apache Web服务器日志</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;messages</td>
<td>发布内核启动信息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;auth.log</td>
<td>用户认证日志</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;dmesg</td>
<td>系统启动信息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mail.log</td>
<td>邮件服务器日志</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;Xorg.0.log</td>
<td>X服务器日志</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向系统日志文件/var/log/message中写入日志信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logger This is a <span class="built_in">test</span> <span class="built_in">log</span> line</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n 1 /var/log/messages</span></span><br><span class="line">Sep 29 07:47:44 slynux-laptop slynux: This is a test log line</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要记录特定的标记（tag），可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logger -t TAG This is a message</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n 1 /var/log/messages</span></span><br><span class="line">Sep 29 07:48:42 slynux-laptop TAG: This is a message</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是当logger发送消息时，它用标记字符串来确定应该记录到哪一个日志文件中。 syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。你可以从/etc/rsyslog.d/目录下的配置文件中看到标记字符串以及与其相关联的日志文件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要将另一个日志文件的最后一行记录到系统日志中，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logger -f /var/log/source.log</span></span><br></pre></td></tr></table></figure>

<h3 id="8-7-通过监视用户登录找出入侵者"><a href="#8-7-通过监视用户登录找出入侵者" class="headerlink" title="8.7 通过监视用户登录找出入侵者"></a>8.7 通过监视用户登录找出入侵者</h3><p>入侵者定义为：屡次试图登入系统达两分钟以上，并且期间的登录过程全部失败。凡是这类用户都应该被检测出来并生成包含以下细节信息的报告： </p>
<ul>
<li>试图登录的账户 </li>
<li>试图登录的次数 </li>
<li>攻击者的IP地址 </li>
<li>IP地址所对应的主机 </li>
<li>进行登录的时间段</li>
</ul>
<p>为了处理SSH登录失败的情况，还得知道用户认证会话日志会被记录在日志文件&#x2F;var&#x2F;log&#x2F;auth.log中。脚本需要扫描这个日志文件来检测出失败的登录信息，执行各种检查来获取所需要的数据。我们可以用host命令找出IP地址所对应的主机。 </p>
<h3 id="8-8-监视磁盘活动"><a href="#8-8-监视磁盘活动" class="headerlink" title="8.8 监视磁盘活动"></a>8.8 监视磁盘活动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式监视, iotop的-o选项只显示出那些正在进行I/O活动的进程：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iotop -o</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于shell脚本的非交互式用法：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iotop -b -n 2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监视特定进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iotop -p PID</span></span><br></pre></td></tr></table></figure>

<h3 id="8-9-检查磁盘及文件系统错误"><a href="#8-9-检查磁盘及文件系统错误" class="headerlink" title="8.9 检查磁盘及文件系统错误"></a>8.9 检查磁盘及文件系统错误</h3><p>使用fsck的各种选项对文件系统错误进行检查和修复。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要检查分区或文件系统的错误，只需要将路径作为fsck的参数：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsck /dev/sdb3</span></span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">e2fsck 1.42.5 (29-Jul-2012)</span><br><span class="line">HDD2 has been mounted 26 times without being checked, check forced.</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">HDD2: 75540/16138240 files (0.7% non-contiguous), 48756390/64529088 blocks</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查/etc/fstab中所配置的所有文件系统：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsck -A</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令会依次检查/etc/fstab中列出的文件系统。 fstab文件对磁盘及其挂载点之间的映射关系进行了配置，以便于更便捷地挂载文件系统</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定fsck自动修复错误，无需询问是否进行修复：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsck -a /dev/sda2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟fsck要执行的操作：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fsck -AN</span></span><br><span class="line">fsck from util-linux 2.20.1</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /] fsck.ext4 /dev/sda8</span><br><span class="line">[/sbin/fsck.ext4 (1) -- /home] fsck.ext4 /dev/sda7</span><br><span class="line">[/sbin/fsck.ext3 (1) -- /media/Data] fsck.ext3 /dev/sda6</span><br></pre></td></tr></table></figure>

<h2 id="9-管理重任"><a href="#9-管理重任" class="headerlink" title="9 管理重任"></a>9 管理重任</h2><h3 id="9-1-收集进程信息"><a href="#9-1-收集进程信息" class="headerlink" title="9.1 收集进程信息"></a>9.1 收集进程信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了包含更多的信息，可以使用-f（表示full）来显示多列，如下所示：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -f</span></span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash</span><br><span class="line">slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用选项 -e（every）。选项-ax（all）也可以生成同样的输出。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行如下命令之一： ps –e， ps –ef， ps -ax或ps –axf。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -e | <span class="built_in">head</span></span></span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1 ? 00:00:00 init</span><br><span class="line">2 ? 00:00:00 kthreadd</span><br><span class="line">3 ? 00:00:00 migration/0</span><br><span class="line">4 ? 00:00:00 ksoftirqd/0</span><br><span class="line">5 ? 00:00:00 watchdog/0</span><br><span class="line">6 ? 00:00:00 events/0</span><br><span class="line">7 ? 00:00:00 cpuset</span><br><span class="line">8 ? 00:00:00 khelper</span><br><span class="line">9 ? 00:00:00 netns</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用 -o 来指定想要显示的列，以便只打印出我们需要的内容。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-o 的参数以逗号操作符（,）作为定界符。值得注意的是，逗号操作符与它分隔的参数之间是没有空格的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例如下，其中<span class="built_in">comm</span>表示COMMAND， pcpu表示CPU占用率：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -eo <span class="built_in">comm</span>,pcpu | <span class="built_in">head</span></span></span><br><span class="line">COMMAND %CPU</span><br><span class="line">init 0.0</span><br><span class="line">kthreadd 0.0</span><br><span class="line">migration/0 0.0</span><br><span class="line">ksoftirqd/0 0.0</span><br><span class="line">watchdog/0 0.0</span><br><span class="line">events/0 0.0</span><br><span class="line">cpuset 0.0</span><br><span class="line">khelper 0.0</span><br><span class="line">netns 0.0</span><br></pre></td></tr></table></figure>

<p>选项-o可以使用不同的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pcpu</td>
<td>CPU占用率</td>
</tr>
<tr>
<td>pid</td>
<td>进程ID</td>
</tr>
<tr>
<td>ppid</td>
<td>父进程ID</td>
</tr>
<tr>
<td>pmem</td>
<td>内存使用率</td>
</tr>
<tr>
<td>comm</td>
<td>可执行文件名</td>
</tr>
<tr>
<td>cmd</td>
<td>简单命令</td>
</tr>
<tr>
<td>user</td>
<td>启动进程的用户</td>
</tr>
<tr>
<td>nice</td>
<td>优先级</td>
</tr>
<tr>
<td>time</td>
<td>累计的CPU时间</td>
</tr>
<tr>
<td>etime</td>
<td>进程启动后流逝的时间</td>
</tr>
<tr>
<td>tty</td>
<td>所关联的TTY设备</td>
</tr>
<tr>
<td>euid</td>
<td>有效用户ID</td>
</tr>
<tr>
<td>stat</td>
<td>进程状态</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">top, 默认会输出一个占用CPU最多的进程列表。输出结果每隔几秒就会更新。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">top</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据参数对ps输出进行排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -eo <span class="built_in">comm</span>,pcpu --<span class="built_in">sort</span> -pcpu | <span class="built_in">head</span></span></span><br><span class="line">COMMAND 			%CPU</span><br><span class="line">Xorg 				0.1</span><br><span class="line">hald-addon-stor 	0.0</span><br><span class="line">ata/0 				0.0</span><br><span class="line">scsi_eh_0 			0.0</span><br><span class="line">gnome-settings- 	0.0</span><br><span class="line">init 				0.0</span><br><span class="line">hald 				0.0</span><br><span class="line">pulseaudio 			0.0</span><br><span class="line">gdm-simple-gree 	0.0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -eo <span class="built_in">comm</span>,pid,pcpu,pmem | grep bash</span></span><br><span class="line">bash 		1255 	0.0 	0.3</span><br><span class="line">bash 		1680 	5.5 	0.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出给定命令名所对应的进程ID，在参数后加上=就可以移除列名。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -C bash -o pid=</span></span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pgrep bash</span></span><br><span class="line">1255</span><br><span class="line">1680</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不使用换行符作为定界符，而是要自行指定可以像下面这样：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pgrep bash -d <span class="string">&quot;:&quot;</span></span></span><br><span class="line">1255:1680</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定进程的用户（拥有者）列表：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pgrep -u root,slynux COMMAND</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据真实用户或ID以及有效用户或ID过滤ps输出</span></span><br><span class="line"> 用 -u EUSER1,EUSER2 …，指定有效用户列表；</span><br><span class="line"> 用 -U RUSER1,RUSER2 …，指定真实用户列表</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -u root -U root -o user,pcpu</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用TTY过滤ps输出, 可以通过指定进程所属的TTY选择ps的输出。用选项 -t指定TTY列表：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -t pts/0,pts/1</span></span><br><span class="line">PID TTY TIME CMD</span><br><span class="line">1238 pts/0 00:00:00 bash</span><br><span class="line">1835 pts/1 00:00:00 bash</span><br><span class="line">1864 pts/0 00:00:00 ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进程线程的相关信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常与进程线程相关的信息在ps输出中是看不到的。我们可以用选项 –L 在ps输出中显示线程的相关信息。这会显示出两列： NLWP和NLP。 NLWP是进程的线程数量， NLP是ps输出中每个条目的线程ID。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -eLf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定输出宽度以及所要显示的列</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以按照你自己的使用方式来进行应用。尝试以下选项:</span></span><br><span class="line"> -f ps –ef</span><br><span class="line"> u ps -e u</span><br><span class="line"> ps ps -e w（w表示宽松输出）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示进程的环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">了解某个进程依赖哪些环境变量，这类信息我们通常都用得着。进程的运行方式可能极其依赖某组环境变量。我们可以利用环境变量调试并修复与进程相关的问题。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -eo pid,cmd e | <span class="built_in">tail</span> -n 3</span></span><br><span class="line">1162 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">1172 sshd: slynux [priv]</span><br><span class="line">1237 sshd: slynux@pts/0</span><br><span class="line">1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</span><br><span class="line">MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22</span><br><span class="line">SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 TERM=xterm-color</span><br><span class="line">LANG=en_IN XDG_SESSION_COOKIE=d1e96f5cc8a7a3bc3a0a73e44c95121a-1286499339.</span><br><span class="line">592429-1573657095</span><br></pre></td></tr></table></figure>

<h3 id="9-2-which、-whereis、-file、-whatis与平均负载"><a href="#9-2-which、-whereis、-file、-whatis与平均负载" class="headerlink" title="9.2 which、 whereis、 file、 whatis与平均负载"></a>9.2 which、 whereis、 file、 whatis与平均负载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">which</span>, <span class="built_in">which</span>命令用来找出某个命令的位置。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> <span class="built_in">ls</span></span></span><br><span class="line">/bin/ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">whereis</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">whereis与<span class="built_in">which</span>命令类似，但它不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径（如果有的话）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis <span class="built_in">ls</span></span></span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file FILENAME</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令会打印出与该文件类型相关的细节信息。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked</span><br><span class="line">(uses shared libs), for GNU/Linux 2.6.15, stripped</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">whatis, whatis命令会输出作为参数的命令的简短描述信息。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whatis <span class="built_in">ls</span></span></span><br><span class="line">ls (1) 			- list directory contents</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">平均负载</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line">12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure>

<h3 id="9-3-杀死进程以及发送或响应信号"><a href="#9-3-杀死进程以及发送或响应信号" class="headerlink" title="9.3 杀死进程以及发送或响应信号"></a>9.3 杀死进程以及发送或响应信号</h3><p>信号是Linux中的一种进程间通信机制。 当进程接收到一个信号时，它会通过执行对应的信号处理程序（signal handler）来进行响应。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用的信号：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终止进程：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> PROCESS_ID_LIST</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">kill</span>命令默认发出一个TERM信号。进程ID列表使用空格作为进程ID之间的定界符。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要通过<span class="built_in">kill</span>命令向进程发送指定的信号，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -s SIGNAL PID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数SIGNAL要么是信号名称，要么是信号编号。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们经常要强行杀死进程，可以使用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -s SIGKILL PROCESS_ID</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -9 PROCESS_ID</span></span><br></pre></td></tr></table></figure>

<p>常用到的信号量：</p>
<ul>
<li>SIGHUP 1——对控制进程或终端的终结进行挂起检测（hangup detection）</li>
<li>SIGINT 2——当按下Ctrl + C时发送该信号 </li>
<li>SIGKILL 9——用于强行杀死进程 </li>
<li>SIGTERM 15——默认用于终止进程 </li>
<li>SIGTSTP 20——当按下Ctrl + Z时发送该信号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">killall命令通过命令名终止进程：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">killall process_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过名称向进程发送信号：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">killall -s SIGNAL process_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过名称强行杀死进程：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">killall -9 process_name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pkill命令和<span class="built_in">kill</span>命令类似，不过默认情况下pkill接受的是进程名，而非进程ID。例如：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pkill process_name</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pkill -s SIGNAL process_name</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pkill不支持信号名称。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">捕捉并响应信号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">trap</span>命令在脚本中用来为信号分配信号处理程序。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">trap</span> <span class="string">&#x27;signal_handler_function_name&#x27;</span> SIGNAL LIST</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-向用户终端发送消息"><a href="#9-4-向用户终端发送消息" class="headerlink" title="9.4 向用户终端发送消息"></a>9.4 向用户终端发送消息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wall命令用来向当前所有登录用户的终端写入消息。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> message | wall</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wall&lt; message</span></span><br><span class="line">Broadcast Message from slynux@slynux-laptop</span><br><span class="line">(/dev/pts/1) at 12:54 ...</span><br><span class="line">This is a messag</span><br></pre></td></tr></table></figure>

<h3 id="9-5-采集系统信息"><a href="#9-5-采集系统信息" class="headerlink" title="9.5 采集系统信息"></a>9.5 采集系统信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印当前系统的主机名：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -n</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印Linux内核版本、硬件架构等详细信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印内核发行版本：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -r</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印主机类型：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印CPU相关信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/cpuinfo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取处理器名称：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/cpuinfo | sed -n 5p</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印内存的详细信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/meminfo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印系统可用内存总量：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/meminfo | <span class="built_in">head</span> -1</span></span><br><span class="line">MemTotal: 1026096 kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出系统的分区信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/partitions</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fdisk -l <span class="comment">#如果没有输出，切换到root用户执行该命令</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取系统的详细信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lshw <span class="comment">#建议以root用户来执行</span></span></span><br></pre></td></tr></table></figure>

<h3 id="9-6-使用-proc-采集信息"><a href="#9-6-使用-proc-采集信息" class="headerlink" title="9.6 使用 proc 采集信息"></a>9.6 使用 proc 采集信息</h3><p>以Bash为例，它的进程ID是4295（pgrep bash），那么就会有一个对应的目录&#x2F;proc&#x2F;4295。进程对应的目录中包含了大量有关进程的信息。 &#x2F;proc&#x2F;PID中一些重要的文件如下所示。 </p>
<ul>
<li><p>environ：包含与进程相关的环境变量。使用cat &#x2F;proc&#x2F;4295&#x2F;environ，可以显示所有传递给该进程的环境变量 </p>
</li>
<li><p>cwd： 是一个到进程工作目录（working directory）的符号链接 </p>
</li>
<li><p>exe：是一个到当前进程所对应的可执行文件的符号链接 </p>
<p>$ readlink &#x2F;proc&#x2F;4295&#x2F;exe<br>&#x2F;bin&#x2F;bash</p>
</li>
<li><p>fd：包含了进程所使用的文件描述符</p>
</li>
</ul>
<h3 id="9-7-用-cron-进行调度"><a href="#9-7-用-cron-进行调度" class="headerlink" title="9.7 用 cron 进行调度"></a>9.7 用 cron 进行调度</h3><p><strong>crontab任务配置基本格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  			*　 			*　 			*　 		  *　　					command</span><br><span class="line">分钟(0-59)　小时(0-23)　	日期(1-31)　 月份(1-12)　星期(0-6,0代表星期天)　  命令</span><br></pre></td></tr></table></figure>

<p>cron表中的每一个条目都由6部分组成，并按照下列顺序排列： </p>
<ul>
<li>分钟（0～59） </li>
<li>小时（0～23） </li>
<li>天（1～31） </li>
<li>月份（1～12） </li>
<li>工作日（0～6） </li>
<li>命令（在指定时间执行的脚本或命令）</li>
</ul>
<p>星号（*）指定命令应该在每个时间段执行。 </p>
<p>除了数字还有几个个特殊的符号就是 <code>&quot;*&quot;</code> 、<code>&quot;/&quot;</code> 和 <code>&quot;-&quot;</code> 、<code>&quot;,&quot;</code> ，<code>*</code> 代表所有的取值范围内的数字，<code>&quot;/&quot;</code> 代表每的意思, <code>&quot;*/5&quot;</code> 表示每5个单位，<code>&quot;-&quot;</code> 代表从某个数字到某个数字, <code>&quot;,&quot;</code> 分开几个离散的数字。以下举几个例子说明问题： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定每小时的第5分钟执行一次<span class="built_in">ls</span>命令</span></span><br><span class="line">5 * * * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定每天的 5:30 执行<span class="built_in">ls</span>命令</span></span><br><span class="line">30 5 * * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定每月8号的7：30分执行<span class="built_in">ls</span>命令</span></span><br><span class="line">30 7 8 * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定每年的6月8日5：30执行<span class="built_in">ls</span>命令</span></span><br><span class="line">30 5 8 6 * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定每星期日的6:30执行<span class="built_in">ls</span>命令 [ 注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。 ]</span></span><br><span class="line">30 6 * * 0 ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每月10号及20号的3：30执行<span class="built_in">ls</span>命令 [注：“，”用来连接多个不连续的时段 ]</span></span><br><span class="line">30 3 10,20 * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天8-11点的第25分钟执行<span class="built_in">ls</span>命令 [注：“-”用来连接连续的时段 ]</span></span><br><span class="line">25 8-11 * * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每15分钟执行一次<span class="built_in">ls</span>命令 [即每个小时的第0 15 30 45 60分钟执行<span class="built_in">ls</span>命令 ]</span></span><br><span class="line">*/15 * * * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每个月中，每隔10天6:30执行一次<span class="built_in">ls</span>命令[即每月的1、11、21、31日是的6：30执行一次<span class="built_in">ls</span>命令。 ]</span></span><br><span class="line">30 6 */10 * * ls </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件</span></span><br><span class="line">50 7 * * * root run-parts /etc/cron.daily   # [ 注：run-parts参数表示，执行后面目录中的所有可执行文件。 ]</span><br></pre></td></tr></table></figure>

<p><strong>配置用户定时任务的语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab [-u user]file</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -u user[-i]</span></span><br></pre></td></tr></table></figure>

<p>参数与说明：</p>
<ul>
<li>crontab -u		&#x2F;&#x2F;设定某个用户的cron服务</li>
<li>crontab -l        &#x2F;&#x2F;列出某个用户cron服务的详细内容</li>
<li>crontab -r              &#x2F;&#x2F;删除没个用户的cron服务</li>
<li>crontab -e             &#x2F;&#x2F;编辑某个用户的cron服务</li>
</ul>
<h3 id="9-8-从终端截图"><a href="#9-8-从终端截图" class="headerlink" title="9.8 从终端截图"></a>9.8 从终端截图</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取整个屏幕：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">import -window root screenshot.png</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动选择部分区域进行抓取：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">import screenshot.png</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取特定窗口：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">import -window window_id screenshot.png</span></span><br></pre></td></tr></table></figure>

    </div><div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------------- 💖 🌞 本 文 结 束 😚 感 谢 您 的 阅 读 🌞 💖 -------------</div>
    
</div>


    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Mr.Miaow 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Mr.Miaow 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Mr.Miaow
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://miaopei.github.io/2017/05/15/Shell/Shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E7%AC%94%E8%AE%B0/" title="Shell脚本攻略笔记">http://miaopei.github.io/2017/05/15/Shell/Shell脚本攻略笔记/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/shell/" rel="tag"><i class="fa fa-tag"></i> shell</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/04/13/Other/Linux%E5%91%BD%E4%BB%A4eval%E7%9A%84%E7%94%A8%E6%B3%95/" rel="prev" title="Linux命令eval的用法">
                  <i class="fa fa-angle-left"></i> Linux命令eval的用法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/05/15/Other/%E5%AE%9A%E5%88%B6%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/" rel="next" title="定制支持串口安装的ubuntu系统镜像">
                  定制支持串口安装的ubuntu系统镜像 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mr.Miaow</span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">956k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:29</span>
  </span>
</div> <div>
   <span id="sitetime"></span>
   <span id="year" style="display:none">2016</span> 
   <span id="month" style="display:none">12</span>   
   <span id="day" style="display:none">23</span>   
   <span id="hour" style="display:none">15</span>   
   <span id="minute" style="display:none">0</span>   
   <span id="second" style="display:none">0</span>   
	<script language=javascript>
	function siteTime(){        
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
	    var year = document.getElementById("year").innerHTML;
		var month = document.getElementById("month").innerHTML;
		var day = document.getElementById("day").innerHTML;
		var hour = document.getElementById("hour").innerHTML;
		var minute = document.getElementById("minute").innerHTML;
		var second = document.getElementById("second").innerHTML;
		var t1 = Date.UTC(year,month,day,hour,minute,second); 
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		if(diffYears==0){
		document.getElementById("sitetime").innerHTML=" 网站已运行 "/*+diffYears+" 年 "*/+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		} else{
		document.getElementById("sitetime").innerHTML=" 网站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		}
	}
	siteTime();
	</script>
</div>

<div class="busuanzi-count">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"miaopei","repo":"miaopei.github.io","client_id":"Ov23li804qbeklf03KFv","client_secret":"fce69a6b68a24543006d90b37dbe835082db6f23","admin_user":"miaopei","distraction_free_mode":true,"language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"adf548d1ce60a1feabe3f9a5f3ad4e9d"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
