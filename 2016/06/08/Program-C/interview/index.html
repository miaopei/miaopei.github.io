<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="icon" type="image/png" sizes="32x32" href="/images/mrmiaow-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/mrmiaow-16.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"miaopei.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"show_result":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C&#x2F;C++ 面试知识总结C&#x2F;C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。 勘误新增请 Issue、PR，建议、讨论请 #issues&#x2F;12，排版使用 中文文案排版指北 使用建议：  Ctrl + F：快速查找定位知识点 TOC 导航：jawil&#x2F;GayHub 插件快速目录跳转">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview C C++">
<meta property="og:url" content="http://miaopei.github.io/2016/06/08/Program-C/interview/index.html">
<meta property="og:site_name" content="Mr.Miaow Blog">
<meta property="og:description" content="C&#x2F;C++ 面试知识总结C&#x2F;C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。 勘误新增请 Issue、PR，建议、讨论请 #issues&#x2F;12，排版使用 中文文案排版指北 使用建议：  Ctrl + F：快速查找定位知识点 TOC 导航：jawil&#x2F;GayHub 插件快速目录跳转">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/GoogleCppStyleGuide.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/SqStack.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/SqQueue.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/SqLoopStack.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/SqList.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/LinkQueue.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/LinkList.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/DuLinkList.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/CirLinkList.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/HashTable.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/GeneralizedList1.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/GeneralizedList2.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/SqBinaryTree.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/LinkBinaryTree.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/Self-balancingBinarySearchTree.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/l6UyF.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/400px-Octree2.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/CPU-Big-Endian.svg.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/CPU-Little-Endian.svg.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E9%A6%96%E9%83%A8.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/UDP%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/UDP%E9%A6%96%E9%83%A8.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/201012122157467258.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/201012122157487616.png">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6-01.gif">
<meta property="og:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6-02.gif">
<meta property="article:published_time" content="2016-06-08T02:14:50.000Z">
<meta property="article:modified_time" content="2024-06-17T07:15:09.292Z">
<meta property="article:author" content="Mr.Miaow">
<meta property="article:tag" content="c&#x2F;c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://miaopei.github.io/2016/06/08/Program-C/interview/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png">


<link rel="canonical" href="http://miaopei.github.io/2016/06/08/Program-C/interview/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://miaopei.github.io/2016/06/08/Program-C/interview/","path":"2016/06/08/Program-C/interview/","title":"Interview C C++"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Interview C C++ | Mr.Miaow Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Mr.Miaow Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Mr.Miaow Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Do what you say, say what you do.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-messages"><a href="/messages/" rel="section"><i class="fa fa-comment fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-C-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="nav-text">C&#x2F;C++ 面试知识总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C-C"><span class="nav-text">1. C&#x2F;C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-const"><span class="nav-text">1.1 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-static"><span class="nav-text">1.2 static</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%BD%9C%E7%94%A8"><span class="nav-text">1.2.1 作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-this-%E6%8C%87%E9%92%88"><span class="nav-text">1.3 this 指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">1.4 inline 内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E7%89%B9%E5%BE%81"><span class="nav-text">1.4.1 特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E4%BD%BF%E7%94%A8"><span class="nav-text">1.4.2 使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9-inline-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.4.3 编译器对 inline 函数的处理步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">1.4.4 优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88virtual%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89%E5%90%97%EF%BC%9F"><span class="nav-text">1.4.5 虚函数（virtual）可以是内联函数（inline）吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-assert"><span class="nav-text">1.5 assert()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-sizeof"><span class="nav-text">1.6 sizeof()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-pragma-pack-n"><span class="nav-text">1.7 #pragma pack(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E4%BD%8D%E5%9F%9F"><span class="nav-text">1.8 位域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-volatile"><span class="nav-text">1.9 volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-extern-%E2%80%9CC%E2%80%9D"><span class="nav-text">1.10 extern “C”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-struct-%E5%92%8C-typedef-struct"><span class="nav-text">1.11 struct 和 typedef struct</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-1-C-%E4%B8%AD"><span class="nav-text">1.11.1 C 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-2-C-%E4%B8%AD"><span class="nav-text">1.11.2 C++ 中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-C-%E4%B8%AD-struct-%E5%92%8C-class"><span class="nav-text">1.12 C++ 中 struct 和 class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-1-%E5%8C%BA%E5%88%AB"><span class="nav-text">1.12.1 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-union-%E8%81%94%E5%90%88"><span class="nav-text">1.13 union 联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-C-%E5%AE%9E%E7%8E%B0-C-%E7%B1%BB"><span class="nav-text">1.14 C 实现 C++ 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-explicit%EF%BC%88%E6%98%BE%E5%BC%8F%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1.15 explicit（显式）构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-friend-%E5%8F%8B%E5%85%83%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">1.16 friend 友元类和友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-using"><span class="nav-text">1.17 using</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-17-1-using-%E5%A3%B0%E6%98%8E"><span class="nav-text">1.17.1 using 声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-17-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-using-%E5%A3%B0%E6%98%8E%E3%80%90C-11%E3%80%91"><span class="nav-text">1.17.2 构造函数的 using 声明【C++11】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-17-3-using-%E6%8C%87%E7%A4%BA"><span class="nav-text">1.17.3 using 指示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-17-4-%E5%B0%BD%E9%87%8F%E5%B0%91%E4%BD%BF%E7%94%A8-using-%E6%8C%87%E7%A4%BA-%E6%B1%A1%E6%9F%93%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">1.17.4 尽量少使用 using 指示 污染命名空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-18-%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">1.18 :: 范围解析运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-18-1-%E5%88%86%E7%B1%BB"><span class="nav-text">1.18.1 分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-19-enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.19 enum 枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-19-1-%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.19.1 限定作用域的枚举类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-19-2-%E4%B8%8D%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.19.2 不限定作用域的枚举类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-20-decltype"><span class="nav-text">1.20 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-21-%E5%BC%95%E7%94%A8"><span class="nav-text">1.21 引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-21-1-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">1.21.1 左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-21-2-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">1.21.2 右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-21-3-%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="nav-text">1.21.3 引用折叠</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-22-%E5%AE%8F"><span class="nav-text">1.22 宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-23-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text">1.23 成员初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-24-initializer-list-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90C-11%E3%80%91"><span class="nav-text">1.24 initializer_list 列表初始化【C++11】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-25-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.25 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-26-%E5%B0%81%E8%A3%85"><span class="nav-text">1.26 封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-27-%E7%BB%A7%E6%89%BF"><span class="nav-text">1.27 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-28-%E5%A4%9A%E6%80%81"><span class="nav-text">1.28 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-28-1-%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E6%97%A9%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="nav-text">1.28.1 静态多态（早绑定）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-28-2-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E6%99%9A%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="nav-text">1.28.2 动态多态（晚绑定）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-29-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">1.29 虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-30-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1.30 纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-31-%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1.31 虚函数、纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-32-%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-text">1.32 虚函数指针、虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-33-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">1.33 虚继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-34-%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1.34 虚继承、虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-35-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1.35 模板类、成员模板、虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-36-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E3%80%81%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">1.36 抽象类、接口类、聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-37-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-text">1.37 内存分配和管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-37-1-malloc%E3%80%81calloc%E3%80%81realloc%E3%80%81alloca"><span class="nav-text">1.37.1 malloc、calloc、realloc、alloca</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-37-2-malloc%E3%80%81free"><span class="nav-text">1.37.2 malloc、free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-37-3-new%E3%80%81delete"><span class="nav-text">1.37.3 new、delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-37-4-%E5%AE%9A%E4%BD%8D-new"><span class="nav-text">1.37.4 定位 new</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-38-delete-this-%E5%90%88%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-text">1.38 delete this 合法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-39-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%88%E6%A0%88%E4%B8%8A%EF%BC%89%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="nav-text">1.39 如何定义一个只能在堆上（栈上）生成对象的类？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-39-1-%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A"><span class="nav-text">1.39.1 只能在堆上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-39-2-%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A"><span class="nav-text">1.39.2 只能在栈上</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-40-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">1.40 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-40-1-C-%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD"><span class="nav-text">1.40.1 C++ 标准库（STL）中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-40-2-C-98"><span class="nav-text">1.40.2 C++ 98</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-40-3-C-11"><span class="nav-text">1.40.3 C++ 11</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-40-3-1-shared-ptr"><span class="nav-text">1.40.3.1 shared_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-40-3-2-weak-ptr"><span class="nav-text">1.40.3.2 weak_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-40-3-3-unique-ptr"><span class="nav-text">1.40.3.3 unique_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-40-3-4-auto-ptr"><span class="nav-text">1.40.3.4 auto_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-40-3-5-auto-ptr-%E4%B8%8E-unique-ptr-%E6%AF%94%E8%BE%83"><span class="nav-text">1.40.3.5 auto_ptr 与 unique_ptr 比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-41-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">1.41 强制类型转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-41-1-static-cast"><span class="nav-text">1.41.1 static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-41-2-dynamic-cast"><span class="nav-text">1.41.2 dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-41-3-const-cast"><span class="nav-text">1.41.3 const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-41-4-reinterpret-cast"><span class="nav-text">1.41.4 reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-41-5-bad-cast"><span class="nav-text">1.41.5 bad_cast</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-42-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-RTTI"><span class="nav-text">1.42 运行时类型信息 (RTTI)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-42-1-dynamic-cast"><span class="nav-text">1.42.1 dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-42-2-typeid"><span class="nav-text">1.42.2 typeid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-42-3-type-info"><span class="nav-text">1.42.3 type_info</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-43-Effective-C"><span class="nav-text">1.43 Effective C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-44-Google-C-Style-Guide"><span class="nav-text">1.44 Google C++ Style Guide</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-STL"><span class="nav-text">2. STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-STL-%E7%B4%A2%E5%BC%95"><span class="nav-text">2.1 STL 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-STL-%E5%AE%B9%E5%99%A8"><span class="nav-text">2.2 STL 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-STL-%E7%AE%97%E6%B3%95"><span class="nav-text">2.3 STL 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 顺序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E9%A1%BA%E5%BA%8F%E6%A0%88%EF%BC%88Sequence-Stack%EF%BC%89"><span class="nav-text">3.1.1 顺序栈（Sequence Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E9%98%9F%E5%88%97%EF%BC%88Sequence-Queue%EF%BC%89"><span class="nav-text">3.1.2 队列（Sequence Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-1-%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">3.1.2.1 非循环队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">3.1.2.2 循环队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88Sequence-List%EF%BC%89"><span class="nav-text">3.1.3 顺序表（Sequence List）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 链式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E9%93%BE%E9%98%9F%E5%88%97%EF%BC%88Link-Queue%EF%BC%89"><span class="nav-text">3.2.1 链队列（Link Queue）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="nav-text">3.2.2 线性表的链式表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-1-%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88Link-List%EF%BC%89"><span class="nav-text">3.2.2.1 单链表（Link List）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88Du-Link-List%EF%BC%89"><span class="nav-text">3.2.2.2 双向链表（Du-Link-List）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-3-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88Cir-Link-List%EF%BC%89"><span class="nav-text">3.2.2.3 循环链表（Cir-Link-List）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">3.3 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">3.3.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">3.3.2 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">3.3.3 冲突处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3.3.4 线性探测的哈希表数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E9%80%92%E5%BD%92"><span class="nav-text">3.4 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">3.4.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB"><span class="nav-text">3.4.2 递归与分治</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">3.4.3 递归与迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E5%B0%BE%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">头尾链表存储表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">扩展线性链表存储表示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.5 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E6%80%A7%E8%B4%A8"><span class="nav-text">3.5.1 性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.5.2 存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">3.5.2.1 顺序存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">3.5.2.2 链式存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.5.3 遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E5%88%86%E7%B1%BB"><span class="nav-text">3.5.4 分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%85%B6%E4%BB%96%E6%A0%91%E5%8F%8A%E6%A3%AE%E6%9E%97"><span class="nav-text">3.6 其他树及森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.6.1 树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">3.6.2 并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="nav-text">3.6.3 平衡二叉树（AVL树）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-1-%E6%80%A7%E8%B4%A8"><span class="nav-text">3.6.3.1 性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-2-%E6%9C%80%E5%B0%8F%E5%A4%B1%E8%A1%A1%E6%A0%91"><span class="nav-text">3.6.3.2 最小失衡树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">3.6.4 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-1-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.6.4.1 红黑树的特征是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-2-%E8%B0%83%E6%95%B4"><span class="nav-text">3.6.4.2 调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-3-%E5%BA%94%E7%94%A8"><span class="nav-text">3.6.4.3 应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-4-4-%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">3.6.4.4 红黑树、B 树、B+ 树的区别？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-5-B-%E6%A0%91%EF%BC%88B-tree%EF%BC%89%E3%80%81B-%E6%A0%91%EF%BC%88B-tree%EF%BC%89"><span class="nav-text">3.6.5 B 树（B-tree）、B+ 树（B+-tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-1-%E7%89%B9%E7%82%B9"><span class="nav-text">3.6.5.1 特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-2-%E5%BA%94%E7%94%A8"><span class="nav-text">3.6.5.2 应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-3-%E5%8C%BA%E5%88%AB"><span class="nav-text">3.6.5.3 区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-4-B%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">3.6.5.4 B树的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-5-5-B-%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">3.6.5.5 B+树的优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-6-%E5%85%AB%E5%8F%89%E6%A0%91"><span class="nav-text">3.6.6 八叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-6-1-%E7%94%A8%E9%80%94"><span class="nav-text">3.6.6.1 用途</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%AE%97%E6%B3%95"><span class="nav-text">4. 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%8E%92%E5%BA%8F"><span class="nav-text">4.1 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%9F%A5%E6%89%BE"><span class="nav-text">4.2 查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-text">4.3 图搜索算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-text">4.4 其他算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Problems"><span class="nav-text">5. Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Single-Problem"><span class="nav-text">5.1 Single Problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Leetcode-Problems"><span class="nav-text">5.2 Leetcode Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%89%91%E6%8C%87-Offer"><span class="nav-text">5.3 剑指 Offer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Cracking-the-Coding-Interview-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8"><span class="nav-text">5.4 Cracking the Coding Interview 程序员面试金典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="nav-text">5.5 牛客网</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">6. 操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">6.1 进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">6.1.1 进程之间的通信方式以及优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">6.1.2 线程之间的通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-text">6.1.3 进程之间私有和共享的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-text">6.1.4 线程之间私有和共享的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-5-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%E3%80%81%E4%BC%98%E5%8A%A3%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="nav-text">6.1.5 多进程与多线程间的对比、优劣与选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-1-%E5%AF%B9%E6%AF%94"><span class="nav-text">6.1.5.1 对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-2-%E4%BC%98%E5%8A%A3"><span class="nav-text">6.1.5.2 优劣</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-5-3-%E9%80%89%E6%8B%A9"><span class="nav-text">6.1.5.3 选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-6-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-text">6.1.6 多进程并发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-6-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-text">6.1.6.1 优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-6-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-text">6.1.6.2 缺点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-text">6.1.7 多线程并发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-7-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-text">6.1.7.1 优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-7-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-text">6.1.7.2 缺点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Linux-%E5%86%85%E6%A0%B8%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-text">6.2 Linux 内核的同步方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%8E%9F%E5%9B%A0"><span class="nav-text">6.2.1 原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-text">6.2.2 同步方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%AD%BB%E9%94%81"><span class="nav-text">6.3 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E5%8E%9F%E5%9B%A0"><span class="nav-text">6.3.1 原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.3.2 产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-%E9%A2%84%E9%98%B2"><span class="nav-text">6.3.3 预防</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">6.4 文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-text">6.5 主机字节序与网络字节序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88CPU-%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%89"><span class="nav-text">6.5.1 主机字节序（CPU 字节序）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">6.5.1.1 概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-1-2-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">6.5.1.2 存储方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-1-3-%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="nav-text">6.5.1.3 判断大端小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-1-4-%E5%90%84%E6%9E%B6%E6%9E%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-text">6.5.1.4 各架构处理器的字节序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-text">6.5.2 网络字节序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">6.6 页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-1-%E5%88%86%E7%B1%BB"><span class="nav-text">6.6.1 分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-2-%E7%AE%97%E6%B3%95"><span class="nav-text">6.6.2 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-text">7. 计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.1 各层作用及协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">7.2 物理层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">7.3 数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93"><span class="nav-text">7.3.1 点对点信道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93"><span class="nav-text">7.3.2 广播信道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">7.4 网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1-IP-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.4.1 IP 网际协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2-ICMP-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.4.2 ICMP 网际控制报文协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-3-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.4.3 内部网关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-4-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.4.4 外部网关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-5-IP%E5%A4%9A%E6%92%AD"><span class="nav-text">7.4.5 IP多播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-6-VPN-%E5%92%8C-NAT"><span class="nav-text">7.4.6 VPN 和 NAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-7-%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">7.4.7 路由表包含什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-text">7.5 运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-1-TCP"><span class="nav-text">7.5.1 TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-2-UDP"><span class="nav-text">7.5.2 UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-3-TCP-%E4%B8%8E-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">7.5.3 TCP 与 UDP 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-4-TCP-%E9%BB%8F%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">7.5.4 TCP 黏包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-4-1-%E5%8E%9F%E5%9B%A0"><span class="nav-text">7.5.4.1 原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-4-2-%E8%A7%A3%E5%86%B3"><span class="nav-text">7.5.4.2 解决</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-5-TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">7.5.5 TCP 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-5-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">7.5.5.1 概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-5-2-%E6%96%B9%E6%B3%95"><span class="nav-text">7.5.5.2 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-6-TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">7.5.6 TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-6-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">7.5.6.1 概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-6-2-%E6%96%B9%E6%B3%95"><span class="nav-text">7.5.6.2 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-7-TCP-%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">7.5.7 TCP 传输连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-7-1-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-text">7.5.7.1 TCP 三次握手建立连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-7-2-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-text">7.5.7.2 TCP 为什么要进行三次握手？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-7-3-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="nav-text">7.5.7.3 TCP 四次挥手释放连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-7-4-TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-text">7.5.7.4 TCP 为什么要进行四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-8-TCP-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">7.5.8 TCP 有限状态机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">7.6 应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-1-DNS"><span class="nav-text">7.6.1 DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-2-FTP"><span class="nav-text">7.6.2 FTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-3-TELNET"><span class="nav-text">7.6.3 TELNET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-4-WWW"><span class="nav-text">7.6.4 WWW</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-6-4-1-URL"><span class="nav-text">7.6.4.1 URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-6-4-2-HTTP"><span class="nav-text">7.6.4.2 HTTP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-6-4-3-%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.6.4.3 其他协议</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">8. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-Socket"><span class="nav-text">8.1 Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-Socket-%E4%B8%AD%E7%9A%84-read-%E3%80%81write-%E5%87%BD%E6%95%B0"><span class="nav-text">8.1.1 Socket 中的 read()、write() 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-1-1-read"><span class="nav-text">8.1.1.1 read()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-1-2-write"><span class="nav-text">8.1.1.2 write()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-Socket-%E4%B8%AD-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-text">8.1.2 Socket 中 TCP 的三次握手建立连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-Socket-%E4%B8%AD-TCP-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="nav-text">8.1.3 Socket 中 TCP 的四次握手释放连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">9. 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E8%8C%83%E5%BC%8F"><span class="nav-text">9.1 范式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">10. 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.1 单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.2 抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.3 适配器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.4 桥接模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.5 观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-text">10.6 设计模式的六大原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E5%BA%93"><span class="nav-text">11. 链接装载库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E5%86%85%E5%AD%98%E3%80%81%E6%A0%88%E3%80%81%E5%A0%86"><span class="nav-text">11.1 内存、栈、堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-1-%E6%A0%88"><span class="nav-text">11.1.1 栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-2-%E5%A0%86"><span class="nav-text">11.1.2 堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-3-%E2%80%9C%E6%AE%B5%E9%94%99%E8%AF%AF%EF%BC%88segment-fault%EF%BC%89%E2%80%9D-%E6%88%96-%E2%80%9C%E9%9D%9E%E6%B3%95%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%A5%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%8D%E8%83%BD-read-write%E2%80%9D"><span class="nav-text">11.1.3 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read&#x2F;write”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="nav-text">11.2 编译链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1-%E5%90%84%E5%B9%B3%E5%8F%B0%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">11.2.1 各平台文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">11.2.2 编译链接过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-3-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-text">11.2.3 目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-3-1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">11.2.3.1 目标文件格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-3-2-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">11.2.3.2 目标文件存储结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-4-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%8F%A3%E2%80%94%E2%80%94%E7%AC%A6%E5%8F%B7"><span class="nav-text">11.2.4 链接的接口——符号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-Linux-%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93%EF%BC%88Shared-Library%EF%BC%89"><span class="nav-text">11.3 Linux 的共享库（Shared Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-%E5%91%BD%E5%90%8D"><span class="nav-text">11.3.1 命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-%E8%B7%AF%E5%BE%84"><span class="nav-text">11.3.2 路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">11.3.3 环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-4-so-%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%BC%96%E5%86%99"><span class="nav-text">11.3.4 so 共享库的编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-5-so-%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E8%A2%AB%E5%8F%AF%E6%89%A7%E8%A1%8C%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%94%A8%EF%BC%89"><span class="nav-text">11.3.5 so 共享库的使用（被可执行项目调用）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-%E8%BF%90%E8%A1%8C%E5%BA%93%EF%BC%88Runtime-Library%EF%BC%89"><span class="nav-text">11.4 运行库（Runtime Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-1-%E5%85%B8%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-text">11.4.1 典型程序运行步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-2-glibc-%E5%85%A5%E5%8F%A3"><span class="nav-text">11.4.2 glibc 入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-3-MSVC-CRT-%E5%85%A5%E5%8F%A3"><span class="nav-text">11.4.3 MSVC CRT 入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-4-C-%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E5%BA%93%EF%BC%88CRT%EF%BC%89"><span class="nav-text">11.4.4 C 语言运行库（CRT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-5-C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88ANSI-C%EF%BC%89"><span class="nav-text">11.4.5 C语言标准库（ANSI C）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="nav-text">12. 回调函数和钩子函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">12.1 什么是回调函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">12.1.1 为什么要使用回调函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">12.1.2 使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-3-%E6%9C%BA%E5%88%B6"><span class="nav-text">12.1.3 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-4-%E5%8F%82%E8%80%83"><span class="nav-text">12.1.4 参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">12.2 什么是钩子函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-1-%E6%9C%AC%E8%B4%A8"><span class="nav-text">12.2.1 本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-2-%E7%B1%BB%E5%9E%8B"><span class="nav-text">12.2.2 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-3-%E6%9C%BA%E5%88%B6"><span class="nav-text">12.2.3 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-4-%E5%8F%82%E8%80%83"><span class="nav-text">12.2.4 参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%9A%84%E4%BC%A0%E9%80%92%EF%BC%8D%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6"><span class="nav-text">12.3 异步消息的传递－回调机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83"><span class="nav-text">12.3.1 什么是回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-2-%E8%BF%87%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%EF%BC%88C%EF%BC%89"><span class="nav-text">12.3.2 过程语言中的回调（C）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#12-3-2-1-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">12.3.2.1 函数指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-3-2-2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-text">12.3.2.2 参数传递规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-3-2-3-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text">12.3.2.3 应用举例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-3-%E5%9B%9E%E8%B0%83%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88CORBA%EF%BC%89"><span class="nav-text">12.3.3 回调在分布式计算中的应用（CORBA）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#12-3-3-1-%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9E%8B"><span class="nav-text">12.3.3.1 回调接口模型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-text">13. 野指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">13.1 避免野指针的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-text">14. 海量数据处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E9%9F%B3%E8%A7%86%E9%A2%91"><span class="nav-text">15. 音视频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%85%B6%E4%BB%96"><span class="nav-text">16. 其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E4%B9%A6%E7%B1%8D"><span class="nav-text">17. 书籍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-%E8%AF%AD%E8%A8%80"><span class="nav-text">17.1 语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-%E7%AE%97%E6%B3%95"><span class="nav-text">17.2 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-3-%E7%B3%BB%E7%BB%9F"><span class="nav-text">17.3 系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-4-%E7%BD%91%E7%BB%9C"><span class="nav-text">17.4 网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5-%E5%85%B6%E4%BB%96"><span class="nav-text">17.5 其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%A4%8D%E4%B9%A0%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99"><span class="nav-text">18. 复习刷题网站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E6%8B%9B%E8%81%98%E6%97%B6%E9%97%B4%E5%B2%97%E4%BD%8D"><span class="nav-text">19. 招聘时间岗位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C"><span class="nav-text">20. 面试题目经验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-1-%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="nav-text">20.1 牛客网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-2-%E7%9F%A5%E4%B9%8E"><span class="nav-text">20.2 知乎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-3-CSDN"><span class="nav-text">20.3 CSDN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-4-cnblogs"><span class="nav-text">20.4 cnblogs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-5-Segmentfault"><span class="nav-text">20.5 Segmentfault</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-6-HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-text">20.6 HTTP相关知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-7-Spark"><span class="nav-text">20.7 Spark</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-8-%E5%8A%A0%E5%AF%86%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">20.8 加密安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-9-%E5%85%B6%E4%BB%96"><span class="nav-text">20.9 其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-1%E9%AB%98%E5%BE%B7%E9%9D%A2%E8%AF%95"><span class="nav-text">20.1高德面试</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mr.Miaow"
      src="https://avatars.githubusercontent.com/u/7922626?v=4">
  <p class="site-author-name" itemprop="name">Mr.Miaow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>
      RSS
    </a>
  </div>

  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/miaopei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;miaopei" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/miaopei163@163.com" title="E-Mail → miaopei163@163.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


          <link rel="stylesheet" href="/dist/APlayer.min.css">
          <div id="aplayer"></div>
          <script type="text/javascript" src="/dist/APlayer.min.js"></script>
          <script type="text/javascript" src="/dist/music.js"></script>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://miaopei.github.io/2016/06/08/Program-C/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/7922626?v=4">
      <meta itemprop="name" content="Mr.Miaow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Miaow Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Interview C C++ | Mr.Miaow Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Interview C C++
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-06-08 10:14:50" itemprop="dateCreated datePublished" datetime="2016-06-08T10:14:50+08:00">2016-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>51 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="C-C-面试知识总结"><a href="#C-C-面试知识总结" class="headerlink" title="C&#x2F;C++ 面试知识总结"></a>C&#x2F;C++ 面试知识总结</h2><p>C&#x2F;C++ 面试知识总结，只为复习、分享。部分知识点与图片来自网络，侵删。</p>
<p>勘误新增请 Issue、PR，建议、讨论请 <a target="_blank" rel="noopener" href="https://github.com/huihut/interview/issues/12">#issues&#x2F;12</a>，排版使用 <a target="_blank" rel="noopener" href="https://github.com/mzlogin/chinese-copywriting-guidelines">中文文案排版指北</a></p>
<p>使用建议：</p>
<ul>
<li><code>Ctrl + F</code>：快速查找定位知识点</li>
<li><code>TOC 导航</code>：<a target="_blank" rel="noopener" href="https://github.com/jawil/GayHub">jawil&#x2F;GayHub</a> 插件快速目录跳转</li>
</ul>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#cc">C&#x2F;C++</a></li>
<li><a href="#stl">STL</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="#%E7%AE%97%E6%B3%95">算法</a></li>
<li><a href="#problems">Problems</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E5%BA%93">链接装载库</a></li>
<li><a href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">海量数据处理</a></li>
<li><a href="#%E9%9F%B3%E8%A7%86%E9%A2%91">音视频</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
<li><a href="#%E4%B9%A6%E7%B1%8D">书籍</a></li>
<li><a href="#%E5%A4%8D%E4%B9%A0%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99">复习刷题网站</a></li>
<li><a href="#%E6%8B%9B%E8%81%98%E6%97%B6%E9%97%B4%E5%B2%97%E4%BD%8D">招聘时间岗位</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E7%BB%8F%E9%AA%8C">面试题目经验</a></li>
</ul>
<h2 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C&#x2F;C++"></a>1. C&#x2F;C++</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><details><summary>const 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="type">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="type">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="type">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="comment">// 还有其中区别方法，沿着 * 号划一条线：</span></span><br><span class="line">	<span class="comment">// 如果const位于 * 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；</span></span><br><span class="line">	<span class="comment">// 如果const位于 * 的右侧，const就是修饰指针本身，即指针本身是常量。</span></span><br><span class="line">    <span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-2-static"><a href="#1-2-static" class="headerlink" title="1.2 static"></a>1.2 static</h3><h4 id="1-2-1-作用"><a href="#1-2-1-作用" class="headerlink" title="1.2.1 作用"></a>1.2.1 作用</h4><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c35cc218bb4">C++ static 和const 的作用</a></p>
</blockquote>
<h3 id="1-3-this-指针"><a href="#1-3-this-指针" class="headerlink" title="1.3 this 指针"></a>1.3 this 指针</h3><ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h3 id="1-4-inline-内联函数"><a href="#1-4-inline-内联函数" class="headerlink" title="1.4 inline 内联函数"></a>1.4 inline 内联函数</h3><h4 id="1-4-1-特征"><a href="#1-4-1-特征" class="headerlink" title="1.4.1 特征"></a>1.4.1 特征</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>不能包含循环、递归、switch 等复杂操作；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="1-4-2-使用"><a href="#1-4-2-使用" class="headerlink" title="1.4.2 使用"></a>1.4.2 使用</h4><details><summary>inline 使用</summary> 


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> secend,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

</details>

<h4 id="1-4-3-编译器对-inline-函数的处理步骤"><a href="#1-4-3-编译器对-inline-函数的处理步骤" class="headerlink" title="1.4.3 编译器对 inline 函数的处理步骤"></a>1.4.3 编译器对 inline 函数的处理步骤</h4><ol>
<li>将 inline 函数体复制到 inline 函数调用点处； </li>
<li>为所用 inline 函数中的局部变量分配内存空间； </li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="1-4-4-优缺点"><a href="#1-4-4-优缺点" class="headerlink" title="1.4.4 优缺点"></a>1.4.4 优缺点</h4><p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4 id="1-4-5-虚函数（virtual）可以是内联函数（inline）吗？"><a href="#1-4-5-虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="1.4.5 虚函数（virtual）可以是内联函数（inline）吗？"></a>1.4.5 虚函数（virtual）可以是内联函数（inline）吗？</h4><p><a target="_blank" rel="noopener" href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?</a></p>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<details><summary>虚函数内联使用</summary> 


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">	Base b;</span><br><span class="line">	b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">	Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-5-assert"><a href="#1-5-assert" class="headerlink" title="1.5 assert()"></a>1.5 assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<details><summary>assert() 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-6-sizeof"><a href="#1-6-sizeof" class="headerlink" title="1.6 sizeof()"></a>1.6 sizeof()</h3><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h3 id="1-7-pragma-pack-n"><a href="#1-7-pragma-pack-n" class="headerlink" title="1.7 #pragma pack(n)"></a>1.7 #pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<details><summary>#pragma pack(n) 使用</summary> 


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> m1;</span><br><span class="line">    <span class="type">double</span> m4;</span><br><span class="line">    <span class="type">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-8-位域"><a href="#1-8-位域" class="headerlink" title="1.8 位域"></a>1.8 位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure>

<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h3 id="1-9-volatile"><a href="#1-9-volatile" class="headerlink" title="1.9 volatile"></a>1.9 volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h3 id="1-10-extern-“C”"><a href="#1-10-extern-“C”" class="headerlink" title="1.10 extern “C”"></a>1.10 extern “C”</h3><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和连接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<details><summary>extern "C" 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-11-struct-和-typedef-struct"><a href="#1-11-struct-和-typedef-struct" class="headerlink" title="1.11 struct 和 typedef struct"></a>1.11 struct 和 typedef struct</h3><h4 id="1-11-1-C-中"><a href="#1-11-1-C-中" class="headerlink" title="1.11.1 C 中"></a>1.11.1 C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() &#123;&#125;</code>。</p>
<h4 id="1-11-2-C-中"><a href="#1-11-2-C-中" class="headerlink" title="1.11.2 C++ 中"></a>1.11.2 C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student &#123;...&#125;;</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，&quot;struct&quot; 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 &quot;Student&quot; 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Student</span>(); </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> me;      <span class="comment">// 或者 &quot;S me&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-C-中-struct-和-class"><a href="#1-12-C-中-struct-和-class" class="headerlink" title="1.12 C++ 中 struct 和 class"></a>1.12 C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="1-12-1-区别"><a href="#1-12-1-区别" class="headerlink" title="1.12.1 区别"></a>1.12.1 区别</h4><ul>
<li>最本质的一个区别就是默认的访问控制<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h3 id="1-13-union-联合"><a href="#1-13-union-联合" class="headerlink" title="1.13 union 联合"></a>1.13 union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<details><summary>union 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">UnionTest</span> &#123;</span><br><span class="line">    <span class="built_in">UnionTest</span>() : <span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-14-C-实现-C-类"><a href="#1-14-C-实现-C-类" class="headerlink" title="1.14 C 实现 C++ 类"></a>1.14 C 实现 C++ 类</h3><p><a target="_blank" rel="noopener" href="http://dongxicheng.org/cpp/ooc/">C 语言实现封装、继承和多态</a></p>
<h3 id="1-15-explicit（显式）构造函数"><a href="#1-15-explicit（显式）构造函数" class="headerlink" title="1.15 explicit（显式）构造函数"></a>1.15 explicit（显式）构造函数</h3><p>explicit 修饰的构造函数可用来防止隐式转换</p>
<details><summary>explicit 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test1</span>(<span class="type">int</span> n)            <span class="comment">// 普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="type">int</span> n)</span>   <span class="comment">// explicit（显式）构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test1 t1=<span class="number">12</span>;            <span class="comment">// 隐式调用其构造函数，成功</span></span><br><span class="line">    Test2 t2=<span class="number">12</span>;            <span class="comment">// 编译错误，不能隐式调用其构造函数</span></span><br><span class="line">    <span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;           <span class="comment">// 显式调用成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-16-friend-友元类和友元函数"><a href="#1-16-friend-友元类和友元函数" class="headerlink" title="1.16 friend 友元类和友元函数"></a>1.16 friend 友元类和友元函数</h3><ul>
<li>能访问私有成员  </li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h3 id="1-17-using"><a href="#1-17-using" class="headerlink" title="1.17 using"></a>1.17 using</h3><h4 id="1-17-1-using-声明"><a href="#1-17-1-using-声明" class="headerlink" title="1.17.1 using 声明"></a>1.17.1 using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h4 id="1-17-2-构造函数的-using-声明【C-11】"><a href="#1-17-2-构造函数的-using-声明【C-11】" class="headerlink" title="1.17.2 构造函数的 using 声明【C++11】"></a>1.17.2 构造函数的 using 声明【C++11】</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">derived</span>(parms) : <span class="built_in">base</span>(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-17-3-using-指示"><a href="#1-17-3-using-指示" class="headerlink" title="1.17.3 using 指示"></a>1.17.3 using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h4 id="1-17-4-尽量少使用-using-指示-污染命名空间"><a href="#1-17-4-尽量少使用-using-指示-污染命名空间" class="headerlink" title="1.17.4 尽量少使用 using 指示 污染命名空间"></a>1.17.4 尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了制定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<details><summary>using 使用</summary> 

<p>尽量少使用 <code>using 指示</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>应该多使用 <code>using 声明</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::cin &gt;&gt; x ;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-18-范围解析运算符"><a href="#1-18-范围解析运算符" class="headerlink" title="1.18 :: 范围解析运算符"></a>1.18 :: 范围解析运算符</h3><h4 id="1-18-1-分类"><a href="#1-18-1-分类" class="headerlink" title="1.18.1 分类"></a>1.18.1 分类</h4><ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<details><summary>:: 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-19-enum-枚举类型"><a href="#1-19-enum-枚举类型" class="headerlink" title="1.19 enum 枚举类型"></a>1.19 enum 枚举类型</h3><h4 id="1-19-1-限定作用域的枚举类型"><a href="#1-19-1-限定作用域的枚举类型" class="headerlink" title="1.19.1 限定作用域的枚举类型"></a>1.19.1 限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">open_modes</span> &#123; input, output, append &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-19-2-不限定作用域的枚举类型"><a href="#1-19-2-不限定作用域的枚举类型" class="headerlink" title="1.19.2 不限定作用域的枚举类型"></a>1.19.2 不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.weixueyuan.net/view/5824.html">C++ 枚举类型详解</a></p>
</blockquote>
<h3 id="1-20-decltype"><a href="#1-20-decltype" class="headerlink" title="1.20 decltype"></a>1.20 decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<details><summary>decltype 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-21-引用"><a href="#1-21-引用" class="headerlink" title="1.21 引用"></a>1.21 引用</h3><h4 id="1-21-1-左值引用"><a href="#1-21-1-左值引用" class="headerlink" title="1.21.1 左值引用"></a>1.21.1 左值引用</h4><p>常规引用，一般表示对象的身份。</p>
<h4 id="1-21-2-右值引用"><a href="#1-21-2-右值引用" class="headerlink" title="1.21.2 右值引用"></a>1.21.2 右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h4 id="1-21-3-引用折叠"><a href="#1-21-3-引用折叠" class="headerlink" title="1.21.3 引用折叠"></a>1.21.3 引用折叠</h4><ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianxiaolu1175/article/details/46889523">详解c++ 引用（reference）与 指针（pointer）的区别与联系</a></p>
</blockquote>
<h3 id="1-22-宏"><a href="#1-22-宏" class="headerlink" title="1.22 宏"></a>1.22 宏</h3><ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h3 id="1-23-成员初始化列表"><a href="#1-23-成员初始化列表" class="headerlink" title="1.23 成员初始化列表"></a>1.23 成员初始化列表</h3><p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li>
</ol>
</li>
</ul>
<h3 id="1-24-initializer-list-列表初始化【C-11】"><a href="#1-24-initializer-list-列表初始化【C-11】" class="headerlink" title="1.24 initializer_list 列表初始化【C++11】"></a>1.24 initializer_list 列表初始化【C++11】</h3><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<details><summary>initializer_list 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;T&gt; v;</span><br><span class="line">    <span class="built_in">S</span>(std::initializer_list&lt;T&gt; l) : <span class="built_in">v</span>(l) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;constructed with a &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;-element list\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(std::initializer_list&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">const</span> T*, std::<span class="type">size_t</span>&gt; <span class="title">c_arr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.<span class="built_in">append</span>(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The vector size is now &quot;</span> &lt;&lt; s.<span class="built_in">c_arr</span>().second &lt;&lt; <span class="string">&quot; ints:\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Range-for over brace-init-list: \n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The list bound to auto has size() = &quot;</span> &lt;&lt; al.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;std::initializer_list&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-25-面向对象"><a href="#1-25-面向对象" class="headerlink" title="1.25 面向对象"></a>1.25 面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<img data-src="/2016/06/08/Program-C/interview/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" class="" title="面向对象的三个基本特征">

<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="1-26-封装"><a href="#1-26-封装" class="headerlink" title="1.26 封装"></a>1.26 封装</h3><ul>
<li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li>
<li>关键字：public, protected, friendly, private。不写默认为 friendly。</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>当前类</th>
<th>包内</th>
<th>子孙类</th>
<th>包外</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>friendly</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="1-27-继承"><a href="#1-27-继承" class="headerlink" title="1.27 继承"></a>1.27 继承</h3><ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="1-28-多态"><a href="#1-28-多态" class="headerlink" title="1.28 多态"></a>1.28 多态</h3><ul>
<li>多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。</li>
<li>C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。</li>
<li>多态是以封装和继承为基础的。</li>
</ul>
<h4 id="1-28-1-静态多态（早绑定）"><a href="#1-28-1-静态多态（早绑定）" class="headerlink" title="1.28.1 静态多态（早绑定）"></a>1.28.1 静态多态（早绑定）</h4><p>函数重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-28-2-动态多态（晚绑定）"><a href="#1-28-2-动态多态（晚绑定）" class="headerlink" title="1.28.2 动态多态（晚绑定）"></a>1.28.2 动态多态（晚绑定）</h4><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：<a target="_blank" rel="noopener" href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？</a></li>
</ul>
<details><summary>动态多态使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>                     <span class="comment">// 形状类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> : <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-29-虚析构函数"><a href="#1-29-虚析构函数" class="headerlink" title="1.29 虚析构函数"></a>1.29 虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<details><summary>虚析构函数使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;<span class="built_in">calcArea</span>();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-30-纯虚函数"><a href="#1-30-纯虚函数" class="headerlink" title="1.30 纯虚函数"></a>1.30 纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-31-虚函数、纯虚函数"><a href="#1-31-虚函数、纯虚函数" class="headerlink" title="1.31 虚函数、纯虚函数"></a>1.31 虚函数、纯虚函数</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li>
<li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li>
<li>带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</li>
</ul>
<h3 id="1-32-虚函数指针、虚函数表"><a href="#1-32-虚函数指针、虚函数表" class="headerlink" title="1.32 虚函数指针、虚函数表"></a>1.32 虚函数指针、虚函数表</h3><ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<h3 id="1-33-虚继承"><a href="#1-33-虚继承" class="headerlink" title="1.33 虚继承"></a>1.33 虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="1-34-虚继承、虚函数"><a href="#1-34-虚继承、虚函数" class="headerlink" title="1.34 虚继承、虚函数"></a>1.34 虚继承、虚函数</h3><ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-35-模板类、成员模板、虚函数"><a href="#1-35-模板类、成员模板、虚函数" class="headerlink" title="1.35 模板类、成员模板、虚函数"></a>1.35 模板类、成员模板、虚函数</h3><ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h3 id="1-36-抽象类、接口类、聚合类"><a href="#1-36-抽象类、接口类、聚合类" class="headerlink" title="1.36 抽象类、接口类、聚合类"></a>1.36 抽象类、接口类、聚合类</h3><ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul>
<li>所有成员都是 public</li>
<li>没有有定于任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h3 id="1-37-内存分配和管理"><a href="#1-37-内存分配和管理" class="headerlink" title="1.37 内存分配和管理"></a>1.37 内存分配和管理</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C&#x2F;C++内存管理详解</a> - ShinChan’s Blog</p>
</blockquote>
<h4 id="1-37-1-malloc、calloc、realloc、alloca"><a href="#1-37-1-malloc、calloc、realloc、alloca" class="headerlink" title="1.37.1 malloc、calloc、realloc、alloca"></a>1.37.1 malloc、calloc、realloc、alloca</h4><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h4 id="1-37-2-malloc、free"><a href="#1-37-2-malloc、free" class="headerlink" title="1.37.2 malloc、free"></a>1.37.2 malloc、free</h4><p>用于分配、释放内存</p>
<details><summary>malloc、free 使用</summary> 

<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">assert</span>(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

</details>

<h4 id="1-37-3-new、delete"><a href="#1-37-3-new、delete" class="headerlink" title="1.37.3 new、delete"></a>1.37.3 new、delete</h4><ol>
<li>new &#x2F; new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</li>
<li>delete&#x2F;delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<details><summary>new、delete 使用</summary> 

<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> <span class="built_in">T</span>();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h4 id="1-37-4-定位-new"><a href="#1-37-4-定位-new" class="headerlink" title="1.37.4 定位 new"></a>1.37.4 定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (palce_address) type</span><br><span class="line"><span class="built_in">new</span> (palce_address) <span class="built_in">type</span> (initializers)</span><br><span class="line"><span class="built_in">new</span> (palce_address) type [size]</span><br><span class="line"><span class="built_in">new</span> (palce_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>palce_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h3 id="1-38-delete-this-合法吗？"><a href="#1-38-delete-this-合法吗？" class="headerlink" title="1.38 delete this 合法吗？"></a>1.38 delete this 合法吗？</h3><p><a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?</a></p>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h3 id="1-39-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#1-39-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="1.39 如何定义一个只能在堆上（栈上）生成对象的类？"></a>1.39 如何定义一个只能在堆上（栈上）生成对象的类？</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?</a></p>
<h4 id="1-39-1-只能在堆上"><a href="#1-39-1-只能在堆上" class="headerlink" title="1.39.1 只能在堆上"></a>1.39.1 只能在堆上</h4><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h4 id="1-39-2-只能在栈上"><a href="#1-39-2-只能在栈上" class="headerlink" title="1.39.2 只能在栈上"></a>1.39.2 只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="1-40-智能指针"><a href="#1-40-智能指针" class="headerlink" title="1.40 智能指针"></a>1.40 智能指针</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/haolexiao/article/details/56773039">C++11及C++14标准的智能指针</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a819825294/article/details/52139328">C++ 智能指针</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/104666/">使用 C++11 智能指针时要避开的 10 大错误</a></p>
</blockquote>
<h4 id="1-40-1-C-标准库（STL）中"><a href="#1-40-1-C-标准库（STL）中" class="headerlink" title="1.40.1 C++ 标准库（STL）中"></a>1.40.1 C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="1-40-2-C-98"><a href="#1-40-2-C-98" class="headerlink" title="1.40.2 C++ 98"></a>1.40.2 C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::auto_ptr&lt;std::string&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> std::string(str))</span>；</span></span><br></pre></td></tr></table></figure>

<h4 id="1-40-3-C-11"><a href="#1-40-3-C-11" class="headerlink" title="1.40.3 C++ 11"></a>1.40.3 C++ 11</h4><ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h5 id="1-40-3-1-shared-ptr"><a href="#1-40-3-1-shared-ptr" class="headerlink" title="1.40.3.1 shared_ptr"></a>1.40.3.1 shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h5 id="1-40-3-2-weak-ptr"><a href="#1-40-3-2-weak-ptr" class="headerlink" title="1.40.3.2 weak_ptr"></a>1.40.3.2 weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h5 id="1-40-3-3-unique-ptr"><a href="#1-40-3-3-unique-ptr" class="headerlink" title="1.40.3.3 unique_ptr"></a>1.40.3.3 unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h5 id="1-40-3-4-auto-ptr"><a href="#1-40-3-4-auto-ptr" class="headerlink" title="1.40.3.4 auto_ptr"></a>1.40.3.4 auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<h5 id="1-40-3-5-auto-ptr-与-unique-ptr-比较"><a href="#1-40-3-5-auto-ptr-与-unique-ptr-比较" class="headerlink" title="1.40.3.5 auto_ptr 与 unique_ptr 比较"></a>1.40.3.5 auto_ptr 与 unique_ptr 比较</h5><ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h3 id="1-41-强制类型转换运算符"><a href="#1-41-强制类型转换运算符" class="headerlink" title="1.41 强制类型转换运算符"></a>1.41 强制类型转换运算符</h3><p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符</a></p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html">C++类型转换总结</a></p>
</blockquote>
<h4 id="1-41-1-static-cast"><a href="#1-41-1-static-cast" class="headerlink" title="1.41.1 static_cast"></a>1.41.1 static_cast</h4><ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p>向上转换是一种隐式转换。</p>
</blockquote>
<h4 id="1-41-2-dynamic-cast"><a href="#1-41-2-dynamic-cast" class="headerlink" title="1.41.2 dynamic_cast"></a>1.41.2 dynamic_cast</h4><ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h4 id="1-41-3-const-cast"><a href="#1-41-3-const-cast" class="headerlink" title="1.41.3 const_cast"></a>1.41.3 const_cast</h4><ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h4 id="1-41-4-reinterpret-cast"><a href="#1-41-4-reinterpret-cast" class="headerlink" title="1.41.4 reinterpret_cast"></a>1.41.4 reinterpret_cast</h4><ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h4 id="1-41-5-bad-cast"><a href="#1-41-5-bad-cast" class="headerlink" title="1.41.5 bad_cast"></a>1.41.5 bad_cast</h4><ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<details><summary>bad_cast 使用</summary> 

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="built_in">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Caught: &quot;</span> &lt;&lt; b.<span class="built_in">what</span>();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-42-运行时类型信息-RTTI"><a href="#1-42-运行时类型信息-RTTI" class="headerlink" title="1.42 运行时类型信息 (RTTI)"></a>1.42 运行时类型信息 (RTTI)</h3><h4 id="1-42-1-dynamic-cast"><a href="#1-42-1-dynamic-cast" class="headerlink" title="1.42.1 dynamic_cast"></a>1.42.1 dynamic_cast</h4><ul>
<li>用于多态类型的转换</li>
</ul>
<h4 id="1-42-2-typeid"><a href="#1-42-2-typeid" class="headerlink" title="1.42.2 typeid"></a>1.42.2 typeid</h4><ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h4 id="1-42-3-type-info"><a href="#1-42-3-type-info" class="headerlink" title="1.42.3 type_info"></a>1.42.3 type_info</h4><ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：<code>typeinfo</code></li>
</ul>
<details><summary>typeid、type_info 使用</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span>                       <span class="comment">// 能飞的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> : <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_info</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> type_info &amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> type_info &amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">before</span><span class="params">(<span class="type">const</span> type_info &amp; rhs)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">type_info</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;<span class="built_in">takeoff</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(*obj).<span class="built_in">name</span>() &lt;&lt; endl;        <span class="comment">// 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">typeid</span>(*obj) == <span class="built_in">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="built_in">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;<span class="built_in">land</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="1-43-Effective-C"><a href="#1-43-Effective-C" class="headerlink" title="1.43 Effective C++"></a>1.43 Effective C++</h3><ol>
<li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li>
<li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li>
<li>尽可能使用 const</li>
<li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li>
<li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li>
<li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li>
<li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li>
<li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li>
<li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li>
<li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li>
<li>在 <code>operator=</code> 中处理 “自我赋值”</li>
<li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li>
<li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li>
<li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li>
<li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li>
<li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li>
<li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li>
<li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li>
<li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li>
<li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li>
<li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li>
<li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li>
<li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li>
<li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li>
<li>考虑写一个不抛异常的 swap 函数</li>
<li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li>
<li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li>
<li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li>
<li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li>
<li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li>
<li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li>
<li>确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li>
<li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li>
<li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li>
<li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li>
<li>绝不重新定义继承而来的 non-virtual 函数</li>
<li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li>
</ol>
<h3 id="1-44-Google-C-Style-Guide"><a href="#1-44-Google-C-Style-Guide" class="headerlink" title="1.44 Google C++ Style Guide"></a>1.44 Google C++ Style Guide</h3><blockquote>
<p>英文：<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a><br>中文：<a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南</a><br>Google C++ Style Guide 图：</p>
</blockquote>
<img data-src="/2016/06/08/Program-C/interview/GoogleCppStyleGuide.png" class="" title="GoogleCppStyleGuide">

<blockquote>
<p>图片来源于：<a target="_blank" rel="noopener" href="https://blog.csdn.net/voidccc/article/details/37599203">CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide)</a></p>
</blockquote>
<h2 id="2-STL"><a href="#2-STL" class="headerlink" title="2. STL"></a>2. STL</h2><h3 id="2-1-STL-索引"><a href="#2-1-STL-索引" class="headerlink" title="2.1 STL 索引"></a>2.1 STL 索引</h3><p><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL">STL 方法含义索引</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a5607166fb9a01cb256d501">C++ STL容器总结</a></p>
</blockquote>
<h3 id="2-2-STL-容器"><a href="#2-2-STL-容器" class="headerlink" title="2.2 STL 容器"></a>2.2 STL 容器</h3><table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td>
<td>数组</td>
<td>随机读改 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td>
<td>数组</td>
<td>随机读改、尾部插入、尾部删除 O(1)<br/>头部插入、头部删除 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td>
<td>双向链表</td>
<td>插入、删除 O(1)<br/>随机读改 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持快速增删</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td>
<td>双端队列</td>
<td>头尾插入、头尾删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td>
<td>deque &#x2F; list</td>
<td>顶部插入、顶部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td>
<td>deque &#x2F; list</td>
<td>尾部插入、头部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td>
<td>vector + max-heap</td>
<td>插入、删除 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td>vector容器+heap处理规则</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>hash_set</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>hash_multiset</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>hash_map</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>hash_multimap</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-3-STL-算法"><a href="#2-3-STL-算法" class="headerlink" title="2.3 STL 算法"></a>2.3 STL 算法</h3><table>
<thead>
<tr>
<th>算法</th>
<th>底层算法</th>
<th>时间复杂度</th>
<th>可不可重复</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/algorithm/find/">find</a></td>
<td>顺序查找</td>
<td>O(n)</td>
<td>可重复</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort</a></td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Introsort">内省排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>可重复</td>
</tr>
</tbody></table>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><h3 id="3-1-顺序结构"><a href="#3-1-顺序结构" class="headerlink" title="3.1 顺序结构"></a>3.1 顺序结构</h3><h4 id="3-1-1-顺序栈（Sequence-Stack）"><a href="#3-1-1-顺序栈（Sequence-Stack）" class="headerlink" title="3.1.1 顺序栈（Sequence Stack）"></a>3.1.1 顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p>
<details><summary>顺序栈数据结构和图片</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> increment;</span><br><span class="line">&#125; SqSrack;</span><br></pre></td></tr></table></figure>

</details>

<img data-src="/2016/06/08/Program-C/interview/SqStack.png" class="" title="SqStack">

<h4 id="3-1-2-队列（Sequence-Queue）"><a href="#3-1-2-队列（Sequence-Queue）" class="headerlink" title="3.1.2 队列（Sequence Queue）"></a>3.1.2 队列（Sequence Queue）</h4><details><summary>队列数据结构</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType * elem;</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">	<span class="type">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

</details>

<h5 id="3-1-2-1-非循环队列"><a href="#3-1-2-1-非循环队列" class="headerlink" title="3.1.2.1 非循环队列"></a>3.1.2.1 非循环队列</h5><p>非循环队列图片：</p>
<img data-src="/2016/06/08/Program-C/interview/SqQueue.png" class="" title="SqQueue">

<p><code>SqQueue.rear++</code></p>
<h5 id="3-1-2-2-循环队列"><a href="#3-1-2-2-循环队列" class="headerlink" title="3.1.2.2 循环队列"></a>3.1.2.2 循环队列</h5><p>循环队列图片：</p>
<img data-src="/2016/06/08/Program-C/interview/SqLoopStack.png" class="" title="SqLoopStack">

<p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p>
<h4 id="3-1-3-顺序表（Sequence-List）"><a href="#3-1-3-顺序表（Sequence-List）" class="headerlink" title="3.1.3 顺序表（Sequence List）"></a>3.1.3 顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p>
<details><summary>顺序表数据结构和图片</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

</details>

<img data-src="/2016/06/08/Program-C/interview/SqList.png" class="" title="SqList">


<h3 id="3-2-链式结构"><a href="#3-2-链式结构" class="headerlink" title="3.2 链式结构"></a>3.2 链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p>
<p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p>
<details><summary>链式数据结构</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *LinkList; </span><br></pre></td></tr></table></figure>

</details>

<h4 id="3-2-1-链队列（Link-Queue）"><a href="#3-2-1-链队列（Link-Queue）" class="headerlink" title="3.2.1 链队列（Link Queue）"></a>3.2.1 链队列（Link Queue）</h4><p>链队列图片：</p>
<img data-src="/2016/06/08/Program-C/interview/LinkQueue.png" class="" title="LinkQueue">

<h4 id="3-2-2-线性表的链式表示"><a href="#3-2-2-线性表的链式表示" class="headerlink" title="3.2.2 线性表的链式表示"></a>3.2.2 线性表的链式表示</h4><h5 id="3-2-2-1-单链表（Link-List）"><a href="#3-2-2-1-单链表（Link-List）" class="headerlink" title="3.2.2.1 单链表（Link List）"></a>3.2.2.1 单链表（Link List）</h5><p>单链表图片：</p>
<img data-src="/2016/06/08/Program-C/interview/LinkList.png" class="" title="LinkList">


<h5 id="3-2-2-2-双向链表（Du-Link-List）"><a href="#3-2-2-2-双向链表（Du-Link-List）" class="headerlink" title="3.2.2.2 双向链表（Du-Link-List）"></a>3.2.2.2 双向链表（Du-Link-List）</h5><p>双向链表图片：</p>
<img data-src="/2016/06/08/Program-C/interview/DuLinkList.png" class="" title="DuLinkList">

<h5 id="3-2-2-3-循环链表（Cir-Link-List）"><a href="#3-2-2-3-循环链表（Cir-Link-List）" class="headerlink" title="3.2.2.3 循环链表（Cir-Link-List）"></a>3.2.2.3 循环链表（Cir-Link-List）</h5><p>循环链表图片：</p>
<img data-src="/2016/06/08/Program-C/interview/CirLinkList.png" class="" title="CirLinkList">

<h3 id="3-3-哈希表"><a href="#3-3-哈希表" class="headerlink" title="3.3 哈希表"></a>3.3 哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p>
<h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1 概念"></a>3.3.1 概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p>
<h4 id="3-3-2-构造方法"><a href="#3-3-2-构造方法" class="headerlink" title="3.3.2 构造方法"></a>3.3.2 构造方法</h4><ul>
<li>直接定址法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ul>
<h4 id="3-3-3-冲突处理方法"><a href="#3-3-3-冲突处理方法" class="headerlink" title="3.3.3 冲突处理方法"></a>3.3.3 冲突处理方法</h4><ul>
<li>链地址法：key 相同的用单链表链接</li>
<li>开放定址法<ul>
<li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li>
<li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li>
<li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li>
</ul>
</li>
</ul>
<h4 id="3-3-4-线性探测的哈希表数据结构"><a href="#3-3-4-线性探测的哈希表数据结构" class="headerlink" title="3.3.4 线性探测的哈希表数据结构"></a>3.3.4 线性探测的哈希表数据结构</h4><details><summary>线性探测的哈希表数据结构和图片</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	RcdType *rcd;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure>

</details>

<img data-src="/2016/06/08/Program-C/interview/HashTable.png" class="" title="HashTable">


<h3 id="3-4-递归"><a href="#3-4-递归" class="headerlink" title="3.4 递归"></a>3.4 递归</h3><h4 id="3-4-1-概念"><a href="#3-4-1-概念" class="headerlink" title="3.4.1 概念"></a>3.4.1 概念</h4><p>函数直接或间接地调用自身</p>
<h4 id="3-4-2-递归与分治"><a href="#3-4-2-递归与分治" class="headerlink" title="3.4.2 递归与分治"></a>3.4.2 递归与分治</h4><ul>
<li>分治法<ul>
<li>问题的分解</li>
<li>问题规模的分解</li>
</ul>
</li>
<li>折半查找（递归）</li>
<li>归并查找（递归）</li>
<li>快速排序（递归）</li>
</ul>
<h4 id="3-4-3-递归与迭代"><a href="#3-4-3-递归与迭代" class="headerlink" title="3.4.3 递归与迭代"></a>3.4.3 递归与迭代</h4><ul>
<li>迭代：反复利用变量旧值推出新值</li>
<li>折半查找（迭代）</li>
<li>归并查找（迭代）</li>
</ul>
<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><details><summary>广义表的头尾链表存储表示和图片</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GLNode</span> &#123;</span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">GLNode</span> *hp, *tp;</span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure>

</details>

<img data-src="/2016/06/08/Program-C/interview/GeneralizedList1.png" class="" title="GeneralizedList1">

<h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><details><summary>扩展线性链表存储表示和图片</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GLNode1</span> &#123;</span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">GLNode1</span> *hp; <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GLNode1</span> *tp;</span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure>

</details>

<img data-src="/2016/06/08/Program-C/interview/GeneralizedList2.png" class="" title="GeneralizedList2">

<h3 id="3-5-二叉树"><a href="#3-5-二叉树" class="headerlink" title="3.5 二叉树"></a>3.5 二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p>
<h4 id="3-5-1-性质"><a href="#3-5-1-性质" class="headerlink" title="3.5.1 性质"></a>3.5.1 性质</h4><ol>
<li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;&#x3D; 1）</li>
<li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;&#x3D; 1）</li>
<li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1</li>
<li>有 n 个结点的完全二叉树深度 k &#x3D; ⌊ log<sub>2</sub>(n) ⌋ + 1 </li>
<li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;&#x3D; i &lt;&#x3D; n） 的结点<ol>
<li>若 i &#x3D; 1，为根，否则双亲为 ⌊ i &#x2F; 2 ⌋</li>
<li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li>
<li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li>
</ol>
</li>
</ol>
<h4 id="3-5-2-存储结构"><a href="#3-5-2-存储结构" class="headerlink" title="3.5.2 存储结构"></a>3.5.2 存储结构</h4><details><summary>二叉树数据结构</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

</details>


<h5 id="3-5-2-1-顺序存储"><a href="#3-5-2-1-顺序存储" class="headerlink" title="3.5.2.1 顺序存储"></a>3.5.2.1 顺序存储</h5><p>二叉树顺序存储图片：</p>
<img data-src="/2016/06/08/Program-C/interview/SqBinaryTree.png" class="" title="SqBinaryTree">

<h5 id="3-5-2-2-链式存储"><a href="#3-5-2-2-链式存储" class="headerlink" title="3.5.2.2 链式存储"></a>3.5.2.2 链式存储</h5><p>二叉树链式存储图片：</p>
<img data-src="/2016/06/08/Program-C/interview/LinkBinaryTree.png" class="" title="LinkBinaryTree">

<h4 id="3-5-3-遍历方式"><a href="#3-5-3-遍历方式" class="headerlink" title="3.5.3 遍历方式"></a>3.5.3 遍历方式</h4><ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后续遍历</li>
<li>层次遍历</li>
</ul>
<h4 id="3-5-4-分类"><a href="#3-5-4-分类" class="headerlink" title="3.5.4 分类"></a>3.5.4 分类</h4><ul>
<li>满二叉树</li>
<li>完全二叉树（堆）<ul>
<li>大顶堆：根 &gt;&#x3D; 左 &amp;&amp; 根 &gt;&#x3D; 右</li>
<li>小顶堆：根 &lt;&#x3D; 左 &amp;&amp; 根 &lt;&#x3D; 右</li>
</ul>
</li>
<li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li>
<li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;&#x3D; 1</li>
<li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul>
<li>LL型：根的左孩子右旋</li>
<li>RR型：根的右孩子左旋</li>
<li>LR型：根的左孩子左旋，再右旋</li>
<li>RL型：右孩子的左子树，先右旋，再左旋</li>
</ul>
</li>
</ul>
<h3 id="3-6-其他树及森林"><a href="#3-6-其他树及森林" class="headerlink" title="3.6 其他树及森林"></a>3.6 其他树及森林</h3><h4 id="3-6-1-树的存储结构"><a href="#3-6-1-树的存储结构" class="headerlink" title="3.6.1 树的存储结构"></a>3.6.1 树的存储结构</h4><ul>
<li>双亲表示法</li>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h4 id="3-6-2-并查集"><a href="#3-6-2-并查集" class="headerlink" title="3.6.2 并查集"></a>3.6.2 并查集</h4><p>一种不相交的子集所构成的集合 S &#x3D; {S1, S2, …, Sn}</p>
<h4 id="3-6-3-平衡二叉树（AVL树）"><a href="#3-6-3-平衡二叉树（AVL树）" class="headerlink" title="3.6.3 平衡二叉树（AVL树）"></a>3.6.3 平衡二叉树（AVL树）</h4><h5 id="3-6-3-1-性质"><a href="#3-6-3-1-性质" class="headerlink" title="3.6.3.1 性质"></a>3.6.3.1 性质</h5><ul>
<li>| 左子树树高 - 右子树树高 | &lt;&#x3D; 1</li>
<li>平衡二叉树必定是二叉搜索树，反之则不一定</li>
<li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li>
</ul>
<p>平衡二叉树图片：</p>
<img data-src="/2016/06/08/Program-C/interview/Self-balancingBinarySearchTree.png" class="" title="Self-balancingBinarySearchTree">

<h5 id="3-6-3-2-最小失衡树"><a href="#3-6-3-2-最小失衡树" class="headerlink" title="3.6.3.2 最小失衡树"></a>3.6.3.2 最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p>
<p>调整：</p>
<ul>
<li>LL 型：根的左孩子右旋</li>
<li>RR 型：根的右孩子左旋</li>
<li>LR 型：根的左孩子左旋，再右旋</li>
<li>RL 型：右孩子的左子树，先右旋，再左旋</li>
</ul>
<h4 id="3-6-4-红黑树"><a href="#3-6-4-红黑树" class="headerlink" title="3.6.4 红黑树"></a>3.6.4 红黑树</h4><h5 id="3-6-4-1-红黑树的特征是什么？"><a href="#3-6-4-1-红黑树的特征是什么？" class="headerlink" title="3.6.4.1 红黑树的特征是什么？"></a>3.6.4.1 红黑树的特征是什么？</h5><ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是 NIL 节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li>
</ol>
<h5 id="3-6-4-2-调整"><a href="#3-6-4-2-调整" class="headerlink" title="3.6.4.2 调整"></a>3.6.4.2 调整</h5><ol>
<li>变色</li>
<li>左旋</li>
<li>右旋</li>
</ol>
<h5 id="3-6-4-3-应用"><a href="#3-6-4-3-应用" class="headerlink" title="3.6.4.3 应用"></a>3.6.4.3 应用</h5><ul>
<li>关联数组：如 STL 中的 map、set</li>
</ul>
<h5 id="3-6-4-4-红黑树、B-树、B-树的区别？"><a href="#3-6-4-4-红黑树、B-树、B-树的区别？" class="headerlink" title="3.6.4.4 红黑树、B 树、B+ 树的区别？"></a>3.6.4.4 红黑树、B 树、B+ 树的区别？</h5><ul>
<li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li>
<li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li>
</ul>
<h4 id="3-6-5-B-树（B-tree）、B-树（B-tree）"><a href="#3-6-5-B-树（B-tree）、B-树（B-tree）" class="headerlink" title="3.6.5 B 树（B-tree）、B+ 树（B+-tree）"></a>3.6.5 B 树（B-tree）、B+ 树（B+-tree）</h4><p>B 树、B+ 树图片：</p>
<img data-src="/2016/06/08/Program-C/interview/l6UyF.png" class="" title="B 树（B-tree）、B+ 树（B+-tree">

<h5 id="3-6-5-1-特点"><a href="#3-6-5-1-特点" class="headerlink" title="3.6.5.1 特点"></a>3.6.5.1 特点</h5><ul>
<li>一般化的二叉查找树（binary search tree）</li>
<li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li>
</ul>
<h5 id="3-6-5-2-应用"><a href="#3-6-5-2-应用" class="headerlink" title="3.6.5.2 应用"></a>3.6.5.2 应用</h5><ul>
<li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li>
</ul>
<h5 id="3-6-5-3-区别"><a href="#3-6-5-3-区别" class="headerlink" title="3.6.5.3 区别"></a>3.6.5.3 区别</h5><ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<h5 id="3-6-5-4-B树的优点"><a href="#3-6-5-4-B树的优点" class="headerlink" title="3.6.5.4 B树的优点"></a>3.6.5.4 B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<h5 id="3-6-5-5-B-树的优点"><a href="#3-6-5-5-B-树的优点" class="headerlink" title="3.6.5.5 B+树的优点"></a>3.6.5.5 B+树的优点</h5><ul>
<li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
<blockquote>
<p>B 树、B+ 树区别来自：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别</a></p>
</blockquote>
<h4 id="3-6-6-八叉树"><a href="#3-6-6-八叉树" class="headerlink" title="3.6.6 八叉树"></a>3.6.6 八叉树</h4><p>八叉树图片：</p>
<img data-src="/2016/06/08/Program-C/interview/400px-Octree2.png" class="" title="img">

<p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<h5 id="3-6-6-1-用途"><a href="#3-6-6-1-用途" class="headerlink" title="3.6.6.1 用途"></a>3.6.6.1 用途</h5><ul>
<li>三维计算机图形</li>
<li>最邻近搜索</li>
</ul>
<h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2><h3 id="4-1-排序"><a href="#4-1-排序" class="headerlink" title="4.1 排序"></a>4.1 排序</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/SelectionSort.h">选择排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td><a href="Algorithm/InsertSort.h">插入排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/QuickSort.h">快速排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/HeapSort.cpp">堆排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/MergeSort.h">归并排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/ShellSort.h">希尔排序</a></td>
<td>O(n*log<sup>2</sup>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/CountSort.cpp">计数排序</a></td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/BucketSort.cpp">桶排序</a></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/RadixSort.h">基数排序</a></td>
<td>O(k*n)</td>
<td>O(n<sup>2</sup>)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>均按从小到大排列</li>
<li>k：代表数值中的 “数位” 个数</li>
<li>n：代表数据规模</li>
<li>m：代表数据的最大值减最小值</li>
<li>来自：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法</a></li>
</ul>
</blockquote>
<h3 id="4-2-查找"><a href="#4-2-查找" class="headerlink" title="4.2 查找"></a>4.2 查找</h3><table>
<thead>
<tr>
<th>查找算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>查找条件</th>
</tr>
</thead>
<tbody><tr>
<td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/InsertionSearch.h">插值查找</a></td>
<td>O(log<sub>2</sub>(log<sub>2</sub>n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="DataStructure/HashTable.cpp">哈希查找</a></td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树&#x2F;B+树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-3-图搜索算法"><a href="#4-3-图搜索算法" class="headerlink" title="4.3 图搜索算法"></a>4.3 图搜索算法</h3><table>
<thead>
<tr>
<th>图搜索算法</th>
<th>数据结构</th>
<th>遍历时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索</a></td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索</a></td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
</tbody></table>
<h3 id="4-4-其他算法"><a href="#4-4-其他算法" class="headerlink" title="4.4 其他算法"></a>4.4 其他算法</h3><table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></td>
<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题</a>、排序算法（快速排序、归并排序）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></td>
<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td>
<td><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题</a>、斐波那契数列</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法</a></td>
<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td>
<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td>
</tr>
</tbody></table>
<h2 id="5-Problems"><a href="#5-Problems" class="headerlink" title="5. Problems"></a>5. Problems</h2><h3 id="5-1-Single-Problem"><a href="#5-1-Single-Problem" class="headerlink" title="5.1 Single Problem"></a>5.1 Single Problem</h3><ul>
<li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li>
<li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li>
<li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li>
<li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li>
<li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li>
</ul>
<h3 id="5-2-Leetcode-Problems"><a href="#5-2-Leetcode-Problems" class="headerlink" title="5.2 Leetcode Problems"></a>5.2 Leetcode Problems</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/haoel/leetcode">Github . haoel&#x2F;leetcode</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pezy/LeetCode">Github . pezy&#x2F;LeetCode</a></li>
</ul>
<h3 id="5-3-剑指-Offer"><a href="#5-3-剑指-Offer" class="headerlink" title="5.3 剑指 Offer"></a>5.3 剑指 Offer</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zhedahht/CodingInterviewChinese2">Github . zhedahht&#x2F;CodingInterviewChinese2</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gatieme/CodingInterviews">Github . gatieme&#x2F;CodingInterviews</a></li>
</ul>
<h3 id="5-4-Cracking-the-Coding-Interview-程序员面试金典"><a href="#5-4-Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="5.4 Cracking the Coding Interview 程序员面试金典"></a>5.4 Cracking the Coding Interview 程序员面试金典</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/careercup/ctci">Github . careercup&#x2F;ctci</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/cracking-the-coding-interview">牛客网 . 程序员面试金典</a></li>
</ul>
<h3 id="5-5-牛客网"><a href="#5-5-牛客网" class="headerlink" title="5.5 牛客网"></a>5.5 牛客网</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/activity/oj">牛客网 . 在线编程专题</a></li>
</ul>
<h2 id="6-操作系统"><a href="#6-操作系统" class="headerlink" title="6. 操作系统"></a>6. 操作系统</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26054925">【构建操作系统】进程间通信</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangzhen209/article/details/78249288">C++ 高性能服务器网络框架设计细节</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21516827/answer/53576754">epoll编程，如何实现高并发服务器开发？</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38552590">如何实现高并发服务器开发</a></p>
</blockquote>
<h3 id="6-1-进程与线程"><a href="#6-1-进程与线程" class="headerlink" title="6.1 进程与线程"></a>6.1 进程与线程</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoweifu/article/details/46835437">编程思想之多线程与多进程(4)——C++中的多线程</a></p>
</blockquote>
<p>对于有线程系统：</p>
<ul>
<li>进程是资源分配的独立单位</li>
<li>线程是资源调度的独立单位</li>
</ul>
<p>对于无线程系统：</p>
<ul>
<li>进程是资源调度、分配的独立单位</li>
</ul>
<h4 id="6-1-1-进程之间的通信方式以及优缺点"><a href="#6-1-1-进程之间的通信方式以及优缺点" class="headerlink" title="6.1.1 进程之间的通信方式以及优缺点"></a>6.1.1 进程之间的通信方式以及优缺点</h4><ul>
<li>管道（PIPE）<ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul>
<li>优点：简单方便</li>
<li>缺点：<ol>
<li>局限于单向通信 </li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
</li>
<li>套接字（Socket）：可用于不同及其间的进程通信<ul>
<li>优点：<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h4 id="6-1-2-线程之间的通信方式"><a href="#6-1-2-线程之间的通信方式" class="headerlink" title="6.1.2 线程之间的通信方式"></a>6.1.2 线程之间的通信方式</h4><ul>
<li>锁机制：包括互斥锁&#x2F;量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul>
<li>互斥锁&#x2F;量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p>
<blockquote>
<p>进程之间的通信方式以及优缺点来源于：<a target="_blank" rel="noopener" href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结</a></p>
</blockquote>
<h4 id="6-1-3-进程之间私有和共享的资源"><a href="#6-1-3-进程之间私有和共享的资源" class="headerlink" title="6.1.3 进程之间私有和共享的资源"></a>6.1.3 进程之间私有和共享的资源</h4><ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h4 id="6-1-4-线程之间私有和共享的资源"><a href="#6-1-4-线程之间私有和共享的资源" class="headerlink" title="6.1.4 线程之间私有和共享的资源"></a>6.1.4 线程之间私有和共享的资源</h4><ul>
<li>私有：线程栈，寄存器，程序寄存器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h4 id="6-1-5-多进程与多线程间的对比、优劣与选择"><a href="#6-1-5-多进程与多线程间的对比、优劣与选择" class="headerlink" title="6.1.5 多进程与多线程间的对比、优劣与选择"></a>6.1.5 多进程与多线程间的对比、优劣与选择</h4><h5 id="6-1-5-1-对比"><a href="#6-1-5-1-对比" class="headerlink" title="6.1.5.1 对比"></a>6.1.5.1 对比</h5><table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<h5 id="6-1-5-2-优劣"><a href="#6-1-5-2-优劣" class="headerlink" title="6.1.5.2 优劣"></a>6.1.5.2 优劣</h5><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody></table>
<h5 id="6-1-5-3-选择"><a href="#6-1-5-3-选择" class="headerlink" title="6.1.5.3 选择"></a>6.1.5.3 选择</h5><ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h4 id="6-1-6-多进程并发"><a href="#6-1-6-多进程并发" class="headerlink" title="6.1.6 多进程并发"></a>6.1.6 多进程并发</h4><h5 id="6-1-6-1-优点："><a href="#6-1-6-1-优点：" class="headerlink" title="6.1.6.1 优点："></a>6.1.6.1 优点：</h5><ul>
<li>将应用程序分为多个、独立的、单纯和的进程，它们运行在同一时刻，就像你可以同时进行网页浏览和文字处理，这些独立的进程可以通过所有常规的进程间通信渠道互相传递信息（信号、套接字、文件、管道等）。</li>
<li>操作系统在进程间提供的附加保护操作和更高级别的通信机制，意味着可以比线程更容易地编写安全的并发代码。</li>
<li>使用独立的进程实现并发，可以在网络连接的不同的机器上运行独立的进程，虽然这增加了通信成本，但在一个精心设计的系统上，这可能是一个提高并行可用行和提高性能的低成本方法。</li>
</ul>
<h5 id="6-1-6-2-缺点："><a href="#6-1-6-2-缺点：" class="headerlink" title="6.1.6.2 缺点："></a>6.1.6.2 缺点：</h5><ul>
<li>这种进程之间的通信通常设置复杂，或是速度较慢，或两者兼备，因为操作系统通常在进程间提供了大量的保护，以避免一个进程不小心修改了属于另一个进程的数据。</li>
<li>运行多个进和所需的固有开销：启动进程需要时间，操作系统必须投入内部资源来管理进程。</li>
</ul>
<h4 id="6-1-7-多线程并发"><a href="#6-1-7-多线程并发" class="headerlink" title="6.1.7 多线程并发"></a>6.1.7 多线程并发</h4><h5 id="6-1-7-1-优点："><a href="#6-1-7-1-优点：" class="headerlink" title="6.1.7.1 优点："></a>6.1.7.1 优点：</h5><ul>
<li>每个线程相互独立运行，且每个线程可以运行不同的指令序列。但进程中的所有的线程都共享相同的地址空间，并且从所有线程中访问大部分数据——全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</li>
<li>共享的地址空间，以及缺少线程间的数据保护，使得使用多线程相关的开销远小于使用多进程，因为操作系统有更少的簿记要做。</li>
</ul>
<h5 id="6-1-7-2-缺点："><a href="#6-1-7-2-缺点：" class="headerlink" title="6.1.7.2 缺点："></a>6.1.7.2 缺点：</h5><ul>
<li><p>虽然通常可以在进程之间共享内存，但这难以建立并且通常难以管理，因为同一数据的内存地址在不同的进程中也不尽相同。</p>
</li>
<li><p>共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么必须确保当每个线程访问时所看到的数据是一致的。</p>
</li>
</ul>
<h3 id="6-2-Linux-内核的同步方式"><a href="#6-2-Linux-内核的同步方式" class="headerlink" title="6.2 Linux 内核的同步方式"></a>6.2 Linux 内核的同步方式</h3><h4 id="6-2-1-原因"><a href="#6-2-1-原因" class="headerlink" title="6.2.1 原因"></a>6.2.1 原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实象多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p>
<h4 id="6-2-2-同步方式"><a href="#6-2-2-同步方式" class="headerlink" title="6.2.2 同步方式"></a>6.2.2 同步方式</h4><ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
<blockquote>
<p>来自：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分</a>、<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分</a></p>
</blockquote>
<h3 id="6-3-死锁"><a href="#6-3-死锁" class="headerlink" title="6.3 死锁"></a>6.3 死锁</h3><h4 id="6-3-1-原因"><a href="#6-3-1-原因" class="headerlink" title="6.3.1 原因"></a>6.3.1 原因</h4><ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<h4 id="6-3-2-产生条件"><a href="#6-3-2-产生条件" class="headerlink" title="6.3.2 产生条件"></a>6.3.2 产生条件</h4><ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li>环路</li>
</ul>
<h4 id="6-3-3-预防"><a href="#6-3-3-预防" class="headerlink" title="6.3.3 预防"></a>6.3.3 预防</h4><ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="6-4-文件系统"><a href="#6-4-文件系统" class="headerlink" title="6.4 文件系统"></a>6.4 文件系统</h3><ul>
<li>Windows：FCB 表 + FAT + 位图</li>
<li>Unix：inode + 混合索引 + 成组链接</li>
</ul>
<h3 id="6-5-主机字节序与网络字节序"><a href="#6-5-主机字节序与网络字节序" class="headerlink" title="6.5 主机字节序与网络字节序"></a>6.5 主机字节序与网络字节序</h3><h4 id="6-5-1-主机字节序（CPU-字节序）"><a href="#6-5-1-主机字节序（CPU-字节序）" class="headerlink" title="6.5.1 主机字节序（CPU 字节序）"></a>6.5.1 主机字节序（CPU 字节序）</h4><h5 id="6-5-1-1-概念"><a href="#6-5-1-1-概念" class="headerlink" title="6.5.1.1 概念"></a>6.5.1.1 概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p>
<ul>
<li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li>
<li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li>
</ul>
<h5 id="6-5-1-2-存储方式"><a href="#6-5-1-2-存储方式" class="headerlink" title="6.5.1.2 存储方式"></a>6.5.1.2 存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x00</th>
<th>0x01</th>
<th>0x02</th>
<th>0x03</th>
</tr>
</thead>
<tbody><tr>
<td>大端</td>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
<tr>
<td>小端</td>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody></table>
<p>大端小端图片：</p>
<img data-src="/2016/06/08/Program-C/interview/CPU-Big-Endian.svg.png" class="" title="CPU-Big-Endian.svg">

<img data-src="/2016/06/08/Program-C/interview/CPU-Little-Endian.svg.png" class="" title="CPU-Little-Endian.svg">

<h5 id="6-5-1-3-判断大端小端"><a href="#6-5-1-3-判断大端小端" class="headerlink" title="6.5.1.3 判断大端小端"></a>6.5.1.3 判断大端小端</h5><details><summary>判断大端小端</summary>

<p>可以这样判断自己 CPU 字节序是大端还是小端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*((<span class="type">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;大端&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h5 id="6-5-1-4-各架构处理器的字节序"><a href="#6-5-1-4-各架构处理器的字节序" class="headerlink" title="6.5.1.4 各架构处理器的字节序"></a>6.5.1.4 各架构处理器的字节序</h5><ul>
<li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System&#x2F;370、SPARC（除 V9 外）等处理器为大端序；</li>
<li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li>
</ul>
<h4 id="6-5-2-网络字节序"><a href="#6-5-2-网络字节序" class="headerlink" title="6.5.2 网络字节序"></a>6.5.2 网络字节序</h4><p>网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。</p>
<p>网络字节顺序采用：大端（Big Endian）排列方式。</p>
<h3 id="6-6-页面置换算法"><a href="#6-6-页面置换算法" class="headerlink" title="6.6 页面置换算法"></a>6.6 页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="6-6-1-分类"><a href="#6-6-1-分类" class="headerlink" title="6.6.1 分类"></a>6.6.1 分类</h4><ul>
<li>全局置换：在整个内存空间置换</li>
<li>局部置换：在本进程中进行置换</li>
</ul>
<h4 id="6-6-2-算法"><a href="#6-6-2-算法" class="headerlink" title="6.6.2 算法"></a>6.6.2 算法</h4><p>全局：</p>
<ul>
<li>工作集算法</li>
<li>缺页率置换算法</li>
</ul>
<p>局部：</p>
<ul>
<li>最佳置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用（LRU）算法</li>
<li>时钟（Clock）置换算法</li>
</ul>
<h2 id="7-计算机网络"><a href="#7-计算机网络" class="headerlink" title="7. 计算机网络"></a>7. 计算机网络</h2><p>计算机经网络体系结构：</p>
<img data-src="/2016/06/08/Program-C/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="" title="计算机经网络体系结构">

<h3 id="7-1-各层作用及协议"><a href="#7-1-各层作用及协议" class="headerlink" title="7.1 各层作用及协议"></a>7.1 各层作用及协议</h3><table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>将比特组装成帧和点到点的传递（帧 Frame）</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包从源到宿的传递和网际互连（包 Packet）</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话（会话协议数据单元 SPDU）</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>表示层</td>
<td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
</tbody></table>
<h3 id="7-2-物理层"><a href="#7-2-物理层" class="headerlink" title="7.2 物理层"></a>7.2 物理层</h3><ul>
<li>传输数据的单位 ———— 比特</li>
<li>数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点）</li>
</ul>
<p>通道：</p>
<ul>
<li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li>
<li>双向交替通行（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li>
<li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li>
</ul>
<p>通道复用技术：</p>
<ul>
<li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
<h3 id="7-3-数据链路层"><a href="#7-3-数据链路层" class="headerlink" title="7.3 数据链路层"></a>7.3 数据链路层</h3><p>主要信道：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h4 id="7-3-1-点对点信道"><a href="#7-3-1-点对点信道" class="headerlink" title="7.3.1 点对点信道"></a>7.3.1 点对点信道</h4><ul>
<li>数据单元 ———— 帧</li>
</ul>
<p>三个基本问题：</p>
<ul>
<li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li>
<li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li>
<li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li>
</ul>
<p>点对点协议（Point-to-Point Protocol）：</p>
<ul>
<li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li>
</ul>
<h4 id="7-3-2-广播信道"><a href="#7-3-2-广播信道" class="headerlink" title="7.3.2 广播信道"></a>7.3.2 广播信道</h4><p>广播通信：</p>
<ul>
<li>硬件地址（物理地址、MAC 地址）</li>
<li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li>
<li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li>
<li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li>
</ul>
<h3 id="7-4-网络层"><a href="#7-4-网络层" class="headerlink" title="7.4 网络层"></a>7.4 网络层</h3><ul>
<li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
</ul>
<h4 id="7-4-1-IP-网际协议"><a href="#7-4-1-IP-网际协议" class="headerlink" title="7.4.1 IP 网际协议"></a>7.4.1 IP 网际协议</h4><p>IP 地址分类：</p>
<ul>
<li><code>IP 地址 ::= &#123;&lt;网络号&gt;,&lt;主机号&gt;&#125;</code></li>
</ul>
<table>
<thead>
<tr>
<th>IP 地址类别</th>
<th>网络号</th>
<th>网络范围</th>
<th>主机号</th>
<th>IP 地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A 类</td>
<td>8bit，第一位固定为 0</td>
<td>0 —— 127</td>
<td>24bit</td>
<td>1.0.0.0 —— 127.255.255.255</td>
</tr>
<tr>
<td>B 类</td>
<td>16bit，前两位固定为  10</td>
<td>128.0 —— 191.255</td>
<td>16bit</td>
<td>128.0.0.0 —— 191.255.255.255</td>
</tr>
<tr>
<td>C  类</td>
<td>24bit，前三位固定为  110</td>
<td>192.0.0 —— 223.255.255</td>
<td>8bit</td>
<td>192.0.0.0 —— 223.255.255.255</td>
</tr>
<tr>
<td>D  类</td>
<td>前四位固定为 1110，后面为多播地址</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E  类</td>
<td>前五位固定为 11110，后面保留为今后所用</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>IP 数据报格式：</p>
<img data-src="/2016/06/08/Program-C/interview/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" class="" title="IP数据报格式">

<h4 id="7-4-2-ICMP-网际控制报文协议"><a href="#7-4-2-ICMP-网际控制报文协议" class="headerlink" title="7.4.2 ICMP 网际控制报文协议"></a>7.4.2 ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p>
<img data-src="/2016/06/08/Program-C/interview/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" class="" title="ICMP报文格式">

<p>应用：</p>
<ul>
<li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性<ul>
<li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li>
</ul>
</li>
</ul>
<h4 id="7-4-3-内部网关协议"><a href="#7-4-3-内部网关协议" class="headerlink" title="7.4.3 内部网关协议"></a>7.4.3 内部网关协议</h4><ul>
<li>RIP（Routing Information Protocol，路由信息协议）</li>
<li>OSPF（Open Sortest Path First，开放最短路径优先）</li>
</ul>
<h4 id="7-4-4-外部网关协议"><a href="#7-4-4-外部网关协议" class="headerlink" title="7.4.4 外部网关协议"></a>7.4.4 外部网关协议</h4><ul>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
</ul>
<h4 id="7-4-5-IP多播"><a href="#7-4-5-IP多播" class="headerlink" title="7.4.5 IP多播"></a>7.4.5 IP多播</h4><ul>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
<li>多播路由选择协议</li>
</ul>
<h4 id="7-4-6-VPN-和-NAT"><a href="#7-4-6-VPN-和-NAT" class="headerlink" title="7.4.6 VPN 和 NAT"></a>7.4.6 VPN 和 NAT</h4><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="7-4-7-路由表包含什么？"><a href="#7-4-7-路由表包含什么？" class="headerlink" title="7.4.7 路由表包含什么？"></a>7.4.7 路由表包含什么？</h4><ol>
<li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li>
<li>子网掩码（subnet mask）：用来判断 IP 所属网络</li>
<li>下一跳地址&#x2F;接口（Next hop &#x2F; interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li>
</ol>
<p>根据应用和执行的不同，路由表可能含有如下附加信息：</p>
<ol>
<li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li>
<li>路由的服务质量</li>
<li>路由中需要过滤的出&#x2F;入连接列表</li>
</ol>
<h3 id="7-5-运输层"><a href="#7-5-运输层" class="headerlink" title="7.5 运输层"></a>7.5 运输层</h3><p>协议：</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>UDP（User Datagram Protocol，用户数据报协议）</li>
</ul>
<p>端口：</p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>HTTPS</th>
<th>SNMP</th>
</tr>
</thead>
<tbody><tr>
<td>端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>443</td>
<td>161</td>
</tr>
</tbody></table>
<h4 id="7-5-1-TCP"><a href="#7-5-1-TCP" class="headerlink" title="7.5.1 TCP"></a>7.5.1 TCP</h4><ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li>
</ul>
<p>特征：</p>
<ul>
<li>面向连接</li>
<li>只能点对点（一对一）通信</li>
<li>可靠交互</li>
<li>全双工通信</li>
<li>面向字节流</li>
</ul>
<p>TCP 如何保证可靠传输：</p>
<ul>
<li>确认和超时重传</li>
<li>数据合理分片和排序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>数据校验</li>
</ul>
<p>TCP 报文结构</p>
<img data-src="/2016/06/08/Program-C/interview/TCP%E6%8A%A5%E6%96%87.png" class="" title="TCP报文">

<p>TCP 首部</p>
<img data-src="/2016/06/08/Program-C/interview/TCP%E9%A6%96%E9%83%A8.png" class="" title="TCP首部">

<p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p>
<ul>
<li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li>
<li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li>
<li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li>
<li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li>
<li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
</ul>
<h4 id="7-5-2-UDP"><a href="#7-5-2-UDP" class="headerlink" title="7.5.2 UDP"></a>7.5.2 UDP</h4><ul>
<li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li>
</ul>
<p>特征：</p>
<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>没有拥塞控制</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
<li>首部开销小</li>
</ul>
<p>UDP 报文结构</p>
<img data-src="/2016/06/08/Program-C/interview/UDP%E6%8A%A5%E6%96%87.png" class="" title="UDP报文">

<p>UDP 首部</p>
<img data-src="/2016/06/08/Program-C/interview/UDP%E9%A6%96%E9%83%A8.png" class="" title="UDP首部">

<blockquote>
<p>TCP&#x2F;UDP 图片来源于：<a target="_blank" rel="noopener" href="https://github.com/JerryC8080/understand-tcp-udp">https://github.com/JerryC8080/understand-tcp-udp</a></p>
</blockquote>
<h4 id="7-5-3-TCP-与-UDP-的区别"><a href="#7-5-3-TCP-与-UDP-的区别" class="headerlink" title="7.5.3 TCP 与 UDP 的区别"></a>7.5.3 TCP 与 UDP 的区别</h4><ol>
<li>TCP 面向连接，UDP 是无连接的；</li>
<li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li>
<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>
<li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li>
</ol>
<h4 id="7-5-4-TCP-黏包问题"><a href="#7-5-4-TCP-黏包问题" class="headerlink" title="7.5.4 TCP 黏包问题"></a>7.5.4 TCP 黏包问题</h4><h5 id="7-5-4-1-原因"><a href="#7-5-4-1-原因" class="headerlink" title="7.5.4.1 原因"></a>7.5.4.1 原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<h5 id="7-5-4-2-解决"><a href="#7-5-4-2-解决" class="headerlink" title="7.5.4.2 解决"></a>7.5.4.2 解决</h5><ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li>
<li>使用更加复杂的应用层协议。</li>
</ul>
<h4 id="7-5-5-TCP-流量控制"><a href="#7-5-5-TCP-流量控制" class="headerlink" title="7.5.5 TCP 流量控制"></a>7.5.5 TCP 流量控制</h4><h5 id="7-5-5-1-概念"><a href="#7-5-5-1-概念" class="headerlink" title="7.5.5.1 概念"></a>7.5.5.1 概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h5 id="7-5-5-2-方法"><a href="#7-5-5-2-方法" class="headerlink" title="7.5.5.2 方法"></a>7.5.5.2 方法</h5><p>利用可变窗口进行流量控制：</p>
<img data-src="/2016/06/08/Program-C/interview/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" class="" title="利用可变窗口进行流量控制举例">

<h4 id="7-5-6-TCP-拥塞控制"><a href="#7-5-6-TCP-拥塞控制" class="headerlink" title="7.5.6 TCP 拥塞控制"></a>7.5.6 TCP 拥塞控制</h4><h5 id="7-5-6-1-概念"><a href="#7-5-6-1-概念" class="headerlink" title="7.5.6.1 概念"></a>7.5.6.1 概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<h5 id="7-5-6-2-方法"><a href="#7-5-6-2-方法" class="headerlink" title="7.5.6.2 方法"></a>7.5.6.2 方法</h5><ul>
<li>慢开始( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )</li>
</ul>
<p>TCP的拥塞控制图：</p>
<img data-src="/2016/06/08/Program-C/interview/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" class="" title="TCP拥塞窗口cwnd在拥塞控制时的变化情况">

<img data-src="/2016/06/08/Program-C/interview/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="快重传示意图">

<img data-src="/2016/06/08/Program-C/interview/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="TCP的拥塞控制流程图">

<h4 id="7-5-7-TCP-传输连接管理"><a href="#7-5-7-TCP-传输连接管理" class="headerlink" title="7.5.7 TCP 传输连接管理"></a>7.5.7 TCP 传输连接管理</h4><blockquote>
<p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<a target="_blank" rel="noopener" href="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png</a></p>
</blockquote>
<h5 id="7-5-7-1-TCP-三次握手建立连接"><a href="#7-5-7-1-TCP-三次握手建立连接" class="headerlink" title="7.5.7.1 TCP 三次握手建立连接"></a>7.5.7.1 TCP 三次握手建立连接</h5><img data-src="/2016/06/08/Program-C/interview/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" class="" title="TCP三次握手建立连接">

<p>【TCP 建立连接全过程解释】</p>
<ol>
<li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li>
<li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li>
<li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li>
<li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li>
</ol>
<h5 id="7-5-7-2-TCP-为什么要进行三次握手？"><a href="#7-5-7-2-TCP-为什么要进行三次握手？" class="headerlink" title="7.5.7.2 TCP 为什么要进行三次握手？"></a>7.5.7.2 TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}</a></p>
</blockquote>
<p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24853633/answer/115173386">知乎 . TCP 为什么是三次握手，而不是两次或四次？</a></p>
</blockquote>
<p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/huihut/interview/blob/master/images/TCP-transport-connection-management.png">《计算机网络（第 7 版）-谢希仁》</a></p>
</blockquote>
<h5 id="7-5-7-3-TCP-四次挥手释放连接"><a href="#7-5-7-3-TCP-四次挥手释放连接" class="headerlink" title="7.5.7.3 TCP 四次挥手释放连接"></a>7.5.7.3 TCP 四次挥手释放连接</h5><img data-src="/2016/06/08/Program-C/interview/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" class="" title="TCP四次挥手释放连接">

<p>【TCP 释放连接全过程解释】</p>
<ol>
<li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li>
<li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li>
<li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li>
<li>服务端继续发送之前没发完的数据给客户端；</li>
<li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li>
<li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；</li>
<li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li>
</ol>
<h5 id="7-5-7-4-TCP-为什么要进行四次挥手？"><a href="#7-5-7-4-TCP-为什么要进行四次挥手？" class="headerlink" title="7.5.7.4 TCP 为什么要进行四次挥手？"></a>7.5.7.4 TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ &#x2F; 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p>
<p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p>
<p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p>
<p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p>
<p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p>
<p>【答案三】</p>
<ol>
<li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li>
<li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/overstack/article/details/8833894">Time-wait状态(2MSL)一些理解</a></p>
</blockquote>
<h4 id="7-5-8-TCP-有限状态机"><a href="#7-5-8-TCP-有限状态机" class="headerlink" title="7.5.8 TCP 有限状态机"></a>7.5.8 TCP 有限状态机</h4><p>TCP 有限状态机图片：</p>
<img data-src="/2016/06/08/Program-C/interview/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" class="" title="TCP的有限状态机">

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/335de1323ce9">TCP和UDP详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a5cf81b1a976">HTTP、TCP、UDP详解</a></p>
</blockquote>
<h3 id="7-6-应用层"><a href="#7-6-应用层" class="headerlink" title="7.6 应用层"></a>7.6 应用层</h3><h4 id="7-6-1-DNS"><a href="#7-6-1-DNS" class="headerlink" title="7.6.1 DNS"></a>7.6.1 DNS</h4><ul>
<li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li>
</ul>
<p>域名：</p>
<ul>
<li><code>域名 ::= &#123;&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;&#125;</code>，如：<code>blog.huihut.com</code></li>
</ul>
<h4 id="7-6-2-FTP"><a href="#7-6-2-FTP" class="headerlink" title="7.6.2 FTP"></a>7.6.2 FTP</h4><ul>
<li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户&#x2F;服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li>
</ul>
<h4 id="7-6-3-TELNET"><a href="#7-6-3-TELNET" class="headerlink" title="7.6.3 TELNET"></a>7.6.3 TELNET</h4><ul>
<li><p>TELNET 协议是 TCP&#x2F;IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p>
</li>
<li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p>
</li>
<li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP&#x2F;IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p>
</li>
<li><p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP&#x2F;IP 的封装，TCP&#x2F;IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p>
</li>
</ul>
<h4 id="7-6-4-WWW"><a href="#7-6-4-WWW" class="headerlink" title="7.6.4 WWW"></a>7.6.4 WWW</h4><ul>
<li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li>
</ul>
<h5 id="7-6-4-1-URL"><a href="#7-6-4-1-URL" class="headerlink" title="7.6.4.1 URL"></a>7.6.4.1 URL</h5><ul>
<li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li>
</ul>
<p>标准格式：</p>
<ul>
<li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<p>完整格式：</p>
<ul>
<li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<blockquote>
<p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p>
</blockquote>
<h5 id="7-6-4-2-HTTP"><a href="#7-6-4-2-HTTP" class="headerlink" title="7.6.4.2 HTTP"></a>7.6.4.2 HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>请求方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>OPTIONS</td>
<td>请求一些选项信息，允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody></table>
<p>状态码（Status-Code）</p>
<ul>
<li>1xx：表示通知信息，如请求收到了或正在进行处理<ul>
<li>100 Continue：继续，客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li>2xx：表示成功，如接收或知道了<ul>
<li>200 OK: 请求成功</li>
</ul>
</li>
<li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul>
<li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li>
</ul>
</li>
<li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized: 请求要求用户的身份认证</li>
<li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li>
<li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li>
<li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul>
<li>500 Internal Server Error: 服务器内部错误，无法完成请求</li>
<li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li>
<li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多状态码：<a target="_blank" rel="noopener" href="http://www.runoob.com/http/http-status-codes.html">菜鸟教程 . HTTP状态码</a></p>
</blockquote>
<h5 id="7-6-4-3-其他协议"><a href="#7-6-4-3-其他协议" class="headerlink" title="7.6.4.3 其他协议"></a>7.6.4.3 其他协议</h5><ul>
<li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul>
<li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段</li>
</ul>
</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li>
</ul>
<h2 id="8-网络编程"><a href="#8-网络编程" class="headerlink" title="8. 网络编程"></a>8. 网络编程</h2><h3 id="8-1-Socket"><a href="#8-1-Socket" class="headerlink" title="8.1 Socket"></a>8.1 Socket</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket 编程（不限 Linux）</a></p>
<img data-src="/2016/06/08/Program-C/interview/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" class="" title="socket客户端服务器通讯">


<h4 id="8-1-1-Socket-中的-read-、write-函数"><a href="#8-1-1-Socket-中的-read-、write-函数" class="headerlink" title="8.1.1 Socket 中的 read()、write() 函数"></a>8.1.1 Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-1-1-read"><a href="#8-1-1-1-read" class="headerlink" title="8.1.1.1 read()"></a>8.1.1.1 read()</h5><ul>
<li>read 函数是负责从 fd 中读取内容。</li>
<li>当读成功时，read 返回实际所读的字节数。</li>
<li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li>
<li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li>
</ul>
<h5 id="8-1-1-2-write"><a href="#8-1-1-2-write" class="headerlink" title="8.1.1.2 write()"></a>8.1.1.2 write()</h5><ul>
<li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li>
<li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li>
<li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li>
<li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li>
<li>（2）返回的值小于 0，此时出现了错误。</li>
<li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li>
</ul>
<h4 id="8-1-2-Socket-中-TCP-的三次握手建立连接"><a href="#8-1-2-Socket-中-TCP-的三次握手建立连接" class="headerlink" title="8.1.2 Socket 中 TCP 的三次握手建立连接"></a>8.1.2 Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p>
<ol>
<li>客户端向服务器发送一个 SYN J</li>
<li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li>
<li>客户端再想服务器发一个确认 ACK K+1</li>
</ol>
<p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p>
<img data-src="/2016/06/08/Program-C/interview/201012122157467258.png" class="" title="socket 中发送的 TCP 三次握手">

<p>从图中可以看出：</p>
<ol>
<li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li>
<li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li>
<li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li>
<li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li>
</ol>
<h4 id="8-1-3-Socket-中-TCP-的四次握手释放连接"><a href="#8-1-3-Socket-中-TCP-的四次握手释放连接" class="headerlink" title="8.1.3 Socket 中 TCP 的四次握手释放连接"></a>8.1.3 Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p>
<img data-src="/2016/06/08/Program-C/interview/201012122157487616.png" class="" title="socket 中发送的 TCP 四次握手">

<p>图示过程如下：</p>
<ol>
<li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li>
<li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li>
<li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li>
</ol>
<p>这样每个方向上都有一个 FIN 和 ACK。</p>
<h2 id="9-数据库"><a href="#9-数据库" class="headerlink" title="9. 数据库"></a>9. 数据库</h2><ul>
<li>数据库事务四大特性：原子性、一致性、分离性、持久性</li>
<li>数据库索引：顺序索引、B+ 树索引、hash 索引<br><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/sql/sql_constraints.asp">SQL 约束 (Constraints)</a></li>
</ul>
<h3 id="9-1-范式"><a href="#9-1-范式" class="headerlink" title="9.1 范式"></a>9.1 范式</h3><ul>
<li>第一范式（1NF）：属性（字段）是最小单位不可再分</li>
<li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）</li>
<li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）</li>
<li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）</li>
<li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）</li>
</ul>
<h2 id="10-设计模式"><a href="#10-设计模式" class="headerlink" title="10. 设计模式"></a>10. 设计模式</h2><blockquote>
<p>各大设计模式例子参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/15392.html">CSDN专栏 . C++ 设计模式</a> 系列博文</p>
</blockquote>
<p><a href="DesignPattern">设计模式工程目录</a></p>
<h3 id="10-1-单例模式"><a href="#10-1-单例模式" class="headerlink" title="10.1 单例模式"></a>10.1 单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p>
<h3 id="10-2-抽象工厂模式"><a href="#10-2-抽象工厂模式" class="headerlink" title="10.2 抽象工厂模式"></a>10.2 抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p>
<h3 id="10-3-适配器模式"><a href="#10-3-适配器模式" class="headerlink" title="10.3 适配器模式"></a>10.3 适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p>
<h3 id="10-4-桥接模式"><a href="#10-4-桥接模式" class="headerlink" title="10.4 桥接模式"></a>10.4 桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p>
<h3 id="10-5-观察者模式"><a href="#10-5-观察者模式" class="headerlink" title="10.5 观察者模式"></a>10.5 观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p>
<h3 id="10-6-设计模式的六大原则"><a href="#10-6-设计模式的六大原则" class="headerlink" title="10.6 设计模式的六大原则"></a>10.6 设计模式的六大原则</h3><ul>
<li>单一职责原则（SRP，Single Responsibility Principle）</li>
<li>里氏替换原则（LSP，Liskov Substitution Principle）</li>
<li>依赖倒置原则（DIP，Dependence Inversion Principle）</li>
<li>接口隔离原则（ISP，Interface Segregation Principle）</li>
<li>迪米特法则（LoD，Law of Demeter）</li>
<li>开放封闭原则（OCP，Open Close Principle）</li>
</ul>
<h2 id="11-链接装载库"><a href="#11-链接装载库" class="headerlink" title="11. 链接装载库"></a>11. 链接装载库</h2><h3 id="11-1-内存、栈、堆"><a href="#11-1-内存、栈、堆" class="headerlink" title="11.1 内存、栈、堆"></a>11.1 内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p>
<ul>
<li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li>
<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li>
<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<h4 id="11-1-1-栈"><a href="#11-1-1-栈" class="headerlink" title="11.1.1 栈"></a>11.1.1 栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存上下文：包括函数调用前后需要保持不变的寄存器</li>
</ul>
<h4 id="11-1-2-堆"><a href="#11-1-2-堆" class="headerlink" title="11.1.2 堆"></a>11.1.2 堆</h4><p>堆分配算法：</p>
<ul>
<li>空闲链表（Free List）</li>
<li>位图（Bitmap）</li>
<li>对象池</li>
</ul>
<h4 id="11-1-3-“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#11-1-3-“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="11.1.3 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read&#x2F;write”"></a>11.1.3 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read&#x2F;write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p>
<p>普遍原因：</p>
<ul>
<li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li>
<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li>
</ul>
<h3 id="11-2-编译链接"><a href="#11-2-编译链接" class="headerlink" title="11.2 编译链接"></a>11.2 编译链接</h3><h4 id="11-2-1-各平台文件格式"><a href="#11-2-1-各平台文件格式" class="headerlink" title="11.2.1 各平台文件格式"></a>11.2.1 各平台文件格式</h4><table>
<thead>
<tr>
<th>平台</th>
<th>可执行文件</th>
<th>目标文件</th>
<th>动态库&#x2F;共享对象</th>
<th>静态库</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>exe</td>
<td>obj</td>
<td>dll</td>
<td>lib</td>
</tr>
<tr>
<td>Unix&#x2F;Linux</td>
<td>ELF、out</td>
<td>o</td>
<td>so</td>
<td>a</td>
</tr>
<tr>
<td>Mac</td>
<td>Mach-O</td>
<td>o</td>
<td>dylib、tbd、framework</td>
<td>a、framework</td>
</tr>
</tbody></table>
<h4 id="11-2-2-编译链接过程"><a href="#11-2-2-编译链接过程" class="headerlink" title="11.2.2 编译链接过程"></a>11.2.2 编译链接过程</h4><ol>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li>
<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li>
</ol>
<blockquote>
<p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p>
</blockquote>
<blockquote>
<p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p>
</blockquote>
<h4 id="11-2-3-目标文件"><a href="#11-2-3-目标文件" class="headerlink" title="11.2.3 目标文件"></a>11.2.3 目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<blockquote>
<p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p>
</blockquote>
<h5 id="11-2-3-1-目标文件格式"><a href="#11-2-3-1-目标文件格式" class="headerlink" title="11.2.3.1 目标文件格式"></a>11.2.3.1 目标文件格式</h5><ul>
<li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li>
<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li>
<li>Intel&#x2F;Microsoft 的 OMF（Object Module Format）</li>
<li>Unix 的 <code>a.out</code> 格式</li>
<li>MS-DOS 的 <code>.COM</code> 格式</li>
</ul>
<blockquote>
<p>PE 和 ELF 都是 COFF（Common File Format）的变种</p>
</blockquote>
<h5 id="11-2-3-2-目标文件存储结构"><a href="#11-2-3-2-目标文件存储结构" class="headerlink" title="11.2.3.2 目标文件存储结构"></a>11.2.3.2 目标文件存储结构</h5><table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody></table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h4 id="11-2-4-链接的接口——符号"><a href="#11-2-4-链接的接口——符号" class="headerlink" title="11.2.4 链接的接口——符号"></a>11.2.4 链接的接口——符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>如下符号表（Symbol Table）：</p>
<table>
<thead>
<tr>
<th>Symbol（符号名）</th>
<th>Symbol Value （地址）</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>0x100</td>
</tr>
<tr>
<td>Add</td>
<td>0x123</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="11-3-Linux-的共享库（Shared-Library）"><a href="#11-3-Linux-的共享库（Shared-Library）" class="headerlink" title="11.3 Linux 的共享库（Shared Library）"></a>11.3 Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p>
<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p>
<h4 id="11-3-1-命名"><a href="#11-3-1-命名" class="headerlink" title="11.3.1 命名"></a>11.3.1 命名</h4><p><code>libname.so.x.y.z</code></p>
<ul>
<li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li>
<li>y：次版本号，高版本号向后兼容低版本号</li>
<li>z：发布版本号，不对接口进行更改，完全兼容</li>
</ul>
<h4 id="11-3-2-路径"><a href="#11-3-2-路径" class="headerlink" title="11.3.2 路径"></a>11.3.2 路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="11-3-3-环境变量"><a href="#11-3-3-环境变量" class="headerlink" title="11.3.3 环境变量"></a>11.3.3 环境变量</h4><ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="11-3-4-so-共享库的编写"><a href="#11-3-4-so-共享库的编写" class="headerlink" title="11.3.4 so 共享库的编写"></a>11.3.4 so 共享库的编写</h4><details><summary>使用 CLion 编写共享库</summary>

<p>创建一个名为 MySharedLib 的共享库</p>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure>

<p>library.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + <span class="built_in">sum</span>&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>library.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h4 id="11-3-5-so-共享库的使用（被可执行项目调用）"><a href="#11-3-5-so-共享库的使用（被可执行项目调用）" class="headerlink" title="11.3.5 so 共享库的使用（被可执行项目调用）"></a>11.3.5 so 共享库的使用（被可执行项目调用）</h4><details><summary>使用 CLion 调用共享库</summary>

<p>创建一个名为 TestSharedLib 的可执行项目</p>
<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 + 2 = &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 + 2 + 3 = &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span>, World!</span><br><span class="line"><span class="attribute">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="attribute">1</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="11-4-运行库（Runtime-Library）"><a href="#11-4-运行库（Runtime-Library）" class="headerlink" title="11.4 运行库（Runtime Library）"></a>11.4 运行库（Runtime Library）</h3><h4 id="11-4-1-典型程序运行步骤"><a href="#11-4-1-典型程序运行步骤" class="headerlink" title="11.4.1 典型程序运行步骤"></a>11.4.1 典型程序运行步骤</h4><ol>
<li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li>
<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I&#x2F;O、线程、全局变量构造等等）。</li>
<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I&#x2F;O等），然后进行系统调用结束进程。</li>
</ol>
<blockquote>
<p>一个程序的 I&#x2F;O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I&#x2F;O 指代操作系统理解为 “文件” 的事物。</p>
</blockquote>
<h4 id="11-4-2-glibc-入口"><a href="#11-4-2-glibc-入口" class="headerlink" title="11.4.2 glibc 入口"></a>11.4.2 glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p>
<p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p>
<h4 id="11-4-3-MSVC-CRT-入口"><a href="#11-4-3-MSVC-CRT-入口" class="headerlink" title="11.4.3 MSVC CRT 入口"></a>11.4.3 MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p>
<p>执行如下操作：</p>
<ol>
<li>初始化和 OS 版本有关的全局变量。</li>
<li>初始化堆。</li>
<li>初始化 I&#x2F;O。</li>
<li>获取命令行参数和环境变量。</li>
<li>初始化 C 库的一些数据。</li>
<li>调用 main 并记录返回值。</li>
<li>检查错误并将 main 的返回值返回。</li>
</ol>
<h4 id="11-4-4-C-语言运行库（CRT）"><a href="#11-4-4-C-语言运行库（CRT）" class="headerlink" title="11.4.4 C 语言运行库（CRT）"></a>11.4.4 C 语言运行库（CRT）</h4><p>大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I&#x2F;O：I&#x2F;O 功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h4 id="11-4-5-C语言标准库（ANSI-C）"><a href="#11-4-5-C语言标准库（ANSI-C）" class="headerlink" title="11.4.5 C语言标准库（ANSI C）"></a>11.4.5 C语言标准库（ANSI C）</h4><p>包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转换（stdlib.h）</li>
<li>时间&#x2F;日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h &amp; float.h）</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>
<h2 id="12-回调函数和钩子函数"><a href="#12-回调函数和钩子函数" class="headerlink" title="12. 回调函数和钩子函数"></a>12. 回调函数和钩子函数</h2><h3 id="12-1-什么是回调函数？"><a href="#12-1-什么是回调函数？" class="headerlink" title="12.1 什么是回调函数？"></a>12.1 什么是回调函数？</h3><p>简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 </p>
<h4 id="12-1-1-为什么要使用回调函数？"><a href="#12-1-1-为什么要使用回调函数？" class="headerlink" title="12.1.1 为什么要使用回调函数？"></a>12.1.1 为什么要使用回调函数？</h4><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为 int ）的被调用函数。 </p>
<p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、 shell 排序、 shake 排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（ int 、 float 、 string ），此时，该怎么办呢？可以使用函数指针，并进行回调。 </p>
<p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API 使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。 </p>
<p>另一个使用回调机制的 API 函数是 EnumWindow() ，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。 EnumWindow() 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。 </p>
<h4 id="12-1-2-使用场景"><a href="#12-1-2-使用场景" class="headerlink" title="12.1.2 使用场景"></a>12.1.2 使用场景</h4><p>不管怎么说，<strong>回调函数是继续自 C 语言的，因而，在 C++ 中，应只在与 C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 C++ 中应使用虚拟方法或函数符（ functor ），而不是回调函数</strong>。</p>
<h4 id="12-1-3-机制"><a href="#12-1-3-机制" class="headerlink" title="12.1.3 机制"></a>12.1.3 机制</h4><p>也可以这样，更容易理解：回调函数就好像是一个中断处理函数，系统在符合你设定的条件时自动调用。</p>
<p>为此，你需要做三件事：</p>
<ol>
<li><p>声明；</p>
</li>
<li><p>定义；</p>
</li>
<li><p>设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用。</p>
</li>
</ol>
<p>声明和定义时应注意：回调函数由系统调用，所以可以认为它属于WINDOWS系统，不要把它当作你的某个类的成员函数</p>
<p>回调函数是一个程序员不能显式调用的函数；通过将回调函数的地址传给调用者从而实现调用。回调函数使用是必要的，在我们想通过一个统一接口实现不同的内容，这时用回掉函数非常合适。比如，我们为几个不同的设备分别写了不同的显示函数：void TVshow(); void ComputerShow(); void NoteBookShow()…等等。这是我们想用一个统一的显示函数，我们这时就可以用回掉函数了。void show(void (*ptr)()); 使用时根据所传入的参数不同而调用不同的回调函数。</p>
<h4 id="12-1-4-参考"><a href="#12-1-4-参考" class="headerlink" title="12.1.4 参考"></a>12.1.4 参考</h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-cpitugpu-bcg.html">C语言中的回调函数</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/socho/article/details/51583112">c语言实现回调函数</a></p>
<p><a target="_blank" rel="noopener" href="http://www.runoob.com/cprogramming/c-fun-pointer-callback.html">函数指针</a></p>
</blockquote>
<h3 id="12-2-什么是钩子函数？"><a href="#12-2-什么是钩子函数？" class="headerlink" title="12.2 什么是钩子函数？"></a>12.2 什么是钩子函数？</h3><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。</p>
<h4 id="12-2-1-本质"><a href="#12-2-1-本质" class="headerlink" title="12.2.1 本质"></a>12.2.1 本质</h4><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p>
<h4 id="12-2-2-类型"><a href="#12-2-2-类型" class="headerlink" title="12.2.2 类型"></a>12.2.2 类型</h4><ol>
<li><p>局部钩子：仅钩挂您自己进程的事件。</p>
</li>
<li><p>远程钩子：可以钩挂自己进程或其他进程的事件，</p>
<p>远程钩子又分为两种：</p>
<ul>
<li>一种是系统级的全局钩子，</li>
<li>一种是线程级的钩子。</li>
</ul>
<p>全局钩子函数需要定义在 DLL 中，线程级的钩子中经常用到 GetCurrentThreadID 函数来获取当前线程的ID。</p>
</li>
</ol>
<h4 id="12-2-3-机制"><a href="#12-2-3-机制" class="headerlink" title="12.2.3 机制"></a>12.2.3 机制</h4><p>当创建一个钩子时，WINDOWS会先在内存中创建一个数据结构，该数据结构包含了钩子的相关信息，然后把该结构体加到已经存在的钩子链表中去。新的钩子将加到老的前面。当一个事件发生时，如果安装的是一个局部钩子，自己进程中的钩子函数将被调用。如果是一个远程钩子，系统就必须把钩子函数插入到其他进程的地址空间，要做到这一点要求钩子函数必须在一个动态链接库中，所以如果想要使用远程钩子，就必须把该钩子函数放到动态链接库中去。</p>
<p>两个例外：</p>
<ul>
<li>工作日志钩子</li>
<li>工作日志回放钩子。</li>
</ul>
<p>这两个钩子的钩子函数必须在安装钩子的线程中。原因是：</p>
<ul>
<li>这两个钩子是用来监控比较底层的硬件事件的，既然是记录和回放，所有的事件就当然都是有先后次序的。所以如果把回调函数放在DLL中，输入的事件被放在几个线程中记录，所以我们无法保证得到正确的次序。</li>
</ul>
<p>解决办法：把钩子函数放到单个的线程中，譬如安装钩子的线程。</p>
<h4 id="12-2-4-参考"><a href="#12-2-4-参考" class="headerlink" title="12.2.4 参考"></a>12.2.4 参考</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/128145.htm">浅谈c++ hook 钩子的使用介绍</a></p>
</blockquote>
<h3 id="12-3-异步消息的传递－回调机制"><a href="#12-3-异步消息的传递－回调机制" class="headerlink" title="12.3 异步消息的传递－回调机制"></a>12.3 异步消息的传递－回调机制</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-callback/index.html">异步消息的传递－回调机制</a></p>
</blockquote>
<h4 id="12-3-1-什么是回调"><a href="#12-3-1-什么是回调" class="headerlink" title="12.3.1 什么是回调"></a>12.3.1 什么是回调</h4><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：</p>
<ul>
<li>同步调用</li>
<li>回调</li>
<li>异步调用</li>
</ul>
<p>同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p>
<p><strong>回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知</strong>。</p>
<p>同步调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机制在不同软件架构中的实现。</p>
<img data-src="/2016/06/08/Program-C/interview/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6-01.gif" class="" title="回调机制-01">

<p>对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。</p>
<p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。</p>
<p>在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p>
<p>Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。</p>
<p>对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。</p>
<p>下面我们集中比较具有代表性的语言（C、Object Pascal）和架构（CORBA）来分析回调的实现方式、具体作用等。</p>
<h4 id="12-3-2-过程语言中的回调（C）"><a href="#12-3-2-过程语言中的回调（C）" class="headerlink" title="12.3.2 过程语言中的回调（C）"></a>12.3.2 过程语言中的回调（C）</h4><h5 id="12-3-2-1-函数指针"><a href="#12-3-2-1-函数指针" class="headerlink" title="12.3.2.1 函数指针"></a>12.3.2.1 函数指针</h5><p>回调在C语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> *s)</span>；	<span class="comment">// 函数原型</span></span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*pFunc)</span> <span class="params">(<span class="type">char</span> *)</span></span>;	<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure>

<p>可以看出，函数的定义和函数指针的定义非常类似。</p>
<p>一般的话，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pcb)</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。</p>
<p>被调函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetCallBack</span><span class="params">(pcb callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在调用上面的函数时，需要自己实现一个pcb类型的回调函数：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fCallback</span><span class="params">(<span class="type">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 然后，就可以直接把fCallback当作一个变量传递给GetCallBack,</span></span><br><span class="line">GetCallBack（fCallback）;</span><br></pre></td></tr></table></figure>

<p>如果赋了不同的值给该参数，那么调用者将调用不同地址的函数。赋值可以发生在运行时，这样使你能实现动态绑定。</p>
<h5 id="12-3-2-2-参数传递规则"><a href="#12-3-2-2-参数传递规则" class="headerlink" title="12.3.2.2 参数传递规则"></a>12.3.2.2 参数传递规则</h5><p>到目前为止，我们只讨论了函数指针及回调而没有去注意 ANSI C&#x2F;C++ 的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加 <code>_cdecl</code>，<code>_stdcall</code> 或者 <code>_pascal</code> 来表示其调用规范（默认为 <code>_cdecl</code>）。C++ Builder也支持 <code>_fastcall</code> 调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。</p>
<p>将调用规范看成是函数类型的一部分是很重要的；不能用不兼容的调用规范将地址赋值给函数指针。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用函数是以 int 为参数，以 int 为返回值</span></span><br><span class="line"><span class="function">__stdcall <span class="type">int</span> <span class="title">callee</span><span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line"><span class="comment">// 调用函数以函数指针为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">caller</span><span class="params">( __cdecl <span class="type">int</span>(*ptr)(<span class="type">int</span>))</span></span>; </span><br><span class="line"><span class="comment">// 在 p 中企图存储被调用函数地址的非法操作</span></span><br><span class="line"><span class="function">__cdecl <span class="title">int</span><span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span> </span>= callee; <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<p>指针 p 和 callee() 的类型不兼容，因为它们有不同的调用规范。因此不能将被调用者的地址赋值给指针p，尽管两者有相同的返回值和参数列</p>
<h5 id="12-3-2-3-应用举例"><a href="#12-3-2-3-应用举例" class="headerlink" title="12.3.2.3 应用举例"></a>12.3.2.3 应用举例</h5><p>C 语言的标准库函数中很多地方就采用了回调函数来让用户定制处理过程。如常用的快速排序函数、二分搜索函数等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序函数原型：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nelem, <span class="type">size_t</span> width, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> (_USERENTRY *fcmp)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 二分搜索函数原型：</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nelem, <span class="type">size_t</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> (_USERENTRY *fcmp)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 fcmp 就是一个回调函数的变量。</p>
<p>下面给出一个具体的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sort_function</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span>;</span><br><span class="line"><span class="type">int</span> list[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   <span class="built_in">qsort</span>((<span class="type">void</span> *)list, <span class="number">5</span>, <span class="built_in">sizeof</span>(list[<span class="number">0</span>]), sort_function);</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, list[x]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sort_function</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-3-3-回调在分布式计算中的应用（CORBA）"><a href="#12-3-3-回调在分布式计算中的应用（CORBA）" class="headerlink" title="12.3.3 回调在分布式计算中的应用（CORBA）"></a>12.3.3 回调在分布式计算中的应用（CORBA）</h4><h5 id="12-3-3-1-回调接口模型"><a href="#12-3-3-1-回调接口模型" class="headerlink" title="12.3.3.1 回调接口模型"></a>12.3.3.1 回调接口模型</h5><p>CORBA 的消息传递机制有很多种，比如回调接口、事件服务和通知服务等。回调接口的原理很简单，CORBA 客户和服务器都具有双重角色，即充当服务器也是客户客户。</p>
<p>回调接口的反向调用与正向调用往往是同时进行的，如果服务端多次调用该回调接口，那么这个回调接口就变成异步接口了。因此，回调接口在 CORBA 中常常充当事件注册的用途，客户端调用该注册函数时，客户函数就是回调函数，在此后的调用中，由于不需要客户端的主动参与，该函数就是实现了一种异步机制。</p>
<p>从 CORBA 规范我们知道，一个 CORBA 接口在服务端和客户端有不同的表现形式，在客户端一般使用桩（Stub）文件，服务端则用到框架（Skeleton）文件，接口的规格采用 IDL 来定义。而回调函数的引入，使得服务端和客户端都需要实现一定的桩和框架。下面是回调接口的实现模型：</p>
<img data-src="/2016/06/08/Program-C/interview/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6-02.gif" class="" title="回调机制-02">

<p>下面给出了一个使用回调的接口文件，服务端需要实现 Server 接口的框架，客户端需要实现 CallBack 的框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module cb</span><br><span class="line">&#123;</span><br><span class="line">    interface CallBack;</span><br><span class="line">    interface Server;</span><br><span class="line">    interface CallBack </span><br><span class="line">    &#123;</span><br><span class="line">    	void OnEvent(in long Source,in long msg);</span><br><span class="line">    &#125;;</span><br><span class="line">    interface Server </span><br><span class="line">    &#123;</span><br><span class="line">        long RegisterCB(in CallBack cb);</span><br><span class="line">        void UnRegisterCB(in long hCb);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户端首先通过同步方式调用服务端的接口 RegistCB，用来注册回调接口 CallBack。服务端收到该请求以后，就会保留该接口引用，如果发生某种事件需要向客户端通知的时候就通过该引用调用客户方的 OnEvent 函数，以便对方及时处理。</p>
<h2 id="13-野指针"><a href="#13-野指针" class="headerlink" title="13. 野指针"></a>13. 野指针</h2><h3 id="13-1-避免野指针的方法"><a href="#13-1-避免野指针的方法" class="headerlink" title="13.1 避免野指针的方法"></a>13.1 避免野指针的方法</h3><p>为了防止野指针带来的灾难，建议指针在定义时给一个初值，比如“NULL”，意思是不指向任何内存地址。然后再使用malloc函数给指针分配一块存储空间。</p>
<details><summary>避免野指针的方法</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str2 = <span class="literal">NULL</span>; <span class="comment">//str2 赋初值，不指向任何内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2的值是: %u\n&quot;</span>, str2);</span><br><span class="line">    </span><br><span class="line">    str2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2被分配的地址是: %u\n&quot;</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2指向的字符串是: %s\n&quot;</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != str2)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">free</span>(str2); <span class="comment">// 主动释放分配给str2的内存</span></span><br><span class="line">    	str2 = <span class="literal">NULL</span>; <span class="comment">// 让str2不指向任何内存    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>



<h2 id="14-海量数据处理"><a href="#14-海量数据处理" class="headerlink" title="14. 海量数据处理"></a>14. 海量数据处理</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/v_july_v/article/details/6685962"> 海量数据处理面试题集锦</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/v_JULY_v/article/details/6279498">十道海量数据处理面试题与十个方法大总结</a></li>
</ul>
<h2 id="15-音视频"><a href="#15-音视频" class="headerlink" title="15. 音视频"></a>15. 音视频</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.yunliaoim.com/im/1869.html">最全实时音视频开发要用到的开源工程汇总</a></li>
<li><a target="_blank" rel="noopener" href="http://webrtc.org.cn/18%E4%B8%AA%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">18个实时音视频开发中会用到开源项目</a></li>
</ul>
<h2 id="16-其他"><a href="#16-其他" class="headerlink" title="16. 其他"></a>16. 其他</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.stroustrup.com/bs_faq.html">Bjarne Stroustrup 的常见问题</a></li>
<li><a target="_blank" rel="noopener" href="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup 的 C++ 风格和技巧常见问题</a></li>
</ul>
<h2 id="17-书籍"><a href="#17-书籍" class="headerlink" title="17. 书籍"></a>17. 书籍</h2><h3 id="17-1-语言"><a href="#17-1-语言" class="headerlink" title="17.1 语言"></a>17.1 语言</h3><ul>
<li>《C++ Primer》</li>
<li>《Effective C++》</li>
<li>《More Effective C++》</li>
<li>《深度探索 C++ 对象模型》</li>
<li>《深入理解 C++11》</li>
<li>《STL 源码剖析》</li>
</ul>
<h3 id="17-2-算法"><a href="#17-2-算法" class="headerlink" title="17.2 算法"></a>17.2 算法</h3><ul>
<li>《剑指 Offer》</li>
<li>《编程珠玑》</li>
<li>《程序员面试宝典》</li>
</ul>
<h3 id="17-3-系统"><a href="#17-3-系统" class="headerlink" title="17.3 系统"></a>17.3 系统</h3><ul>
<li>《深入理解计算机系统》</li>
<li>《Windows 核心编程》</li>
<li>《Unix 环境高级编程》</li>
</ul>
<h3 id="17-4-网络"><a href="#17-4-网络" class="headerlink" title="17.4 网络"></a>17.4 网络</h3><ul>
<li>《Unix 网络编程》</li>
<li>《TCP&#x2F;IP 详解》</li>
</ul>
<h3 id="17-5-其他"><a href="#17-5-其他" class="headerlink" title="17.5 其他"></a>17.5 其他</h3><ul>
<li>《程序员的自我修养》</li>
</ul>
<h2 id="18-复习刷题网站"><a href="#18-复习刷题网站" class="headerlink" title="18. 复习刷题网站"></a>18. 复习刷题网站</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/">leetcode</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.net/">牛客网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/">慕课网</a></li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/">菜鸟教程</a></li>
</ul>
<h2 id="19-招聘时间岗位"><a href="#19-招聘时间岗位" class="headerlink" title="19. 招聘时间岗位"></a>19. 招聘时间岗位</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/activity/campus2019">牛客网 . 2019 IT名企校招指南</a></li>
</ul>
<h2 id="20-面试题目经验"><a href="#20-面试题目经验" class="headerlink" title="20. 面试题目经验"></a>20. 面试题目经验</h2><h3 id="20-1-牛客网"><a href="#20-1-牛客网" class="headerlink" title="20.1 牛客网"></a>20.1 牛客网</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/12805">牛客网 . 2017秋季校园招聘笔经面经专题汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/25268">牛客网 . 史上最全2017春招面经大合集！！</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/57978">牛客网 . 面试题干货在此</a></li>
</ul>
<h3 id="20-2-知乎"><a href="#20-2-知乎" class="headerlink" title="20.2 知乎"></a>20.2 知乎</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29693016">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24964987">知乎 . 互联网公司最常见的面试算法题有哪些？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20184857">知乎 . 面试 C++ 程序员，什么样的问题是好问题？</a></li>
</ul>
<h3 id="20-3-CSDN"><a href="#20-3-CSDN" class="headerlink" title="20.3 CSDN"></a>20.3 CSDN</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/ljzcome/article/details/574158">CSDN . 全面整理的C++面试题</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1">CSDN . 百度研发类面试题（C++方向）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/fakine/article/details/51321544">CSDN . c++常见面试题30道</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/onever_say_love/article/details/51223886">CSDN . 腾讯2016实习生面试经验（已经拿到offer)</a></li>
</ul>
<h3 id="20-4-cnblogs"><a href="#20-4-cnblogs" class="headerlink" title="20.4 cnblogs"></a>20.4 cnblogs</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Y1Focus/p/6707121.html">cnblogs . C++面试集锦( 面试被问到的问题 )</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html">cnblogs . C&#x2F;C++ 笔试、面试题目大汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LUO77/p/5771237.html">cnblogs . 常见C++面试题及基本知识点总结（一）</a></li>
</ul>
<h3 id="20-5-Segmentfault"><a href="#20-5-Segmentfault" class="headerlink" title="20.5 Segmentfault"></a>20.5 Segmentfault</h3><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003745529">segmentfault . C++常见面试问题总结</a></li>
</ul>
<h3 id="20-6-HTTP相关知识"><a href="#20-6-HTTP相关知识" class="headerlink" title="20.6 HTTP相关知识"></a>20.6 HTTP相关知识</h3><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012368732">你必须知道的HTTP基本概念</a></li>
<li><a target="_blank" rel="noopener" href="https://imququ.com/post/network-protocol-in-browser.html">浏览器中常见网络协议介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1007317">WebRTC介绍及简单应用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fishmai/article/details/69681595">WebRTC架构简介</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b14bd9ce51d450688134430">了不起的WebRTC：生态日趋完善，或将实时音视频技术白菜化</a></li>
</ul>
<h3 id="20-7-Spark"><a href="#20-7-Spark" class="headerlink" title="20.7 Spark"></a>20.7 Spark</h3><ul>
<li><a target="_blank" rel="noopener" href="http://spark.apachecn.org/docs/cn/2.2.0/">Apache Spark 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012185296/article/details/76855770">Apache Spark 2.2.0 官方文档中文版（翻译完成 98%. 除 MLib 外） | ApacheCN</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xwc35047/article/details/60330528">30分钟概览Spark分布式计算引擎</a></li>
</ul>
<h3 id="20-8-加密安全问题"><a href="#20-8-加密安全问题" class="headerlink" title="20.8 加密安全问题"></a>20.8 加密安全问题</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wufaliang003/article/details/79782168">SHA算法系列介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/225ff9439132">比特币背后的密码学原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiandiwuya/article/details/79571639">比特币的加密算法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/linuxprobe2017/article/details/62049001">密码学大事件！ SHA-1 哈希碰撞实例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/28527.html">如何安全的存储用户的密码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.aqniu.com/learn/30238.html">机器学习作用于信息安全的五大顶级案例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50853891">机器学习和数据挖掘在网络安全领域会有哪些应用？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.leiphone.com/news/201609/fY4pztt4RQsrOqji.html">机器学习正在安全领域挂起一阵小旋风，但这里面有BUG</a></li>
</ul>
<h3 id="20-9-其他"><a href="#20-9-其他" class="headerlink" title="20.9 其他"></a>20.9 其他</h3><ul>
<li><a target="_blank" rel="noopener" href="https://news.mbalib.com/story/88506">终于有人把P2P、P2C、O2O、B2C、B2B、C2C 的区别讲透了！</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35066939">如何真正让小程序,WebRTC和APP互通连麦直播</a></li>
<li><a target="_blank" rel="noopener" href="https://36kr.com/p/5117575.html">创业者必读：开发一款 App 到底需要多久？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/42c249168275">如何开发一个app（Android）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aaef5ceb3936">微信小程序开发教程–从零开始</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39931551">面向机器学习:数据平台的设计与搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b135482e51d4506dc0aaa14">基于Apache Spark以BigDL搭建可扩展的分布式深度学习框架</a></li>
<li></li>
</ul>
<h3 id="20-1高德面试"><a href="#20-1高德面试" class="headerlink" title="20.1高德面试"></a>20.1高德面试</h3><p>基本知识</p>
<p>1、进程和线程</p>
<p>2、多线程通讯方式</p>
<p>3、消费者和生产者模式（消费者是否轮询方式读取消息，用等待信号方式）</p>
<p>4、linux命令   top、netstat</p>
<p>5、gdb调试，怎样切换到某个线程</p>
<p>6、inline和宏定义区别</p>
<p>7、vector和list区别，什么情况分别是用什么</p>
<p>8、类的什么函数不能作为虚函数、析构函数能否作为虚函数，虚函数怎么实现的</p>
<p>9、setsocektopt   no-delay，等参数的作用</p>
<p>10、tcp关闭时的几个步骤，tcp的慢启动时啥意思，，，，</p>
<p>11、epoll模型，我说的是多线程，每个线程一个epoll，一个专门接收链接，另外的读数据 ，解码在哪个线程中进行</p>
<p>12、c++11 智能指针</p>
<p>13、死锁概念</p>
<p>14、什么叫做稳定排序、有哪些排序算法、快排怎么实现的</p>
<p>15、怎么样判断一棵树和平衡二叉树</p>
<p>16、当前编写代码（输入一个字符串和一个分隔符，，，，，，把字符串用分割符分割几部分，然后输出）</p>
<p>项目：</p>
<p>1、freeswitch的系统结构模型、并发的语音的最大路数，语音编码</p>
<p>2、视频花屏是怎样优化的</p>
<p>3、rtp，udp</p>
<p>4、语音包、和视频包是不是固定大小的，，，是否分包</p>

    </div><div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------------- 💖 🌞 本 文 结 束 😚 感 谢 您 的 阅 读 🌞 💖 -------------</div>
    
</div>


    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Mr.Miaow 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Mr.Miaow 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Mr.Miaow
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://miaopei.github.io/2016/06/08/Program-C/interview/" title="Interview C C++">http://miaopei.github.io/2016/06/08/Program-C/interview/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/c-c/" rel="tag"><i class="fa fa-tag"></i> c/c++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/06/05/Program-C/algorithm/" rel="prev" title="重拾十大经典排序算法">
                  <i class="fa fa-angle-left"></i> 重拾十大经典排序算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016/06/18/Program-C/STL/" rel="next" title="Interview STL">
                  Interview STL <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mr.Miaow</span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">825k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:30</span>
  </span>
</div> <div>
   <span id="sitetime"></span>
   <span id="year" style="display:none">2016</span> 
   <span id="month" style="display:none">12</span>   
   <span id="day" style="display:none">23</span>   
   <span id="hour" style="display:none">15</span>   
   <span id="minute" style="display:none">0</span>   
   <span id="second" style="display:none">0</span>   
	<script language=javascript>
	function siteTime(){        
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
	    var year = document.getElementById("year").innerHTML;
		var month = document.getElementById("month").innerHTML;
		var day = document.getElementById("day").innerHTML;
		var hour = document.getElementById("hour").innerHTML;
		var minute = document.getElementById("minute").innerHTML;
		var second = document.getElementById("second").innerHTML;
		var t1 = Date.UTC(year,month,day,hour,minute,second); 
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		if(diffYears==0){
		document.getElementById("sitetime").innerHTML=" 网站已运行 "/*+diffYears+" 年 "*/+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		} else{
		document.getElementById("sitetime").innerHTML=" 网站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		}
	}
	siteTime();
	</script>
</div>

<div class="busuanzi-count">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"miaopei","repo":"miaopei.github.io","client_id":"Ov23li804qbeklf03KFv","client_secret":"fce69a6b68a24543006d90b37dbe835082db6f23","admin_user":"miaopei","distraction_free_mode":true,"language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"a82b98c1423c315ac2079f6c377b2a74"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
